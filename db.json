{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/archive.png","path":"img/archive.png","modified":0,"renderable":0},{"_id":"source/img/background.jpg","path":"img/background.jpg","modified":0,"renderable":0},{"_id":"source/img/default_banner.jpg","path":"img/default_banner.jpg","modified":0,"renderable":0},{"_id":"source/img/default_img.png","path":"img/default_img.png","modified":0,"renderable":0},{"_id":"source/img/siteicon.ico","path":"img/siteicon.ico","modified":0,"renderable":0},{"_id":"source/img/sky.png","path":"img/sky.png","modified":0,"renderable":0},{"_id":"source/img/tom.jpg","path":"img/tom.jpg","modified":0,"renderable":0},{"_id":"source/img/yellow-wallpaper.jpg","path":"img/yellow-wallpaper.jpg","modified":0,"renderable":0},{"_id":"source/img/wechat.png","path":"img/wechat.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"124361edff89ab3216fa246915df470b96e9d212","modified":1663858543057},{"_id":"source/_posts/Markdown格式测试.md","hash":"8b729e2c0ece0365c061c34e6752414a36c978e4","modified":1664513880135},{"_id":"source/about/index.md","hash":"23bdc7b138bfb880e14d7532290dd10c949d26a2","modified":1663989248758},{"_id":"source/categories/index.md","hash":"7b9c5309bdf4a90a8ee49441b63799321eee5d67","modified":1663898669999},{"_id":"source/img/siteicon.ico","hash":"a3f21154b95286f7b0bc8b27864ae26058fa4468","modified":1663891526094},{"_id":"source/tags/index.md","hash":"2aeebe3737fc18ca6212e8c610f393c55e8063d1","modified":1663896402650},{"_id":"source/img/tom.jpg","hash":"69e8c436bdde019a7aa8784ad581940f77971a19","modified":1618460461367},{"_id":"source/img/default_img.png","hash":"91e0f37d1a87f702e8167d839776ac9a98bdff34","modified":1661241475641},{"_id":"source/img/archive.png","hash":"f806089a384a6c2d49709e76b2aed8d98a5f3264","modified":1661241361190},{"_id":"source/img/background.jpg","hash":"70dd12cafffa6f6f6bfae3a6e47c8cc76e5ccba7","modified":1662465549506},{"_id":"source/img/default_banner.jpg","hash":"c9f0a6c06e9c12305855b5a380b801f8e01ba21b","modified":1661241197729},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1663862553286},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":1663862552991},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"39baa882da9b0af5178c7767306be14bcf992a55","modified":1663862553295},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1663862552796},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"167c6a0729a9286a7f508c1dd6a9c689e8799008","modified":1663862552989},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1663862553306},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1663862553299},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1663862553303},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1663862553305},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1663862553301},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1663862553312},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1663862553310},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1663862553297},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1663862553314},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1663862552813},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1663862552805},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1663862552820},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1663862552827},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"9569c5c8f67d2783f372f671c57b93a00dc63c2f","modified":1663862552803},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"db000a6a0cec19d32a6e7e94cd4c478500d9c5ac","modified":1663862552861},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1663862552812},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1663862552864},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1663862552879},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1663862552895},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1663862552893},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"505bcc06e55066b7cc5551d9ac0694e7713bfab5","modified":1663862552882},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1663862552824},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1663862552826},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1663862552856},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1663862552863},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1663862552842},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"24ef242aa01e5f5bc397cf3f83ae48b1e8353dab","modified":1663862552838},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1663862552857},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1663862552887},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1663862552880},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1663862552850},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1663862552885},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":1663862552976},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1663862552959},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1663862552868},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1663862552949},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1663862552972},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1663862552932},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1663862552946},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1663862552929},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1663862552952},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1663862552933},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1663862552980},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1663862552963},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1663862552970},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1663862552982},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":1663862552937},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1663862552984},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"4543b8954c5c2ca91191cc0d53cf071b3f26faaa","modified":1663862552988},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1663862552953},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1663862552916},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1663862552967},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1663862552801},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1663862552940},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1663862552915},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1663862552969},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1663862552966},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1663862553249},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1663862552923},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1663862553265},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1663862552993},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1663862552978},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1663862553252},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1663862552912},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1663862553198},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"ba63f7c3324bc1fdd050a90add9d8faaffc27e07","modified":1663862552920},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1663862553201},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1663862552909},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1663862552981},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1663862552935},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1663862552945},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1663862552961},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"2333494add51e5e1374602a4e81f0be36a05d4c2","modified":1663862552975},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1663862552986},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1663862552835},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1663862552956},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1663862553292},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1663862552844},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1663862552852},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1663862552854},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1663862552866},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1663862552884},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":1663862552898},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1663862552901},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1663862552903},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1663862552846},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1663862552905},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1663862552818},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1663862552892},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1663862552809},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"38990ed9dbccd88342ee4b4cb5e60818e9eb8e8a","modified":1663862552876},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1663862552816},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1663862552837},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"1327395a4dde1ea06c476b047fb110bcd269149f","modified":1663862552807},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"e3713fa78e0fc14a239360b020068d8513573ae4","modified":1663862552847},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1663862552859},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"e49506e9895e255e0e53f34a11d325f83109c1b0","modified":1663862552871},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1663862552822},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1663862552849},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1663862552869},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"9d13392cea94b66d86422ad17c66e5ae67ce1d32","modified":1663862552840},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":1663862552900},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1663862552877},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"97e003371b76911522fb93c5180c9fdceed29488","modified":1663862552896},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1663862552874},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1663862552890},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1663862552888},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"0f02df2244e275595e72163498d42f42bcf0de5e","modified":1663862552943},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":1663862552872},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"2ec2ae03c79bb1ae7ac3fcf7e00fb52d1af2898d","modified":1663862552938},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1663862552942},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1663862553217},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1663862553226},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1663862552927},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1663862552955},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1663862552950},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1663862553205},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1663862553274},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1663862552965},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1663862553212},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1663862553219},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1663862553256},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1663862553231},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1663862553223},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1663862553258},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":1663862553237},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1663862553232},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1663862553263},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1663862553241},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1663862553250},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1663862553259},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1663862553266},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1663862553234},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"127bb5391370afe7fef2a297084d76406bc5e902","modified":1663862553277},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1663862553287},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1663862553279},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1663862553228},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1663862553235},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1663862553214},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1663862553209},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1663862553244},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1663862553245},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1663862553242},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1663862553268},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"0aa512c21a4b74ef2e70009786a1858d7c2fae9c","modified":1663862553247},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1663862553269},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1663862553271},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1663862553275},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1663862553282},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1663862553284},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1663862553289},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1663862553281},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1663862553188},{"_id":"source/img/yellow-wallpaper.jpg","hash":"25bc2186a5b55822c0467ea42075e064f8212e0e","modified":1660091838670},{"_id":"source/img/sky.png","hash":"fa9661ba36b1b92a7098c08c39791ce41a9d18e5","modified":1656507344977},{"_id":"public/local-search.xml","hash":"c6003b129ea04f56b1d8a61768f6faa51c336fbd","modified":1671283272219},{"_id":"public/about/index.html","hash":"a5ee003c9065843fe070285313f5bb9aaa72fd1d","modified":1664982286785},{"_id":"public/tags/index.html","hash":"5853e3c318211e09f3795569bb2a09758d25d4d8","modified":1671283079568},{"_id":"public/categories/index.html","hash":"4a27dafd4646aa71417e49aafcc8861000990542","modified":1671283079568},{"_id":"public/archives/index.html","hash":"2da91b3c86fdbf6418e18e0cb60f64d121a16dde","modified":1671283079568},{"_id":"public/categories/其他/index.html","hash":"68c29f00b029c0c46c58d4d19972bb3961198111","modified":1664982286785},{"_id":"public/archives/2022/index.html","hash":"4b6a0cde94182dd634ad445b6585d5f666e46a8b","modified":1671283079568},{"_id":"public/index.html","hash":"ac44d6b9b5b3b4d19ec01a04eac782eaceb1b295","modified":1671283079568},{"_id":"public/archives/2022/09/index.html","hash":"45309ed821a2ae15d052e6a11d4046965472fdf3","modified":1671283079568},{"_id":"public/tags/Test/index.html","hash":"7b162c0d4c4bab0e5b55d9dd9184d336a4ef61d3","modified":1664982286785},{"_id":"public/links/index.html","hash":"b2476246fd92832cac958d20cc3629ba3a1d726a","modified":1664982286785},{"_id":"public/404.html","hash":"9f51d2d50b8f65a68b89cff45a31457800e169fe","modified":1664982286785},{"_id":"public/2022/09/23/Markdown格式测试/index.html","hash":"d69b2d5556d3be48b43d3513fd88232d1afda47d","modified":1664982286785},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1663990319094},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1663990319094},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1663990319094},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1663990319094},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1663990319094},{"_id":"public/CNAME","hash":"124361edff89ab3216fa246915df470b96e9d212","modified":1663990319094},{"_id":"public/img/siteicon.ico","hash":"a3f21154b95286f7b0bc8b27864ae26058fa4468","modified":1663990319094},{"_id":"public/img/tom.jpg","hash":"69e8c436bdde019a7aa8784ad581940f77971a19","modified":1663990319094},{"_id":"public/css/highlight-dark.css","hash":"e7aa6abc7579cc0580551abbfa9d7dcf1b4f1b70","modified":1663990319094},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1663990319094},{"_id":"public/css/highlight.css","hash":"5234b47feb7617ed458ebc0f583530feac0e0063","modified":1663990319094},{"_id":"public/js/color-schema.js","hash":"ba63f7c3324bc1fdd050a90add9d8faaffc27e07","modified":1663990319094},{"_id":"public/css/main.css","hash":"feeac2c341ed1567a3b7168ff0e03c0402bd3b47","modified":1663990319094},{"_id":"public/img/default_img.png","hash":"91e0f37d1a87f702e8167d839776ac9a98bdff34","modified":1663990319094},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1663990319094},{"_id":"public/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1663990319094},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1663990319094},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1663990319094},{"_id":"public/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1663990319094},{"_id":"public/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1663990319094},{"_id":"public/js/plugins.js","hash":"2333494add51e5e1374602a4e81f0be36a05d4c2","modified":1663990319094},{"_id":"public/img/archive.png","hash":"f806089a384a6c2d49709e76b2aed8d98a5f3264","modified":1663990319094},{"_id":"public/img/background.jpg","hash":"70dd12cafffa6f6f6bfae3a6e47c8cc76e5ccba7","modified":1663990319094},{"_id":"public/img/default_banner.jpg","hash":"c9f0a6c06e9c12305855b5a380b801f8e01ba21b","modified":1663990319094},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1663990319094},{"_id":"public/img/yellow-wallpaper.jpg","hash":"25bc2186a5b55822c0467ea42075e064f8212e0e","modified":1663990319094},{"_id":"public/img/sky.png","hash":"fa9661ba36b1b92a7098c08c39791ce41a9d18e5","modified":1663990319094},{"_id":"source/img/wechat.png","hash":"b40999b8b782c28bef4583bafa3ed218afe36393","modified":1664088178099},{"_id":"public/img/wechat.png","hash":"b40999b8b782c28bef4583bafa3ed218afe36393","modified":1664088273691},{"_id":"source/_posts/观《正阳门下》.md","hash":"bf44f70e45e1a4a30e25a52cfb6517456017a32f","modified":1664514662994},{"_id":"public/categories/雅俗共赏/index.html","hash":"6ef82770c9de8b378a49de2aeba670bc1bc57a62","modified":1664514993033},{"_id":"public/tags/文化/index.html","hash":"29a368f621440450f556bf1b3ff5252f0ed4210e","modified":1664514993033},{"_id":"public/2022/09/30/观《正阳门下》/index.html","hash":"cd3d1b7e7e5a89444946781981a17e01ec2151a7","modified":1664514670149},{"_id":"source/_posts/观正阳门下.md","hash":"b24d05f2d0cb7513ebaefed504008b011e54ea4e","modified":1664598642169},{"_id":"public/2022/09/30/观正阳门下/index.html","hash":"220e7dbe1fd14967fb1acdc481fdbb3fe92bc654","modified":1664601274363},{"_id":"source/_posts/李约瑟之谜.md","hash":"fe935b815f0694bb3352e0453b1d6fb043409ad4","modified":1664895612894},{"_id":"public/archives/2022/10/index.html","hash":"ed8e70a110f7c2ed8ded751da4c38d7f006bcec5","modified":1671283079568},{"_id":"public/tags/中国经济/index.html","hash":"5ab1686f0a620ed6d2aa67e7294aeb670672780d","modified":1664982286785},{"_id":"public/categories/经济学/index.html","hash":"bdf0c3ce03d022a8b57cd2192c40df7d7c08206e","modified":1664982286785},{"_id":"public/2022/10/01/李约瑟之谜/index.html","hash":"e15217fcf04d3e75d3260368630af6427f024598","modified":1664982286785},{"_id":"source/_posts/目的论.md","hash":"923528db18ef593ebc822417211c2f999bb8b7e5","modified":1664602387452},{"_id":"public/2022/10/01/目的论/index.html","hash":"fe393afd6508e46f6e7b52ed4f21fe51d208f006","modified":1664607960998},{"_id":"public/categories/心理学/index.html","hash":"5346c451fda6cd0ceeeae908ae7e61cfbb0e694b","modified":1664601274363},{"_id":"public/tags/勇气心理学/index.html","hash":"927a078ed0ea99603f3e14631d0f41324b6a0354","modified":1664601274363},{"_id":"source/_posts/Linux系统启动时.md","hash":"b1bd464f18fb5e3d16b08dfbc167046a77dfaad8","modified":1664690748821},{"_id":"public/categories/操作系统/index.html","hash":"732fdac489590ed13ab35153e6a1a42d3fbc9bf5","modified":1664982286785},{"_id":"public/tags/操作系统/index.html","hash":"be6a3766f521dd4467e727bdfde3bb32b1f52d86","modified":1664982286785},{"_id":"public/tags/Linux/index.html","hash":"794a999aafef8ed1f9947faa555a91c1c99019e6","modified":1664982286785},{"_id":"public/tags/BIOS/index.html","hash":"1f59922d02c1e5949b0796279cd7dc8adf5cee8a","modified":1664982286785},{"_id":"public/tags/软硬件交互/index.html","hash":"b216935476b8863e152d895e3f3a650a866169b1","modified":1664982286785},{"_id":"public/2022/10/02/Linux系统启动时/index.html","hash":"e6f6c464fe96415a9d8b618ca9fde153f288a422","modified":1664982286785},{"_id":"source/_posts/近代屈辱与社会主义革命.md","hash":"906cd0d9ea5a054874457b2a7f48f7351c84a27a","modified":1664982393876},{"_id":"public/categories/经济学/中国经济/index.html","hash":"9b21380abeb906be7a1dc8b6439ac3b58fc89130","modified":1664982286785},{"_id":"public/2022/10/04/近代屈辱与社会主义革命/index.html","hash":"3b9acf868840344565ff8171d4105a5473f2d857","modified":1665833433773},{"_id":"source/_posts/Untitled.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1665826126601},{"_id":"source/_posts/BitTorrent协议.md","hash":"9557d40c256cc1483b15b4fef263b627ef671843","modified":1665474111505},{"_id":"public/archives/page/2/index.html","hash":"9f6a9bc975f5e5de951529bc615e63a2dceaf551","modified":1671283079568},{"_id":"public/archives/2022/page/2/index.html","hash":"a35e8bc4bea3a9c27bd2b0c1d252004117f38271","modified":1671283079568},{"_id":"public/categories/计算机网络/index.html","hash":"a61e44bcd3409f0043fef32bc4ec7b9749c201e7","modified":1671283079568},{"_id":"public/categories/计算机网络/分布式/index.html","hash":"246cddd72ca52b2cfd7c5c5097bb8e9abb09f532","modified":1665826111415},{"_id":"public/tags/P2P/index.html","hash":"08f2ab675f06f726ac1497992344f73254e35223","modified":1665826111415},{"_id":"public/2022/10/15/Untitled/index.html","hash":"0d98cc8594b9b9d1133cd880b17943801f02decc","modified":1665826111415},{"_id":"public/2022/10/09/BitTorrent协议/index.html","hash":"e79258d45f1d34317e929de187eb26379d12b5ea","modified":1668243006383},{"_id":"source/_posts/对JavaWeb的思考1.md","hash":"c07c59efabc2caf529843d56d570cb11832240c6","modified":1668912181487},{"_id":"public/2022/10/15/对JavaWeb的思考1/index.html","hash":"2bda6986ba283bf41e7d399dde8f7db23f5e48af","modified":1668929788349},{"_id":"public/categories/web开发/index.html","hash":"b904a83154cbebc17fd650e804abe5bf379a7882","modified":1668929788349},{"_id":"public/categories/web开发/java-web/index.html","hash":"298b0f9aaef0cf7c7f95982f7152ba8b71678dfb","modified":1668929788349},{"_id":"public/tags/web/index.html","hash":"024a4a31c487f364761819a73c83e8ebb360a8e4","modified":1668243006383},{"_id":"public/tags/java/index.html","hash":"49aed801d262f4bf9485ea5f633aac4ae5f3f67b","modified":1668929788349},{"_id":"source/_posts/java中的多态和多态绑定.md","hash":"be6d4ed6ec91aa71fe649aad376cf09a25e7d218","modified":1666359077890},{"_id":"public/archives/2022/10/page/2/index.html","hash":"38bd3dcf7184e559e73aa11be2c30df648f1182f","modified":1671283079568},{"_id":"public/categories/java/index.html","hash":"87473388d9ab1dc021dac7ed16ee59b79665e3d9","modified":1666359121218},{"_id":"public/tags/OOP/index.html","hash":"4d78c3bdcc6a4f2c32b3e01e27ae9a7d94585a5f","modified":1666359121218},{"_id":"public/2022/10/16/java中的多态和多态绑定/index.html","hash":"42ee7b8f429f037e4d47f945bc5ced9e1c338338","modified":1668243006383},{"_id":"source/_posts/Servlet优化.md","hash":"f4c41aff84fce724bf397c5e061ec3454e1a7527","modified":1668912167029},{"_id":"public/archives/2022/11/index.html","hash":"fbd6f34ef6b653ff2a31c1575fc153da09127a1a","modified":1671283079568},{"_id":"public/categories/web开发/javaee/index.html","hash":"8529c42ced7e089fc87a2ba6e88e20785c06f534","modified":1668241984040},{"_id":"public/tags/servlet/index.html","hash":"0a6ae1db25f6a6ed14eed4d192039b81cf60822e","modified":1668241984040},{"_id":"public/2022/11/10/Servlet优化/index.html","hash":"4a0d6827cf20027ed1b8a9b974419dec7dc91309","modified":1668929788349},{"_id":"source/_posts/事务管理基础.md","hash":"0eabeb18ac978ea020d9f8cc8308933f6c4800ab","modified":1668930069085},{"_id":"public/tags/JavaWeb/index.html","hash":"c1668c2a11227ca18aeefb60e416a53062f6ba1b","modified":1668929788349},{"_id":"public/2022/11/18/事务管理基础/index.html","hash":"444afb7657db225a191a1e267ceedde3a2afeb99","modified":1669006192931},{"_id":"source/_posts/稀疏矩阵及其运算.md","hash":"4f9ee0818d3b94d64babf9bd0b36cec2462fac13","modified":1669006506396},{"_id":"public/categories/数据结构和算法/index.html","hash":"14b246165434e0ba062380c2c81912e5d0ebfd4f","modified":1669006192931},{"_id":"public/2022/11/21/稀疏矩阵及其运算/index.html","hash":"53d79d627adcfe7aa6662fa6134d9a1feb4d7976","modified":1669031084886},{"_id":"public/tags/矩阵/index.html","hash":"9b5d1b6ff2151e161db1f2becf3187cb0d0ba2f2","modified":1669006192931},{"_id":"source/_posts/FTP协议.md","hash":"461c6954aaa022f00b5b2a9224871dd0d45cf485","modified":1669032249912},{"_id":"public/archives/page/3/index.html","hash":"0eafdcd49c8fcfeefc88d78ade17ebf3b539d2e3","modified":1671283079568},{"_id":"public/archives/2022/page/3/index.html","hash":"d0ca568edb4a4ce657dadc995f4742b06e4bb514","modified":1671283079568},{"_id":"public/2022/11/21/FTP协议/index.html","hash":"edf9be974b85ce16c1f7d4216c160632827f4429","modified":1671283079568},{"_id":"public/categories/计算机网络/应用层协议/index.html","hash":"e28d4d8bf2789132843efd7690b544dffea6db12","modified":1669031084886},{"_id":"public/page/2/index.html","hash":"3816d028137c77d19eeaebfcf4947d331d9d24c2","modified":1671283079568},{"_id":"public/tags/文件共享协议/index.html","hash":"d401449d766cd597cd0ee41eb6b31c137c95e08e","modified":1669031084886},{"_id":"source/_posts/TCP Wireshark实验.md","hash":"8a9d9b919982d53ac8725a0c9258a838cfd92fe9","modified":1671283268204},{"_id":"public/archives/2022/12/index.html","hash":"61f8b962904a07197a7f1af6eb50ae29adceebc7","modified":1671283079568},{"_id":"public/categories/计算机网络/运输层协议/index.html","hash":"0c9c713a91eb55c9a0edf41581f81b3d84a74145","modified":1671283079568},{"_id":"public/tags/TCP/index.html","hash":"c4d11e625e52e47a6bfb8078f930799369044adc","modified":1671283079568},{"_id":"public/2022/12/17/TCP Wireshark实验/index.html","hash":"b97a231fe5c917961989298eb5d196bfb0e383f1","modified":1671283272219}],"Category":[{"name":"其他","_id":"cl8fcvhay000404ru89b4f3et"},{"name":"雅俗共赏","_id":"cl8o126et0001o4rud73e4wz2"},{"name":"经济学","_id":"cl8p9um2q0001pcrub6kralm5"},{"name":"心理学","_id":"cl8pgmen90000z0ru11w0fkuy"},{"name":"操作系统","_id":"cl8qxsjhb0001bkrugm3rcwgb"},{"name":"中国经济","parent":"cl8p9um2q0001pcrub6kralm5","_id":"cl8vrh3ea0002gsrucddue00z"},{"name":"计算机网络","_id":"cl99pv6rk0002tkrugecjc3fo"},{"name":"分布式","parent":"cl99pv6rk0002tkrugecjc3fo","_id":"cl99pv6rv0005tkru9v8rco1i"},{"name":"web开发","_id":"cl99q176l00011oru8u0w8oo4"},{"name":"java web","parent":"cl99q176l00011oru8u0w8oo4","_id":"cl99q176x00041oru3u829a76"},{"name":"java","_id":"cl9ij7ew50001j4ru1lizesi2"},{"name":"javaee","parent":"cl99q176l00011oru8u0w8oo4","_id":"clado7pwh000294ru46d67o77"},{"name":"数据结构和算法","_id":"claqb7ea60001dsru3jcs08zl"},{"name":"应用层协议","parent":"cl99pv6rk0002tkrugecjc3fo","_id":"claqq0voy00029cru5k6w9eig"},{"name":"运输层协议","parent":"cl99pv6rk0002tkrugecjc3fo","_id":"clbrysqly0002gsrudqtr4xmh"}],"Data":[],"Page":[{"title":"About me","layout":"about","date":"2022-09-23T00:39:10.000Z","_content":"\n记录一个人的所见所闻，所思所想。\n","source":"about/index.md","raw":"---\ntitle: About me\nlayout: about\ndate: 2022-09-23 08:39:10\n---\n\n记录一个人的所见所闻，所思所想。\n","updated":"2022-09-24T03:14:08.758Z","path":"about/index.html","comments":1,"_id":"cl8fcvhac000004rubrvi6klt","content":"<p>记录一个人的所见所闻，所思所想。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>记录一个人的所见所闻，所思所想。</p>\n"},{"title":"categories","layout":"categories","banner":"/img/yellow-wallpaper.jpg","date":"2022-09-23T00:51:19.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\nlayout: categories\nbanner: /img/yellow-wallpaper.jpg\ndate: 2022-09-23 08:51:19\n---\n","updated":"2022-09-23T02:04:29.999Z","path":"categories/index.html","comments":1,"_id":"cl8fcvhah000104rubsz63kdt","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","layout":"tags","date":"2022-09-23T00:51:40.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\nlayout: tags\ndate: 2022-09-23 08:51:40\n---\n","updated":"2022-09-23T01:26:42.650Z","path":"tags/index.html","comments":1,"_id":"cl8fcvhap000204ru432zgajc","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Markdown样式测试","excerpt":"对fluid主题的markdown样式测试","date":"2022-09-23T00:39:10.000Z","_content":"\n# 代码块\n\n```java\npublic class Test{\n    public static void main(String args[]){\n        System.out.println(\"This a test.\");\n    }\n}\n```\n\n# 标签\n\n<p class=\"note note-primary\">primary标签</p>\n\n<p class=\"note note-info\">info标签</p>\n\n<p class=\"note note-success\">success标签</p>\n\n<p class=\"note note-danger\">danger标签</p>\n\n```markdown\n语法1：<p class=\"note note-primary\">primary标签</p>\n\n语法2: \n{% note success %}\n文字 或者 `markdown` 均可\n{% endnote %}\n\n行内标签： <span class=\"label label-primary\">Label</span>\n```\n\n# 表格\n\n```markdown\n| 姓名  | 年龄  | 介绍  |\n|:---:|:---:|:---:|\n| a   | 20  | 1   |\n| b   | 20  | 2   |\n| c   | 18  | 3   |\n```\n\n| 姓名  | 年龄  | 介绍  |\n|:---:|:---:|:---:|\n| a   | 20  | 1   |\n| b   | 20  | 2   |\n| c   | 18  | 3   |\n\n# 页面嵌套\n\n```markdown\n<iframe src=\"https://hexo.fluid-dev.com/\" width=\"100%\" height=\"500\" name=\"topFrame\" scrolling=\"yes\"  noresize=\"noresize\" frameborder=\"0\" id=\"topFrame\"></iframe>\n```\n\n<iframe src=\"https://hexo.fluid-dev.com/\" width=\"100%\" height=\"500\" name=\"topFrame\" scrolling=\"yes\"  noresize=\"noresize\" frameborder=\"0\" id=\"topFrame\"></iframe>\n\n# 折叠标签\n\n```markdown\n<details>\n<summary>这是一个折叠块</summary>\n<p><b>行一</b></p>\n<p><b>行二</b></p>\n<img width=\"200\" src=\"https://www.jianguoyun.com/c/dl-file/2022923102812.jpg?dt=rin5ma&sd=dlmq2&kv=MTE4NjU5OTA4MUBxcS5jb20&vr=1&ud=7ye0WsQXUj-HvwzVtVeuuWw0Lg28JNzUwHpN3F7Ivw4\" alt=\"wechat\">\n</details>\n```\n\n<details>\n<summary>这是一个折叠块</summary>\n<p><b>行一</b></p>\n<p><b>行二</b></p>\n<img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/凌波丽3.6folue9m3wk0.webp\" alt=\"凌波丽3\">\n</details>\n\n# 图片引用\n\n![凌波丽3](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/凌波丽3.6folue9m3wk0.webp)\n\n# 脚注\n\n```markdown\n脚注演示[^1]\n[^1]: 脚注内容演示\n[^2]: 脚注内容演示\n\n脚注演示[^2]\n[^2]: 脚注内容演示\n```\n\n脚注演示[^1]\n[^1]: 脚注内容演示\n[^2]: 脚注内容演示\n\n脚注演示[^2]\n[^2]: 脚注内容演示\n","source":"_posts/Markdown格式测试.md","raw":"---\ntitle: Markdown样式测试\nexcerpt: 对fluid主题的markdown样式测试\ndate: 2022-09-23 08:39:10\ntags: [Test]\ncategories: \n    - 其他\n---\n\n# 代码块\n\n```java\npublic class Test{\n    public static void main(String args[]){\n        System.out.println(\"This a test.\");\n    }\n}\n```\n\n# 标签\n\n<p class=\"note note-primary\">primary标签</p>\n\n<p class=\"note note-info\">info标签</p>\n\n<p class=\"note note-success\">success标签</p>\n\n<p class=\"note note-danger\">danger标签</p>\n\n```markdown\n语法1：<p class=\"note note-primary\">primary标签</p>\n\n语法2: \n{% note success %}\n文字 或者 `markdown` 均可\n{% endnote %}\n\n行内标签： <span class=\"label label-primary\">Label</span>\n```\n\n# 表格\n\n```markdown\n| 姓名  | 年龄  | 介绍  |\n|:---:|:---:|:---:|\n| a   | 20  | 1   |\n| b   | 20  | 2   |\n| c   | 18  | 3   |\n```\n\n| 姓名  | 年龄  | 介绍  |\n|:---:|:---:|:---:|\n| a   | 20  | 1   |\n| b   | 20  | 2   |\n| c   | 18  | 3   |\n\n# 页面嵌套\n\n```markdown\n<iframe src=\"https://hexo.fluid-dev.com/\" width=\"100%\" height=\"500\" name=\"topFrame\" scrolling=\"yes\"  noresize=\"noresize\" frameborder=\"0\" id=\"topFrame\"></iframe>\n```\n\n<iframe src=\"https://hexo.fluid-dev.com/\" width=\"100%\" height=\"500\" name=\"topFrame\" scrolling=\"yes\"  noresize=\"noresize\" frameborder=\"0\" id=\"topFrame\"></iframe>\n\n# 折叠标签\n\n```markdown\n<details>\n<summary>这是一个折叠块</summary>\n<p><b>行一</b></p>\n<p><b>行二</b></p>\n<img width=\"200\" src=\"https://www.jianguoyun.com/c/dl-file/2022923102812.jpg?dt=rin5ma&sd=dlmq2&kv=MTE4NjU5OTA4MUBxcS5jb20&vr=1&ud=7ye0WsQXUj-HvwzVtVeuuWw0Lg28JNzUwHpN3F7Ivw4\" alt=\"wechat\">\n</details>\n```\n\n<details>\n<summary>这是一个折叠块</summary>\n<p><b>行一</b></p>\n<p><b>行二</b></p>\n<img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/凌波丽3.6folue9m3wk0.webp\" alt=\"凌波丽3\">\n</details>\n\n# 图片引用\n\n![凌波丽3](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/凌波丽3.6folue9m3wk0.webp)\n\n# 脚注\n\n```markdown\n脚注演示[^1]\n[^1]: 脚注内容演示\n[^2]: 脚注内容演示\n\n脚注演示[^2]\n[^2]: 脚注内容演示\n```\n\n脚注演示[^1]\n[^1]: 脚注内容演示\n[^2]: 脚注内容演示\n\n脚注演示[^2]\n[^2]: 脚注内容演示\n","slug":"Markdown格式测试","published":1,"updated":"2022-09-30T04:58:00.135Z","_id":"cl8fcvhaq000304ruhtu74tux","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String args[])</span>&#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;This a test.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><p class=\"note note-primary\">primary标签</p>\n\n<p class=\"note note-info\">info标签</p>\n\n<p class=\"note note-success\">success标签</p>\n\n<p class=\"note note-danger\">danger标签</p>\n\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">语法1：<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;note note-primary&quot;</span>&gt;</span></span>primary标签<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><br>语法2: <br>&#123;% note success %&#125;<br>文字 或者 <span class=\"hljs-code\">`markdown`</span> 均可<br>&#123;% endnote %&#125;<br><br>行内标签： <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;label label-primary&quot;</span>&gt;</span></span>Label<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h1><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">| 姓名  | 年龄  | 介绍  |<br>|:---:|:---:|:---:|<br>| a   | 20  | 1   |<br>| b   | 20  | 2   |<br>| c   | 18  | 3   |<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">姓名</th>\n<th align=\"center\">年龄</th>\n<th align=\"center\">介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">a</td>\n<td align=\"center\">20</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">b</td>\n<td align=\"center\">20</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">18</td>\n<td align=\"center\">3</td>\n</tr>\n</tbody></table>\n<h1 id=\"页面嵌套\"><a href=\"#页面嵌套\" class=\"headerlink\" title=\"页面嵌套\"></a>页面嵌套</h1><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">iframe</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://hexo.fluid-dev.com/&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;100%&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;500&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;topFrame&quot;</span> <span class=\"hljs-attr\">scrolling</span>=<span class=\"hljs-string\">&quot;yes&quot;</span>  <span class=\"hljs-attr\">noresize</span>=<span class=\"hljs-string\">&quot;noresize&quot;</span> <span class=\"hljs-attr\">frameborder</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;topFrame&quot;</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">iframe</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<iframe src=\"https://hexo.fluid-dev.com/\" width=\"100%\" height=\"500\" name=\"topFrame\" scrolling=\"yes\"  noresize=\"noresize\" frameborder=\"0\" id=\"topFrame\"></iframe>\n\n<h1 id=\"折叠标签\"><a href=\"#折叠标签\" class=\"headerlink\" title=\"折叠标签\"></a>折叠标签</h1><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">details</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">summary</span>&gt;</span></span>这是一个折叠块<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">summary</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span></span>行一<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span></span>行二<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://www.jianguoyun.com/c/dl-file/2022923102812.jpg?dt=rin5ma&amp;sd=dlmq2&amp;kv=MTE4NjU5OTA4MUBxcS5jb20&amp;vr=1&amp;ud=7ye0WsQXUj-HvwzVtVeuuWw0Lg28JNzUwHpN3F7Ivw4&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;wechat&quot;</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">details</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<details>\n<summary>这是一个折叠块</summary>\n<p><b>行一</b></p>\n<p><b>行二</b></p>\n<img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/凌波丽3.6folue9m3wk0.webp\" alt=\"凌波丽3\">\n</details>\n\n<h1 id=\"图片引用\"><a href=\"#图片引用\" class=\"headerlink\" title=\"图片引用\"></a>图片引用</h1><p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/%E5%87%8C%E6%B3%A2%E4%B8%BD3.6folue9m3wk0.webp\" alt=\"凌波丽3\"></p>\n<h1 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a>脚注</h1><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">脚注演示<sup id=\"fnref:1\" class=\"footnote-ref\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"脚注内容演示\">[1]</span></a></sup><br>[<span class=\"hljs-symbol\">^1</span>]: <span class=\"hljs-link\">脚注内容演示</span><br>[<span class=\"hljs-symbol\">^2</span>]: <span class=\"hljs-link\">脚注内容演示</span><br><br>脚注演示<sup id=\"fnref:2\" class=\"footnote-ref\"><a href=\"#fn:2\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"脚注内容演示\">[2]</span></a></sup><br>[<span class=\"hljs-symbol\">^2</span>]: <span class=\"hljs-link\">脚注内容演示</span><br></code></pre></td></tr></table></figure>\n\n<p>脚注演示<sup id=\"fnref:1\" class=\"footnote-ref\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"脚注内容演示\">[1]</span></a></sup></p>\n<p>脚注演示<sup id=\"fnref:2\" class=\"footnote-ref\"><a href=\"#fn:2\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"脚注内容演示\">[2]</span></a></sup></p>\n<section class=\"footnotes\"><div class=\"footnote-list\"><ol><li><span id=\"fn:1\" class=\"footnote-text\"><span>脚注内容演示\n<a href=\"#fnref:1\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li><li><span id=\"fn:2\" class=\"footnote-text\"><span>脚注内容演示\n<a href=\"#fnref:2\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li><li><span id=\"fn:2\" class=\"footnote-text\"><span>脚注内容演示\n<a href=\"#fnref:2\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li></ol></div></section>","site":{"data":{}},"more":"<h1 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String args[])</span>&#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;This a test.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><p class=\"note note-primary\">primary标签</p>\n\n<p class=\"note note-info\">info标签</p>\n\n<p class=\"note note-success\">success标签</p>\n\n<p class=\"note note-danger\">danger标签</p>\n\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">语法1：<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;note note-primary&quot;</span>&gt;</span></span>primary标签<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><br>语法2: <br>&#123;% note success %&#125;<br>文字 或者 <span class=\"hljs-code\">`markdown`</span> 均可<br>&#123;% endnote %&#125;<br><br>行内标签： <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;label label-primary&quot;</span>&gt;</span></span>Label<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h1><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">| 姓名  | 年龄  | 介绍  |<br>|:---:|:---:|:---:|<br>| a   | 20  | 1   |<br>| b   | 20  | 2   |<br>| c   | 18  | 3   |<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">姓名</th>\n<th align=\"center\">年龄</th>\n<th align=\"center\">介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">a</td>\n<td align=\"center\">20</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">b</td>\n<td align=\"center\">20</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">18</td>\n<td align=\"center\">3</td>\n</tr>\n</tbody></table>\n<h1 id=\"页面嵌套\"><a href=\"#页面嵌套\" class=\"headerlink\" title=\"页面嵌套\"></a>页面嵌套</h1><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">iframe</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://hexo.fluid-dev.com/&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;100%&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;500&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;topFrame&quot;</span> <span class=\"hljs-attr\">scrolling</span>=<span class=\"hljs-string\">&quot;yes&quot;</span>  <span class=\"hljs-attr\">noresize</span>=<span class=\"hljs-string\">&quot;noresize&quot;</span> <span class=\"hljs-attr\">frameborder</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;topFrame&quot;</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">iframe</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<iframe src=\"https://hexo.fluid-dev.com/\" width=\"100%\" height=\"500\" name=\"topFrame\" scrolling=\"yes\"  noresize=\"noresize\" frameborder=\"0\" id=\"topFrame\"></iframe>\n\n<h1 id=\"折叠标签\"><a href=\"#折叠标签\" class=\"headerlink\" title=\"折叠标签\"></a>折叠标签</h1><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">details</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">summary</span>&gt;</span></span>这是一个折叠块<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">summary</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span></span>行一<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span></span>行二<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://www.jianguoyun.com/c/dl-file/2022923102812.jpg?dt=rin5ma&amp;sd=dlmq2&amp;kv=MTE4NjU5OTA4MUBxcS5jb20&amp;vr=1&amp;ud=7ye0WsQXUj-HvwzVtVeuuWw0Lg28JNzUwHpN3F7Ivw4&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;wechat&quot;</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">details</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<details>\n<summary>这是一个折叠块</summary>\n<p><b>行一</b></p>\n<p><b>行二</b></p>\n<img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/凌波丽3.6folue9m3wk0.webp\" alt=\"凌波丽3\">\n</details>\n\n<h1 id=\"图片引用\"><a href=\"#图片引用\" class=\"headerlink\" title=\"图片引用\"></a>图片引用</h1><p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/%E5%87%8C%E6%B3%A2%E4%B8%BD3.6folue9m3wk0.webp\" alt=\"凌波丽3\"></p>\n<h1 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a>脚注</h1><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">脚注演示<sup id=\"fnref:1\" class=\"footnote-ref\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"脚注内容演示\">[1]</span></a></sup><br>[<span class=\"hljs-symbol\">^1</span>]: <span class=\"hljs-link\">脚注内容演示</span><br>[<span class=\"hljs-symbol\">^2</span>]: <span class=\"hljs-link\">脚注内容演示</span><br><br>脚注演示<sup id=\"fnref:2\" class=\"footnote-ref\"><a href=\"#fn:2\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"脚注内容演示\">[2]</span></a></sup><br>[<span class=\"hljs-symbol\">^2</span>]: <span class=\"hljs-link\">脚注内容演示</span><br></code></pre></td></tr></table></figure>\n\n<p>脚注演示<sup id=\"fnref:1\" class=\"footnote-ref\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"脚注内容演示\">[1]</span></a></sup></p>\n<p>脚注演示<sup id=\"fnref:2\" class=\"footnote-ref\"><a href=\"#fn:2\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"脚注内容演示\">[2]</span></a></sup></p>\n<section class=\"footnotes\"><div class=\"footnote-list\"><ol><li><span id=\"fn:1\" class=\"footnote-text\"><span>脚注内容演示\n<a href=\"#fnref:1\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li><li><span id=\"fn:2\" class=\"footnote-text\"><span>脚注内容演示\n<a href=\"#fnref:2\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li><li><span id=\"fn:2\" class=\"footnote-text\"><span>脚注内容演示\n<a href=\"#fnref:2\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li></ol></div></section>"},{"title":"李约瑟之谜","date":"2022-10-01T00:55:26.000Z","banner_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/china.4g94cmuvtl40.webp","index_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.47ucdvvh76c0.webp","excerpt":"《解读中国经济》—为什么在前现代社会中国的科学技术十分发达？而在现代社会，中国又成为技术落后的国家？","_content":"\n# 观古今之中国\n\n## 前现代社会之辉煌\n\n<p class=\"note note-primary\">经济规模庞大</p>\n\n[麦迪森](https://baike.baidu.com/item/%E5%AE%89%E6%A0%BC%E6%96%AF%C2%B7%E9%BA%A6%E8%BF%AA%E6%A3%AE/5818140)在《世界经济千年史》中对很多国家的长期经济发展历史做了许多细致的研究，他认为，<u>**中国直到19世纪中叶还是全世界最大的经济体**</u>，在这之前的两千年时间里，中国也一直是最大最强的经济体。\n\n亚当斯·斯密的《国富论》中提到一个经济发展规律：<u>**劳动分工是经济发展的动力之一，分工越细，生产力水平就越高**</u>。但是分工的规模又取决于市场规模的大小，市场越大，分工就可以越细，否则即使提高产量，没那么大市场也卖不掉，就显得没啥必要了。这个规律就能用来解释欧洲和中国在古代的不同发展情况。\n\n![古罗马帝国与汉帝国](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.73d7frfifj80.webp)\n\n欧洲和中国在公元元年左右时，人均收入水平不相上下。此时欧洲正值古罗马帝国的盛世，中国也将迎来大汉的光武中兴。但欧洲在古罗马帝国分崩离析后，进入到封建社会，帝国变成了一个个独立的城邦，城邦之间商业贸易很少，因此市场规模急剧减小，由此造成分工和生产力水平低下。\n\n与欧洲不同的是，中国自汉朝以来，绝大部分时间是大一统的，这意味着中国的市场规模是十分庞大的，根据斯密的理论，中国的劳动分工水平必定不断提高，经济不断发展，因此中国经济在当时是首屈一指的。\n\n<p class=\"note note-info\">技术水平领先</p>\n\n**技术落后**是一个国家经济发展落后的主要标志，而在17，18世纪之前，中国的技术水平是世界领先的，就比如中国古代的四大发明，这四项技术让欧洲走出了黑暗的时代。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1k34ak7p0pi8.webp\" alt=\"四大发明\" style=\"zoom:50%;\" /></div>\n\n<p class=\"note note-success\">活跃的市场经济</p>\n\n现有理论认为**私有制是市场经济的基础，而土地的私有是私有制中最重要的一环**。中国在春秋战国时期就开始实行土地私有制，允许自由买卖土地；而欧洲在整个封建时期，土地都是属于贵族的，没有土地市场。\n\n《管子》里有言：“<u>国多财则远者来</u>”，这表明当时的劳动力市场也是十分活跃的，比如孔子周游列国，寻求就职机会，**劳动力的流动在那时就是相对自由的；而在欧洲农民是依附于土地的**。\n\n![春秋战国](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.60171ph2pqo0.webp)\n\n除了要素市场，中国的商品市场也是十分活跃。在春秋战国时期就有了期贷市场和投机市场。比如范蠡的故事，其有言：“<u>论起有余而不足，则知贵贱。贵上极则反贱，贱下极则反贵。贵出如粪土，贱取如玉珠。</u>”这其实就是在讲**价格在调节供给关系的作用**，其背后的思想和今天的市场经济十分相似。\n\n## 近代中国之衰弱\n\n中国落后于西方，发生于”瞬息之间“，直接原因就是**西方18世纪中叶的工业革命**。林毅夫先生引用了一句十分形象的话：“<u>当中国使用铁犁的时候，欧洲还在使用木犁；欧洲使用钢犁的时候，中国还在使用铁犁。</u>”\n\n最初发生于英国的第一次工业革命在历史书上都学过，那么为什么工业革命会发生在英国，而不是中国呢？更为重要的是，中国在接下来的几个世纪都没有迈入工业革命，直到鸦片战争的爆发，才让中国人意识到自己落后了。\n\n一位研究中国科技史的学者，李约瑟提出了这个问题，并做了大量的细致研究。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2brh5kgsqhzw.webp\" alt=\"李约瑟与周恩来\" style=\"zoom:80%;\" /></div>\n\n# 李约瑟之谜\n\n李约瑟提出一个问题，后世称之为**李约瑟之谜**，这个问题包含两个方面：\n\n1. 为什么在前现代社会中国的科学技术十分发达？\n2. 为什么在现代社会中国又成为技术落后的国家，没有继续维持领先？\n\n中华民族源远流长，为世间唯一传承千年，屹立不倒的文明，但中国会不会像其他古代文明一样由盛转衰，再而竭呢？**对李约瑟之谜的回答会影响这个问题的判断，会让我们明白中国是否会有复兴之可能**。\n\n# 对李约瑟之谜的解释\n\n## 中国在前现代社会具有优势的原因\n\n中国人口众多，这是因为良好的自然条件造成耕地的生产力>西方，人的生产成本较低，人口繁衍迅速；而欧洲气候条件不适合农作物生长，土地承载人口低，所以人口一直比中国少。**人口众多，这是一个重要的前提**。\n\n<font color=Purple>**在前现代社会中，技术创新主要来自工农的经验性尝试错误**</font>。中国人多，工农基数大，所以发明新技术的概率比较大。当时技术都来自经验积累，一代一代传承下去，但偶尔会犯错，而这偶然的错误可能就会造成一个创新，人一多，偶然的错误就会多，发明新技术的概率自然就大了。不仅仅是中国，大多数的大河文明都是这样，因为人口稠密且劳动力数量庞大，才使得技术的积部有着广阔的基础。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1cl4pq40kqgw.webp\" alt=\"天工开物\" style=\"zoom:80%;\" /></div>\n\n## 8-12世纪中国技术创新加速的原因\n\n这最主要的原因就是<font color=\"red\">**北方游牧民族的入侵，导致经济重心南移，人口大量南迁。**</font>南方的作物以水稻为主，北方的生产力工具显然就不太适合了，为了适应南方水田，猪八戒的耙子必须改成锄头；为了适应南方湖泊众多的环境，北方的马车要改进为船舶，由此引发的一系列技术创新就来了。**生产力提高了，技术创新就有空间了。**\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2vfj4eevqec0.webp\" alt=\"人口南移\" style=\"zoom:80%;\" /></div>\n\n人口迁移引发了8-12世纪技术创新的加速期，但随着生产力和技术水平的不断提高，就会达到一个瓶颈期，即使人口和错误尝试还在增多，但是创新速度也会放缓，除此之外，人口减少也会造成这种结果。\n\n8-12世纪之后，中国人口时多时少，但是技术变迁的速度再没增加过。\n\n## 中国在现代落后于欧洲的原因\n\n在前现代社会，欧洲的人口少是劣势，导致技术变迁速度一直比中国慢；但是18世纪以后，欧洲出现了改变世界格局的工业革命，其主要特征是**纺织机器，蒸汽以及钢铁的使用**，但是最重要的是技术变迁的速度加快了。为什么呢？\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6k3fgaae3800.webp\" alt=\"工业革命\" style=\"zoom:80%;\" /></div>\n\n**<font color=\"green\">经验的重要性已被实验所取代</font>**。在前现代社会，经验是生产的副产品，工农通过偶然的试错发明新技术；而到了18世纪，试错变成通过主动实验来进行，**一个科学家在实验室里一年所能做的尝试错误数量可能是几千个工农一辈子的数量，人口变得不重要了**。但是前面说了，<u>随着技术水平的不断提高，就会到达一个瓶颈期</u>，这该怎么解释呢？\n\n解释就是欧洲人可以通过投资基础科学的研究来突破瓶颈期，增加对自然界的了解，技术发明的可能性又进一步扩大了。**科学增进了人们对自然界的了解，给新技术的发明创造了很大的空间**。\n\n## 中国为什么没有发生科学革命\n\n中国在瞬息之间落后于欧洲，直接原因是工业革命，但这不是根本。通过之前的探讨，我们知道更重要的根本原因是**欧洲可以通过投资基础科学的研究，来不断突破技术成长的瓶颈期**。因此，要寻找中国为什么在现代落后于欧洲的原因，关键不在于工业革命本身，而是**发生在15，16世纪的西方科学革命，为什么没有在中国发生？**\n\n首先，我们要区分原始科学和现代科学。科学就是对自然现象的系统性解释，比如古代的五行说、四元素论，又比如现代的力学，电学啊等等。原始科学和现代科学都是一套对自然界系统的解释，本质上并没有区别。但**不同之处**在于：\n\n1. 现代科学用**数学知识**来表述对自然界现象的解释，使得描述更准确，减少二义性，有利于传播（全世界通用语言）。\n2. 现代科学使用**控制变量和可复制的实验**来验证假说的真实性。\n\n西方的科学革命本质是方法论的革命，即<font color=\"purple\">**数学模型和可控制实验的结合**。</font>那为什么人口基数大的中国没有发现这种方法论呢？\n\n### 对几种观点的驳斥\n\n1. 李约瑟认为是中国重农抑商的文化导致了这一结果，但林毅夫先生驳斥了这一观点，实际上**中国古代的资本主义虽然被压制了，但是还是非常发达（比如明朝），并不比14，15世纪的欧洲差**。\n\n2. 有些观点认为中国是大一统国家，缺乏竞争；而西方小国林立，有利于竞争，像美苏争霸时，由于在航天和军事上的投资，导致技术突飞猛进。林毅夫认为：\n\n   1. 中国虽然大一统，但是思想控制不如欧洲严格，**欧洲的宗教是统一且强势的**（哥白尼的例子），在自然探索方面，中国基本放任不管。\n   2. 国家竞争不是促进科学发展的决定因素，如果不对基础科学投资，科学技术发展还是会很快遇到瓶颈，试问当时哪个国家会为了技术发展，投资基础科学？\n   3. 科学研究需要经费，大国可能出资研究技术，但是概率较小，总体来说，中国贵族确实不像欧洲贵族那样投资科学研究。\n   \n   这种观点确实有道理，但是不适合500年前的情况。\n\n## 林毅夫先生的解释\n\n这个关键就在于**人才选拔的制度**，中国人不是脑子比西方人笨，也不是没有好奇心，<font color=purple>**而是学习数学和可控制实验的绝对人数没有西方多。**</font>中国有句古话，<u>“万般皆下品，唯有读书高”</u>，当时做官的收益是最好的，而要想做官，就得科举考试。\n\n曼昆在《经济学原理》中提出一个基本原理，<font color=purple>**人们会对激励做出反应**</font>。对于那些有着聪明才智的人，参加科举考试，当个官老爷，是投资回报率最高的行为；对于科学技术和数学，就算有心研究，也不会花太多时间。想想看，科举考试的标准教材→四书五经，字数之和就达到几十万字，还得倒背如流，此外还有各种史书和诗文，得花多少时间，谁还有空去看p用没有的数学和科学技术。\n\n![科举](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.78nmw8s00u80.webp)\n\n要想在中国古代做官，就得接受四书五经的价值标准和理论体系，这也是中国古代皇帝能够控制国家官僚体系并维持国家稳定的重要原因，如果一个读书人有谋反之心，从小被灌输“君君臣臣父父子子”的他，会有极强的负罪感。除此之外，对于那些有野心，有抱负的人来说，如果可以通过正常手段成为统治阶级的一部分，为什么还要造反呢？\n\n其实，科举考试初期，考试科目包括了数学，但是呢，皇帝很快发现这个学科对维护自己的统治是一点用没有，就把数学考试取消了。举个很好玩的例子，著名中国科技史著作《天工开物》中在序言就写到，**聪明而又有抱负的人，是不应该读这本书的，因为这本书对科举没用**。由此可见一斑。\n\n经济学中有个概念叫**制度障碍**，<font color=\"purple\">**特定条件下优越的制度，在其他条件下可能会成为社会进步的障碍。**</font>这用来说明科举制度的影响再合适不过了。\n\n<p class=\"note note-primary\">马克思韦伯的疑问</p>\n\n在这里我们还能解释马克斯韦伯的一个疑问：中国在明朝就出现了资本主义萌芽，但中国为什么没有进入资本主义社会呢？\n\n什么是资本主义，**资本主义就是在资本深化的基础上，不断深化资本于劳动的雇佣关系**。\n\n当时中国之所以没进入资本主义社会，还是因为**科学革命**，没有科学革命，就没有工业革命，没有工业革命，技术得不到进步，资本也得不到深化，自然不可能进入全面的资本主义社会。\n\n# 结语\n\n以上大部分内容来自中国著名经济学家林毅夫先生的[《解读中国经济》](https://book.douban.com/subject/11626951/)，我觉得这篇文章特别好，就想做个总结，也算是解决了我心中的一个疑惑。当然，这也是林毅夫先生的一家之言，还是要理性看待观点。\n\n","source":"_posts/李约瑟之谜.md","raw":"---\ntitle: 李约瑟之谜\ndate: 2022-10-01 08:55:26\ntags:\n - 中国经济\ncategories:\n- 经济学\n- 中国经济\nbanner_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/china.4g94cmuvtl40.webp\nindex_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.47ucdvvh76c0.webp\nexcerpt: 《解读中国经济》—为什么在前现代社会中国的科学技术十分发达？而在现代社会，中国又成为技术落后的国家？\n---\n\n# 观古今之中国\n\n## 前现代社会之辉煌\n\n<p class=\"note note-primary\">经济规模庞大</p>\n\n[麦迪森](https://baike.baidu.com/item/%E5%AE%89%E6%A0%BC%E6%96%AF%C2%B7%E9%BA%A6%E8%BF%AA%E6%A3%AE/5818140)在《世界经济千年史》中对很多国家的长期经济发展历史做了许多细致的研究，他认为，<u>**中国直到19世纪中叶还是全世界最大的经济体**</u>，在这之前的两千年时间里，中国也一直是最大最强的经济体。\n\n亚当斯·斯密的《国富论》中提到一个经济发展规律：<u>**劳动分工是经济发展的动力之一，分工越细，生产力水平就越高**</u>。但是分工的规模又取决于市场规模的大小，市场越大，分工就可以越细，否则即使提高产量，没那么大市场也卖不掉，就显得没啥必要了。这个规律就能用来解释欧洲和中国在古代的不同发展情况。\n\n![古罗马帝国与汉帝国](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.73d7frfifj80.webp)\n\n欧洲和中国在公元元年左右时，人均收入水平不相上下。此时欧洲正值古罗马帝国的盛世，中国也将迎来大汉的光武中兴。但欧洲在古罗马帝国分崩离析后，进入到封建社会，帝国变成了一个个独立的城邦，城邦之间商业贸易很少，因此市场规模急剧减小，由此造成分工和生产力水平低下。\n\n与欧洲不同的是，中国自汉朝以来，绝大部分时间是大一统的，这意味着中国的市场规模是十分庞大的，根据斯密的理论，中国的劳动分工水平必定不断提高，经济不断发展，因此中国经济在当时是首屈一指的。\n\n<p class=\"note note-info\">技术水平领先</p>\n\n**技术落后**是一个国家经济发展落后的主要标志，而在17，18世纪之前，中国的技术水平是世界领先的，就比如中国古代的四大发明，这四项技术让欧洲走出了黑暗的时代。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1k34ak7p0pi8.webp\" alt=\"四大发明\" style=\"zoom:50%;\" /></div>\n\n<p class=\"note note-success\">活跃的市场经济</p>\n\n现有理论认为**私有制是市场经济的基础，而土地的私有是私有制中最重要的一环**。中国在春秋战国时期就开始实行土地私有制，允许自由买卖土地；而欧洲在整个封建时期，土地都是属于贵族的，没有土地市场。\n\n《管子》里有言：“<u>国多财则远者来</u>”，这表明当时的劳动力市场也是十分活跃的，比如孔子周游列国，寻求就职机会，**劳动力的流动在那时就是相对自由的；而在欧洲农民是依附于土地的**。\n\n![春秋战国](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.60171ph2pqo0.webp)\n\n除了要素市场，中国的商品市场也是十分活跃。在春秋战国时期就有了期贷市场和投机市场。比如范蠡的故事，其有言：“<u>论起有余而不足，则知贵贱。贵上极则反贱，贱下极则反贵。贵出如粪土，贱取如玉珠。</u>”这其实就是在讲**价格在调节供给关系的作用**，其背后的思想和今天的市场经济十分相似。\n\n## 近代中国之衰弱\n\n中国落后于西方，发生于”瞬息之间“，直接原因就是**西方18世纪中叶的工业革命**。林毅夫先生引用了一句十分形象的话：“<u>当中国使用铁犁的时候，欧洲还在使用木犁；欧洲使用钢犁的时候，中国还在使用铁犁。</u>”\n\n最初发生于英国的第一次工业革命在历史书上都学过，那么为什么工业革命会发生在英国，而不是中国呢？更为重要的是，中国在接下来的几个世纪都没有迈入工业革命，直到鸦片战争的爆发，才让中国人意识到自己落后了。\n\n一位研究中国科技史的学者，李约瑟提出了这个问题，并做了大量的细致研究。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2brh5kgsqhzw.webp\" alt=\"李约瑟与周恩来\" style=\"zoom:80%;\" /></div>\n\n# 李约瑟之谜\n\n李约瑟提出一个问题，后世称之为**李约瑟之谜**，这个问题包含两个方面：\n\n1. 为什么在前现代社会中国的科学技术十分发达？\n2. 为什么在现代社会中国又成为技术落后的国家，没有继续维持领先？\n\n中华民族源远流长，为世间唯一传承千年，屹立不倒的文明，但中国会不会像其他古代文明一样由盛转衰，再而竭呢？**对李约瑟之谜的回答会影响这个问题的判断，会让我们明白中国是否会有复兴之可能**。\n\n# 对李约瑟之谜的解释\n\n## 中国在前现代社会具有优势的原因\n\n中国人口众多，这是因为良好的自然条件造成耕地的生产力>西方，人的生产成本较低，人口繁衍迅速；而欧洲气候条件不适合农作物生长，土地承载人口低，所以人口一直比中国少。**人口众多，这是一个重要的前提**。\n\n<font color=Purple>**在前现代社会中，技术创新主要来自工农的经验性尝试错误**</font>。中国人多，工农基数大，所以发明新技术的概率比较大。当时技术都来自经验积累，一代一代传承下去，但偶尔会犯错，而这偶然的错误可能就会造成一个创新，人一多，偶然的错误就会多，发明新技术的概率自然就大了。不仅仅是中国，大多数的大河文明都是这样，因为人口稠密且劳动力数量庞大，才使得技术的积部有着广阔的基础。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1cl4pq40kqgw.webp\" alt=\"天工开物\" style=\"zoom:80%;\" /></div>\n\n## 8-12世纪中国技术创新加速的原因\n\n这最主要的原因就是<font color=\"red\">**北方游牧民族的入侵，导致经济重心南移，人口大量南迁。**</font>南方的作物以水稻为主，北方的生产力工具显然就不太适合了，为了适应南方水田，猪八戒的耙子必须改成锄头；为了适应南方湖泊众多的环境，北方的马车要改进为船舶，由此引发的一系列技术创新就来了。**生产力提高了，技术创新就有空间了。**\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2vfj4eevqec0.webp\" alt=\"人口南移\" style=\"zoom:80%;\" /></div>\n\n人口迁移引发了8-12世纪技术创新的加速期，但随着生产力和技术水平的不断提高，就会达到一个瓶颈期，即使人口和错误尝试还在增多，但是创新速度也会放缓，除此之外，人口减少也会造成这种结果。\n\n8-12世纪之后，中国人口时多时少，但是技术变迁的速度再没增加过。\n\n## 中国在现代落后于欧洲的原因\n\n在前现代社会，欧洲的人口少是劣势，导致技术变迁速度一直比中国慢；但是18世纪以后，欧洲出现了改变世界格局的工业革命，其主要特征是**纺织机器，蒸汽以及钢铁的使用**，但是最重要的是技术变迁的速度加快了。为什么呢？\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6k3fgaae3800.webp\" alt=\"工业革命\" style=\"zoom:80%;\" /></div>\n\n**<font color=\"green\">经验的重要性已被实验所取代</font>**。在前现代社会，经验是生产的副产品，工农通过偶然的试错发明新技术；而到了18世纪，试错变成通过主动实验来进行，**一个科学家在实验室里一年所能做的尝试错误数量可能是几千个工农一辈子的数量，人口变得不重要了**。但是前面说了，<u>随着技术水平的不断提高，就会到达一个瓶颈期</u>，这该怎么解释呢？\n\n解释就是欧洲人可以通过投资基础科学的研究来突破瓶颈期，增加对自然界的了解，技术发明的可能性又进一步扩大了。**科学增进了人们对自然界的了解，给新技术的发明创造了很大的空间**。\n\n## 中国为什么没有发生科学革命\n\n中国在瞬息之间落后于欧洲，直接原因是工业革命，但这不是根本。通过之前的探讨，我们知道更重要的根本原因是**欧洲可以通过投资基础科学的研究，来不断突破技术成长的瓶颈期**。因此，要寻找中国为什么在现代落后于欧洲的原因，关键不在于工业革命本身，而是**发生在15，16世纪的西方科学革命，为什么没有在中国发生？**\n\n首先，我们要区分原始科学和现代科学。科学就是对自然现象的系统性解释，比如古代的五行说、四元素论，又比如现代的力学，电学啊等等。原始科学和现代科学都是一套对自然界系统的解释，本质上并没有区别。但**不同之处**在于：\n\n1. 现代科学用**数学知识**来表述对自然界现象的解释，使得描述更准确，减少二义性，有利于传播（全世界通用语言）。\n2. 现代科学使用**控制变量和可复制的实验**来验证假说的真实性。\n\n西方的科学革命本质是方法论的革命，即<font color=\"purple\">**数学模型和可控制实验的结合**。</font>那为什么人口基数大的中国没有发现这种方法论呢？\n\n### 对几种观点的驳斥\n\n1. 李约瑟认为是中国重农抑商的文化导致了这一结果，但林毅夫先生驳斥了这一观点，实际上**中国古代的资本主义虽然被压制了，但是还是非常发达（比如明朝），并不比14，15世纪的欧洲差**。\n\n2. 有些观点认为中国是大一统国家，缺乏竞争；而西方小国林立，有利于竞争，像美苏争霸时，由于在航天和军事上的投资，导致技术突飞猛进。林毅夫认为：\n\n   1. 中国虽然大一统，但是思想控制不如欧洲严格，**欧洲的宗教是统一且强势的**（哥白尼的例子），在自然探索方面，中国基本放任不管。\n   2. 国家竞争不是促进科学发展的决定因素，如果不对基础科学投资，科学技术发展还是会很快遇到瓶颈，试问当时哪个国家会为了技术发展，投资基础科学？\n   3. 科学研究需要经费，大国可能出资研究技术，但是概率较小，总体来说，中国贵族确实不像欧洲贵族那样投资科学研究。\n   \n   这种观点确实有道理，但是不适合500年前的情况。\n\n## 林毅夫先生的解释\n\n这个关键就在于**人才选拔的制度**，中国人不是脑子比西方人笨，也不是没有好奇心，<font color=purple>**而是学习数学和可控制实验的绝对人数没有西方多。**</font>中国有句古话，<u>“万般皆下品，唯有读书高”</u>，当时做官的收益是最好的，而要想做官，就得科举考试。\n\n曼昆在《经济学原理》中提出一个基本原理，<font color=purple>**人们会对激励做出反应**</font>。对于那些有着聪明才智的人，参加科举考试，当个官老爷，是投资回报率最高的行为；对于科学技术和数学，就算有心研究，也不会花太多时间。想想看，科举考试的标准教材→四书五经，字数之和就达到几十万字，还得倒背如流，此外还有各种史书和诗文，得花多少时间，谁还有空去看p用没有的数学和科学技术。\n\n![科举](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.78nmw8s00u80.webp)\n\n要想在中国古代做官，就得接受四书五经的价值标准和理论体系，这也是中国古代皇帝能够控制国家官僚体系并维持国家稳定的重要原因，如果一个读书人有谋反之心，从小被灌输“君君臣臣父父子子”的他，会有极强的负罪感。除此之外，对于那些有野心，有抱负的人来说，如果可以通过正常手段成为统治阶级的一部分，为什么还要造反呢？\n\n其实，科举考试初期，考试科目包括了数学，但是呢，皇帝很快发现这个学科对维护自己的统治是一点用没有，就把数学考试取消了。举个很好玩的例子，著名中国科技史著作《天工开物》中在序言就写到，**聪明而又有抱负的人，是不应该读这本书的，因为这本书对科举没用**。由此可见一斑。\n\n经济学中有个概念叫**制度障碍**，<font color=\"purple\">**特定条件下优越的制度，在其他条件下可能会成为社会进步的障碍。**</font>这用来说明科举制度的影响再合适不过了。\n\n<p class=\"note note-primary\">马克思韦伯的疑问</p>\n\n在这里我们还能解释马克斯韦伯的一个疑问：中国在明朝就出现了资本主义萌芽，但中国为什么没有进入资本主义社会呢？\n\n什么是资本主义，**资本主义就是在资本深化的基础上，不断深化资本于劳动的雇佣关系**。\n\n当时中国之所以没进入资本主义社会，还是因为**科学革命**，没有科学革命，就没有工业革命，没有工业革命，技术得不到进步，资本也得不到深化，自然不可能进入全面的资本主义社会。\n\n# 结语\n\n以上大部分内容来自中国著名经济学家林毅夫先生的[《解读中国经济》](https://book.douban.com/subject/11626951/)，我觉得这篇文章特别好，就想做个总结，也算是解决了我心中的一个疑惑。当然，这也是林毅夫先生的一家之言，还是要理性看待观点。\n\n","slug":"李约瑟之谜","published":1,"updated":"2022-10-04T15:00:12.894Z","_id":"cl8p9um2a0000pcru8uvlbvxu","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"观古今之中国\"><a href=\"#观古今之中国\" class=\"headerlink\" title=\"观古今之中国\"></a>观古今之中国</h1><h2 id=\"前现代社会之辉煌\"><a href=\"#前现代社会之辉煌\" class=\"headerlink\" title=\"前现代社会之辉煌\"></a>前现代社会之辉煌</h2><p class=\"note note-primary\">经济规模庞大</p>\n\n<p><a href=\"https://baike.baidu.com/item/%E5%AE%89%E6%A0%BC%E6%96%AF%C2%B7%E9%BA%A6%E8%BF%AA%E6%A3%AE/5818140\">麦迪森</a>在《世界经济千年史》中对很多国家的长期经济发展历史做了许多细致的研究，他认为，<u><strong>中国直到19世纪中叶还是全世界最大的经济体</strong></u>，在这之前的两千年时间里，中国也一直是最大最强的经济体。</p>\n<p>亚当斯·斯密的《国富论》中提到一个经济发展规律：<u><strong>劳动分工是经济发展的动力之一，分工越细，生产力水平就越高</strong></u>。但是分工的规模又取决于市场规模的大小，市场越大，分工就可以越细，否则即使提高产量，没那么大市场也卖不掉，就显得没啥必要了。这个规律就能用来解释欧洲和中国在古代的不同发展情况。</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.73d7frfifj80.webp\" alt=\"古罗马帝国与汉帝国\"></p>\n<p>欧洲和中国在公元元年左右时，人均收入水平不相上下。此时欧洲正值古罗马帝国的盛世，中国也将迎来大汉的光武中兴。但欧洲在古罗马帝国分崩离析后，进入到封建社会，帝国变成了一个个独立的城邦，城邦之间商业贸易很少，因此市场规模急剧减小，由此造成分工和生产力水平低下。</p>\n<p>与欧洲不同的是，中国自汉朝以来，绝大部分时间是大一统的，这意味着中国的市场规模是十分庞大的，根据斯密的理论，中国的劳动分工水平必定不断提高，经济不断发展，因此中国经济在当时是首屈一指的。</p>\n<p class=\"note note-info\">技术水平领先</p>\n\n<p><strong>技术落后</strong>是一个国家经济发展落后的主要标志，而在17，18世纪之前，中国的技术水平是世界领先的，就比如中国古代的四大发明，这四项技术让欧洲走出了黑暗的时代。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1k34ak7p0pi8.webp\" alt=\"四大发明\" style=\"zoom:50%;\" /></div>\n\n<p class=\"note note-success\">活跃的市场经济</p>\n\n<p>现有理论认为<strong>私有制是市场经济的基础，而土地的私有是私有制中最重要的一环</strong>。中国在春秋战国时期就开始实行土地私有制，允许自由买卖土地；而欧洲在整个封建时期，土地都是属于贵族的，没有土地市场。</p>\n<p>《管子》里有言：“<u>国多财则远者来</u>”，这表明当时的劳动力市场也是十分活跃的，比如孔子周游列国，寻求就职机会，<strong>劳动力的流动在那时就是相对自由的；而在欧洲农民是依附于土地的</strong>。</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.60171ph2pqo0.webp\" alt=\"春秋战国\"></p>\n<p>除了要素市场，中国的商品市场也是十分活跃。在春秋战国时期就有了期贷市场和投机市场。比如范蠡的故事，其有言：“<u>论起有余而不足，则知贵贱。贵上极则反贱，贱下极则反贵。贵出如粪土，贱取如玉珠。</u>”这其实就是在讲<strong>价格在调节供给关系的作用</strong>，其背后的思想和今天的市场经济十分相似。</p>\n<h2 id=\"近代中国之衰弱\"><a href=\"#近代中国之衰弱\" class=\"headerlink\" title=\"近代中国之衰弱\"></a>近代中国之衰弱</h2><p>中国落后于西方，发生于”瞬息之间“，直接原因就是<strong>西方18世纪中叶的工业革命</strong>。林毅夫先生引用了一句十分形象的话：“<u>当中国使用铁犁的时候，欧洲还在使用木犁；欧洲使用钢犁的时候，中国还在使用铁犁。</u>”</p>\n<p>最初发生于英国的第一次工业革命在历史书上都学过，那么为什么工业革命会发生在英国，而不是中国呢？更为重要的是，中国在接下来的几个世纪都没有迈入工业革命，直到鸦片战争的爆发，才让中国人意识到自己落后了。</p>\n<p>一位研究中国科技史的学者，李约瑟提出了这个问题，并做了大量的细致研究。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2brh5kgsqhzw.webp\" alt=\"李约瑟与周恩来\" style=\"zoom:80%;\" /></div>\n\n<h1 id=\"李约瑟之谜\"><a href=\"#李约瑟之谜\" class=\"headerlink\" title=\"李约瑟之谜\"></a>李约瑟之谜</h1><p>李约瑟提出一个问题，后世称之为<strong>李约瑟之谜</strong>，这个问题包含两个方面：</p>\n<ol>\n<li>为什么在前现代社会中国的科学技术十分发达？</li>\n<li>为什么在现代社会中国又成为技术落后的国家，没有继续维持领先？</li>\n</ol>\n<p>中华民族源远流长，为世间唯一传承千年，屹立不倒的文明，但中国会不会像其他古代文明一样由盛转衰，再而竭呢？<strong>对李约瑟之谜的回答会影响这个问题的判断，会让我们明白中国是否会有复兴之可能</strong>。</p>\n<h1 id=\"对李约瑟之谜的解释\"><a href=\"#对李约瑟之谜的解释\" class=\"headerlink\" title=\"对李约瑟之谜的解释\"></a>对李约瑟之谜的解释</h1><h2 id=\"中国在前现代社会具有优势的原因\"><a href=\"#中国在前现代社会具有优势的原因\" class=\"headerlink\" title=\"中国在前现代社会具有优势的原因\"></a>中国在前现代社会具有优势的原因</h2><p>中国人口众多，这是因为良好的自然条件造成耕地的生产力&gt;西方，人的生产成本较低，人口繁衍迅速；而欧洲气候条件不适合农作物生长，土地承载人口低，所以人口一直比中国少。<strong>人口众多，这是一个重要的前提</strong>。</p>\n<p><font color=Purple><strong>在前现代社会中，技术创新主要来自工农的经验性尝试错误</strong></font>。中国人多，工农基数大，所以发明新技术的概率比较大。当时技术都来自经验积累，一代一代传承下去，但偶尔会犯错，而这偶然的错误可能就会造成一个创新，人一多，偶然的错误就会多，发明新技术的概率自然就大了。不仅仅是中国，大多数的大河文明都是这样，因为人口稠密且劳动力数量庞大，才使得技术的积部有着广阔的基础。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1cl4pq40kqgw.webp\" alt=\"天工开物\" style=\"zoom:80%;\" /></div>\n\n<h2 id=\"8-12世纪中国技术创新加速的原因\"><a href=\"#8-12世纪中国技术创新加速的原因\" class=\"headerlink\" title=\"8-12世纪中国技术创新加速的原因\"></a>8-12世纪中国技术创新加速的原因</h2><p>这最主要的原因就是<font color=\"red\"><strong>北方游牧民族的入侵，导致经济重心南移，人口大量南迁。</strong></font>南方的作物以水稻为主，北方的生产力工具显然就不太适合了，为了适应南方水田，猪八戒的耙子必须改成锄头；为了适应南方湖泊众多的环境，北方的马车要改进为船舶，由此引发的一系列技术创新就来了。<strong>生产力提高了，技术创新就有空间了。</strong></p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2vfj4eevqec0.webp\" alt=\"人口南移\" style=\"zoom:80%;\" /></div>\n\n<p>人口迁移引发了8-12世纪技术创新的加速期，但随着生产力和技术水平的不断提高，就会达到一个瓶颈期，即使人口和错误尝试还在增多，但是创新速度也会放缓，除此之外，人口减少也会造成这种结果。</p>\n<p>8-12世纪之后，中国人口时多时少，但是技术变迁的速度再没增加过。</p>\n<h2 id=\"中国在现代落后于欧洲的原因\"><a href=\"#中国在现代落后于欧洲的原因\" class=\"headerlink\" title=\"中国在现代落后于欧洲的原因\"></a>中国在现代落后于欧洲的原因</h2><p>在前现代社会，欧洲的人口少是劣势，导致技术变迁速度一直比中国慢；但是18世纪以后，欧洲出现了改变世界格局的工业革命，其主要特征是<strong>纺织机器，蒸汽以及钢铁的使用</strong>，但是最重要的是技术变迁的速度加快了。为什么呢？</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6k3fgaae3800.webp\" alt=\"工业革命\" style=\"zoom:80%;\" /></div>\n\n<p><strong><font color=\"green\">经验的重要性已被实验所取代</font><strong>。在前现代社会，经验是生产的副产品，工农通过偶然的试错发明新技术；而到了18世纪，试错变成通过主动实验来进行，</strong>一个科学家在实验室里一年所能做的尝试错误数量可能是几千个工农一辈子的数量，人口变得不重要了</strong>。但是前面说了，<u>随着技术水平的不断提高，就会到达一个瓶颈期</u>，这该怎么解释呢？</p>\n<p>解释就是欧洲人可以通过投资基础科学的研究来突破瓶颈期，增加对自然界的了解，技术发明的可能性又进一步扩大了。<strong>科学增进了人们对自然界的了解，给新技术的发明创造了很大的空间</strong>。</p>\n<h2 id=\"中国为什么没有发生科学革命\"><a href=\"#中国为什么没有发生科学革命\" class=\"headerlink\" title=\"中国为什么没有发生科学革命\"></a>中国为什么没有发生科学革命</h2><p>中国在瞬息之间落后于欧洲，直接原因是工业革命，但这不是根本。通过之前的探讨，我们知道更重要的根本原因是<strong>欧洲可以通过投资基础科学的研究，来不断突破技术成长的瓶颈期</strong>。因此，要寻找中国为什么在现代落后于欧洲的原因，关键不在于工业革命本身，而是<strong>发生在15，16世纪的西方科学革命，为什么没有在中国发生？</strong></p>\n<p>首先，我们要区分原始科学和现代科学。科学就是对自然现象的系统性解释，比如古代的五行说、四元素论，又比如现代的力学，电学啊等等。原始科学和现代科学都是一套对自然界系统的解释，本质上并没有区别。但<strong>不同之处</strong>在于：</p>\n<ol>\n<li>现代科学用<strong>数学知识</strong>来表述对自然界现象的解释，使得描述更准确，减少二义性，有利于传播（全世界通用语言）。</li>\n<li>现代科学使用<strong>控制变量和可复制的实验</strong>来验证假说的真实性。</li>\n</ol>\n<p>西方的科学革命本质是方法论的革命，即<font color=\"purple\"><strong>数学模型和可控制实验的结合</strong>。</font>那为什么人口基数大的中国没有发现这种方法论呢？</p>\n<h3 id=\"对几种观点的驳斥\"><a href=\"#对几种观点的驳斥\" class=\"headerlink\" title=\"对几种观点的驳斥\"></a>对几种观点的驳斥</h3><ol>\n<li><p>李约瑟认为是中国重农抑商的文化导致了这一结果，但林毅夫先生驳斥了这一观点，实际上<strong>中国古代的资本主义虽然被压制了，但是还是非常发达（比如明朝），并不比14，15世纪的欧洲差</strong>。</p>\n</li>\n<li><p>有些观点认为中国是大一统国家，缺乏竞争；而西方小国林立，有利于竞争，像美苏争霸时，由于在航天和军事上的投资，导致技术突飞猛进。林毅夫认为：</p>\n<ol>\n<li>中国虽然大一统，但是思想控制不如欧洲严格，<strong>欧洲的宗教是统一且强势的</strong>（哥白尼的例子），在自然探索方面，中国基本放任不管。</li>\n<li>国家竞争不是促进科学发展的决定因素，如果不对基础科学投资，科学技术发展还是会很快遇到瓶颈，试问当时哪个国家会为了技术发展，投资基础科学？</li>\n<li>科学研究需要经费，大国可能出资研究技术，但是概率较小，总体来说，中国贵族确实不像欧洲贵族那样投资科学研究。</li>\n</ol>\n<p>这种观点确实有道理，但是不适合500年前的情况。</p>\n</li>\n</ol>\n<h2 id=\"林毅夫先生的解释\"><a href=\"#林毅夫先生的解释\" class=\"headerlink\" title=\"林毅夫先生的解释\"></a>林毅夫先生的解释</h2><p>这个关键就在于<strong>人才选拔的制度</strong>，中国人不是脑子比西方人笨，也不是没有好奇心，<font color=purple><strong>而是学习数学和可控制实验的绝对人数没有西方多。</strong></font>中国有句古话，<u>“万般皆下品，唯有读书高”</u>，当时做官的收益是最好的，而要想做官，就得科举考试。</p>\n<p>曼昆在《经济学原理》中提出一个基本原理，<font color=purple><strong>人们会对激励做出反应</strong></font>。对于那些有着聪明才智的人，参加科举考试，当个官老爷，是投资回报率最高的行为；对于科学技术和数学，就算有心研究，也不会花太多时间。想想看，科举考试的标准教材→四书五经，字数之和就达到几十万字，还得倒背如流，此外还有各种史书和诗文，得花多少时间，谁还有空去看p用没有的数学和科学技术。</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.78nmw8s00u80.webp\" alt=\"科举\"></p>\n<p>要想在中国古代做官，就得接受四书五经的价值标准和理论体系，这也是中国古代皇帝能够控制国家官僚体系并维持国家稳定的重要原因，如果一个读书人有谋反之心，从小被灌输“君君臣臣父父子子”的他，会有极强的负罪感。除此之外，对于那些有野心，有抱负的人来说，如果可以通过正常手段成为统治阶级的一部分，为什么还要造反呢？</p>\n<p>其实，科举考试初期，考试科目包括了数学，但是呢，皇帝很快发现这个学科对维护自己的统治是一点用没有，就把数学考试取消了。举个很好玩的例子，著名中国科技史著作《天工开物》中在序言就写到，<strong>聪明而又有抱负的人，是不应该读这本书的，因为这本书对科举没用</strong>。由此可见一斑。</p>\n<p>经济学中有个概念叫<strong>制度障碍</strong>，<font color=\"purple\"><strong>特定条件下优越的制度，在其他条件下可能会成为社会进步的障碍。</strong></font>这用来说明科举制度的影响再合适不过了。</p>\n<p class=\"note note-primary\">马克思韦伯的疑问</p>\n\n<p>在这里我们还能解释马克斯韦伯的一个疑问：中国在明朝就出现了资本主义萌芽，但中国为什么没有进入资本主义社会呢？</p>\n<p>什么是资本主义，<strong>资本主义就是在资本深化的基础上，不断深化资本于劳动的雇佣关系</strong>。</p>\n<p>当时中国之所以没进入资本主义社会，还是因为<strong>科学革命</strong>，没有科学革命，就没有工业革命，没有工业革命，技术得不到进步，资本也得不到深化，自然不可能进入全面的资本主义社会。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>以上大部分内容来自中国著名经济学家林毅夫先生的<a href=\"https://book.douban.com/subject/11626951/\">《解读中国经济》</a>，我觉得这篇文章特别好，就想做个总结，也算是解决了我心中的一个疑惑。当然，这也是林毅夫先生的一家之言，还是要理性看待观点。</p>\n","site":{"data":{}},"more":"<h1 id=\"观古今之中国\"><a href=\"#观古今之中国\" class=\"headerlink\" title=\"观古今之中国\"></a>观古今之中国</h1><h2 id=\"前现代社会之辉煌\"><a href=\"#前现代社会之辉煌\" class=\"headerlink\" title=\"前现代社会之辉煌\"></a>前现代社会之辉煌</h2><p class=\"note note-primary\">经济规模庞大</p>\n\n<p><a href=\"https://baike.baidu.com/item/%E5%AE%89%E6%A0%BC%E6%96%AF%C2%B7%E9%BA%A6%E8%BF%AA%E6%A3%AE/5818140\">麦迪森</a>在《世界经济千年史》中对很多国家的长期经济发展历史做了许多细致的研究，他认为，<u><strong>中国直到19世纪中叶还是全世界最大的经济体</strong></u>，在这之前的两千年时间里，中国也一直是最大最强的经济体。</p>\n<p>亚当斯·斯密的《国富论》中提到一个经济发展规律：<u><strong>劳动分工是经济发展的动力之一，分工越细，生产力水平就越高</strong></u>。但是分工的规模又取决于市场规模的大小，市场越大，分工就可以越细，否则即使提高产量，没那么大市场也卖不掉，就显得没啥必要了。这个规律就能用来解释欧洲和中国在古代的不同发展情况。</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.73d7frfifj80.webp\" alt=\"古罗马帝国与汉帝国\"></p>\n<p>欧洲和中国在公元元年左右时，人均收入水平不相上下。此时欧洲正值古罗马帝国的盛世，中国也将迎来大汉的光武中兴。但欧洲在古罗马帝国分崩离析后，进入到封建社会，帝国变成了一个个独立的城邦，城邦之间商业贸易很少，因此市场规模急剧减小，由此造成分工和生产力水平低下。</p>\n<p>与欧洲不同的是，中国自汉朝以来，绝大部分时间是大一统的，这意味着中国的市场规模是十分庞大的，根据斯密的理论，中国的劳动分工水平必定不断提高，经济不断发展，因此中国经济在当时是首屈一指的。</p>\n<p class=\"note note-info\">技术水平领先</p>\n\n<p><strong>技术落后</strong>是一个国家经济发展落后的主要标志，而在17，18世纪之前，中国的技术水平是世界领先的，就比如中国古代的四大发明，这四项技术让欧洲走出了黑暗的时代。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1k34ak7p0pi8.webp\" alt=\"四大发明\" style=\"zoom:50%;\" /></div>\n\n<p class=\"note note-success\">活跃的市场经济</p>\n\n<p>现有理论认为<strong>私有制是市场经济的基础，而土地的私有是私有制中最重要的一环</strong>。中国在春秋战国时期就开始实行土地私有制，允许自由买卖土地；而欧洲在整个封建时期，土地都是属于贵族的，没有土地市场。</p>\n<p>《管子》里有言：“<u>国多财则远者来</u>”，这表明当时的劳动力市场也是十分活跃的，比如孔子周游列国，寻求就职机会，<strong>劳动力的流动在那时就是相对自由的；而在欧洲农民是依附于土地的</strong>。</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.60171ph2pqo0.webp\" alt=\"春秋战国\"></p>\n<p>除了要素市场，中国的商品市场也是十分活跃。在春秋战国时期就有了期贷市场和投机市场。比如范蠡的故事，其有言：“<u>论起有余而不足，则知贵贱。贵上极则反贱，贱下极则反贵。贵出如粪土，贱取如玉珠。</u>”这其实就是在讲<strong>价格在调节供给关系的作用</strong>，其背后的思想和今天的市场经济十分相似。</p>\n<h2 id=\"近代中国之衰弱\"><a href=\"#近代中国之衰弱\" class=\"headerlink\" title=\"近代中国之衰弱\"></a>近代中国之衰弱</h2><p>中国落后于西方，发生于”瞬息之间“，直接原因就是<strong>西方18世纪中叶的工业革命</strong>。林毅夫先生引用了一句十分形象的话：“<u>当中国使用铁犁的时候，欧洲还在使用木犁；欧洲使用钢犁的时候，中国还在使用铁犁。</u>”</p>\n<p>最初发生于英国的第一次工业革命在历史书上都学过，那么为什么工业革命会发生在英国，而不是中国呢？更为重要的是，中国在接下来的几个世纪都没有迈入工业革命，直到鸦片战争的爆发，才让中国人意识到自己落后了。</p>\n<p>一位研究中国科技史的学者，李约瑟提出了这个问题，并做了大量的细致研究。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2brh5kgsqhzw.webp\" alt=\"李约瑟与周恩来\" style=\"zoom:80%;\" /></div>\n\n<h1 id=\"李约瑟之谜\"><a href=\"#李约瑟之谜\" class=\"headerlink\" title=\"李约瑟之谜\"></a>李约瑟之谜</h1><p>李约瑟提出一个问题，后世称之为<strong>李约瑟之谜</strong>，这个问题包含两个方面：</p>\n<ol>\n<li>为什么在前现代社会中国的科学技术十分发达？</li>\n<li>为什么在现代社会中国又成为技术落后的国家，没有继续维持领先？</li>\n</ol>\n<p>中华民族源远流长，为世间唯一传承千年，屹立不倒的文明，但中国会不会像其他古代文明一样由盛转衰，再而竭呢？<strong>对李约瑟之谜的回答会影响这个问题的判断，会让我们明白中国是否会有复兴之可能</strong>。</p>\n<h1 id=\"对李约瑟之谜的解释\"><a href=\"#对李约瑟之谜的解释\" class=\"headerlink\" title=\"对李约瑟之谜的解释\"></a>对李约瑟之谜的解释</h1><h2 id=\"中国在前现代社会具有优势的原因\"><a href=\"#中国在前现代社会具有优势的原因\" class=\"headerlink\" title=\"中国在前现代社会具有优势的原因\"></a>中国在前现代社会具有优势的原因</h2><p>中国人口众多，这是因为良好的自然条件造成耕地的生产力&gt;西方，人的生产成本较低，人口繁衍迅速；而欧洲气候条件不适合农作物生长，土地承载人口低，所以人口一直比中国少。<strong>人口众多，这是一个重要的前提</strong>。</p>\n<p><font color=Purple><strong>在前现代社会中，技术创新主要来自工农的经验性尝试错误</strong></font>。中国人多，工农基数大，所以发明新技术的概率比较大。当时技术都来自经验积累，一代一代传承下去，但偶尔会犯错，而这偶然的错误可能就会造成一个创新，人一多，偶然的错误就会多，发明新技术的概率自然就大了。不仅仅是中国，大多数的大河文明都是这样，因为人口稠密且劳动力数量庞大，才使得技术的积部有着广阔的基础。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1cl4pq40kqgw.webp\" alt=\"天工开物\" style=\"zoom:80%;\" /></div>\n\n<h2 id=\"8-12世纪中国技术创新加速的原因\"><a href=\"#8-12世纪中国技术创新加速的原因\" class=\"headerlink\" title=\"8-12世纪中国技术创新加速的原因\"></a>8-12世纪中国技术创新加速的原因</h2><p>这最主要的原因就是<font color=\"red\"><strong>北方游牧民族的入侵，导致经济重心南移，人口大量南迁。</strong></font>南方的作物以水稻为主，北方的生产力工具显然就不太适合了，为了适应南方水田，猪八戒的耙子必须改成锄头；为了适应南方湖泊众多的环境，北方的马车要改进为船舶，由此引发的一系列技术创新就来了。<strong>生产力提高了，技术创新就有空间了。</strong></p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2vfj4eevqec0.webp\" alt=\"人口南移\" style=\"zoom:80%;\" /></div>\n\n<p>人口迁移引发了8-12世纪技术创新的加速期，但随着生产力和技术水平的不断提高，就会达到一个瓶颈期，即使人口和错误尝试还在增多，但是创新速度也会放缓，除此之外，人口减少也会造成这种结果。</p>\n<p>8-12世纪之后，中国人口时多时少，但是技术变迁的速度再没增加过。</p>\n<h2 id=\"中国在现代落后于欧洲的原因\"><a href=\"#中国在现代落后于欧洲的原因\" class=\"headerlink\" title=\"中国在现代落后于欧洲的原因\"></a>中国在现代落后于欧洲的原因</h2><p>在前现代社会，欧洲的人口少是劣势，导致技术变迁速度一直比中国慢；但是18世纪以后，欧洲出现了改变世界格局的工业革命，其主要特征是<strong>纺织机器，蒸汽以及钢铁的使用</strong>，但是最重要的是技术变迁的速度加快了。为什么呢？</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6k3fgaae3800.webp\" alt=\"工业革命\" style=\"zoom:80%;\" /></div>\n\n<p><strong><font color=\"green\">经验的重要性已被实验所取代</font><strong>。在前现代社会，经验是生产的副产品，工农通过偶然的试错发明新技术；而到了18世纪，试错变成通过主动实验来进行，</strong>一个科学家在实验室里一年所能做的尝试错误数量可能是几千个工农一辈子的数量，人口变得不重要了</strong>。但是前面说了，<u>随着技术水平的不断提高，就会到达一个瓶颈期</u>，这该怎么解释呢？</p>\n<p>解释就是欧洲人可以通过投资基础科学的研究来突破瓶颈期，增加对自然界的了解，技术发明的可能性又进一步扩大了。<strong>科学增进了人们对自然界的了解，给新技术的发明创造了很大的空间</strong>。</p>\n<h2 id=\"中国为什么没有发生科学革命\"><a href=\"#中国为什么没有发生科学革命\" class=\"headerlink\" title=\"中国为什么没有发生科学革命\"></a>中国为什么没有发生科学革命</h2><p>中国在瞬息之间落后于欧洲，直接原因是工业革命，但这不是根本。通过之前的探讨，我们知道更重要的根本原因是<strong>欧洲可以通过投资基础科学的研究，来不断突破技术成长的瓶颈期</strong>。因此，要寻找中国为什么在现代落后于欧洲的原因，关键不在于工业革命本身，而是<strong>发生在15，16世纪的西方科学革命，为什么没有在中国发生？</strong></p>\n<p>首先，我们要区分原始科学和现代科学。科学就是对自然现象的系统性解释，比如古代的五行说、四元素论，又比如现代的力学，电学啊等等。原始科学和现代科学都是一套对自然界系统的解释，本质上并没有区别。但<strong>不同之处</strong>在于：</p>\n<ol>\n<li>现代科学用<strong>数学知识</strong>来表述对自然界现象的解释，使得描述更准确，减少二义性，有利于传播（全世界通用语言）。</li>\n<li>现代科学使用<strong>控制变量和可复制的实验</strong>来验证假说的真实性。</li>\n</ol>\n<p>西方的科学革命本质是方法论的革命，即<font color=\"purple\"><strong>数学模型和可控制实验的结合</strong>。</font>那为什么人口基数大的中国没有发现这种方法论呢？</p>\n<h3 id=\"对几种观点的驳斥\"><a href=\"#对几种观点的驳斥\" class=\"headerlink\" title=\"对几种观点的驳斥\"></a>对几种观点的驳斥</h3><ol>\n<li><p>李约瑟认为是中国重农抑商的文化导致了这一结果，但林毅夫先生驳斥了这一观点，实际上<strong>中国古代的资本主义虽然被压制了，但是还是非常发达（比如明朝），并不比14，15世纪的欧洲差</strong>。</p>\n</li>\n<li><p>有些观点认为中国是大一统国家，缺乏竞争；而西方小国林立，有利于竞争，像美苏争霸时，由于在航天和军事上的投资，导致技术突飞猛进。林毅夫认为：</p>\n<ol>\n<li>中国虽然大一统，但是思想控制不如欧洲严格，<strong>欧洲的宗教是统一且强势的</strong>（哥白尼的例子），在自然探索方面，中国基本放任不管。</li>\n<li>国家竞争不是促进科学发展的决定因素，如果不对基础科学投资，科学技术发展还是会很快遇到瓶颈，试问当时哪个国家会为了技术发展，投资基础科学？</li>\n<li>科学研究需要经费，大国可能出资研究技术，但是概率较小，总体来说，中国贵族确实不像欧洲贵族那样投资科学研究。</li>\n</ol>\n<p>这种观点确实有道理，但是不适合500年前的情况。</p>\n</li>\n</ol>\n<h2 id=\"林毅夫先生的解释\"><a href=\"#林毅夫先生的解释\" class=\"headerlink\" title=\"林毅夫先生的解释\"></a>林毅夫先生的解释</h2><p>这个关键就在于<strong>人才选拔的制度</strong>，中国人不是脑子比西方人笨，也不是没有好奇心，<font color=purple><strong>而是学习数学和可控制实验的绝对人数没有西方多。</strong></font>中国有句古话，<u>“万般皆下品，唯有读书高”</u>，当时做官的收益是最好的，而要想做官，就得科举考试。</p>\n<p>曼昆在《经济学原理》中提出一个基本原理，<font color=purple><strong>人们会对激励做出反应</strong></font>。对于那些有着聪明才智的人，参加科举考试，当个官老爷，是投资回报率最高的行为；对于科学技术和数学，就算有心研究，也不会花太多时间。想想看，科举考试的标准教材→四书五经，字数之和就达到几十万字，还得倒背如流，此外还有各种史书和诗文，得花多少时间，谁还有空去看p用没有的数学和科学技术。</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.78nmw8s00u80.webp\" alt=\"科举\"></p>\n<p>要想在中国古代做官，就得接受四书五经的价值标准和理论体系，这也是中国古代皇帝能够控制国家官僚体系并维持国家稳定的重要原因，如果一个读书人有谋反之心，从小被灌输“君君臣臣父父子子”的他，会有极强的负罪感。除此之外，对于那些有野心，有抱负的人来说，如果可以通过正常手段成为统治阶级的一部分，为什么还要造反呢？</p>\n<p>其实，科举考试初期，考试科目包括了数学，但是呢，皇帝很快发现这个学科对维护自己的统治是一点用没有，就把数学考试取消了。举个很好玩的例子，著名中国科技史著作《天工开物》中在序言就写到，<strong>聪明而又有抱负的人，是不应该读这本书的，因为这本书对科举没用</strong>。由此可见一斑。</p>\n<p>经济学中有个概念叫<strong>制度障碍</strong>，<font color=\"purple\"><strong>特定条件下优越的制度，在其他条件下可能会成为社会进步的障碍。</strong></font>这用来说明科举制度的影响再合适不过了。</p>\n<p class=\"note note-primary\">马克思韦伯的疑问</p>\n\n<p>在这里我们还能解释马克斯韦伯的一个疑问：中国在明朝就出现了资本主义萌芽，但中国为什么没有进入资本主义社会呢？</p>\n<p>什么是资本主义，<strong>资本主义就是在资本深化的基础上，不断深化资本于劳动的雇佣关系</strong>。</p>\n<p>当时中国之所以没进入资本主义社会，还是因为<strong>科学革命</strong>，没有科学革命，就没有工业革命，没有工业革命，技术得不到进步，资本也得不到深化，自然不可能进入全面的资本主义社会。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>以上大部分内容来自中国著名经济学家林毅夫先生的<a href=\"https://book.douban.com/subject/11626951/\">《解读中国经济》</a>，我觉得这篇文章特别好，就想做个总结，也算是解决了我心中的一个疑惑。当然，这也是林毅夫先生的一家之言，还是要理性看待观点。</p>\n"},{"title":"Linux系统启动时","date":"2022-10-02T03:44:09.000Z","banner_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2vpyuzqapia0.webp","index_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2vpyuzqapia0.webp","excerpt":"从我们按下开机键到显示器上显示登录界面，这段时间里到底发生了什么？这篇文章将做一个简单的介绍","_content":"\n在Jyy老师的一节OS课上，内容是简单介绍Linux的启动流程，听完后我想更具体点知道这个启动的流程，所以特地搜素了一圈资料，以解答我心中之疑惑。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1zna45ggj5i8.webp\" alt=\"Linux启动流程\" style=\"zoom: 67%;\" /></div>\n\n# CPU Reset\n\n启动的第一步就是**Reset CPU**，即<u>设置CPU的各个寄存器为固定、已知的状态</u>。当我们按下电源按钮后，电源就开始给设备供电，一开始供电并不稳定，主板检测到后，就会一直给CPU发送**RESET信号**，此时的CPU就会清除寄存器上的残留数据并进行寄存器的设置：\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.3gbzr1spgf40.webp\" alt=\"image\" style=\"zoom:67%;\" /></div>\n\n在这之中最重要的寄存器是**CS（代码段）**和**EIP（指令指针）**。CS中隐式的Base（基地址）会与EIP相加，即`ffff 0000 H+fff0 H = ffff fff0 H`,其结果地址`0fff fff0 H` 被称为**重置向量**，<font color=purple>**主要包括一条跳转指令，指向BIOS的入口地址**</font>。\n\n<p class=\"note note-primary\">为什么重置向量不直接设为BIOS地址，而是跳转到BIOS呢？</p>\n\n<details>\n<summary>跳转到BIOS的解释</summary>\n<p><b>注意X86芯片一开始运行在实模式下，实模式只有20位寻址（1M空间），</b>而我们的重置向量是fff0H，到ffffH只有很短的距离，空间很小，不足以放下BIOS程序，所以要跳转。</p>\n<p><b>至于为什么不一开始就把重置向量设置为BIOS入口，</b>可能是希望把ROM放到可寻址空间的高层，以留出更大空间给内存。</p>\n</details>\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.4nbqyewemxw0.webp\" alt=\"实模式内存布局\" style=\"zoom: 80%;\" />\n</div>\n\n<p class=\"note note-info\">多核系统的CPU RESET</p>\n\n<details>\n<summary>多核系统下CPU RESET的解释</summary>\n    <p>多核计算机下，一开始要执行某个协议，系统将选取一个CPU来执行，其他CPU都等待，这个被选取的主CPU叫<b>Bootstrapping CPU（BSP）</b>。只有主CPU继续执行，其它CPU都进入一个等待状态，等待BSP给它们发指令，它们再开始继续执行。</p>\n</details>\n\n# BIOS执行\n\nBIOS是固定在EPROM中的程序，一般由硬件厂商写死，其负责引导系统的启动。其首先执行的程序的就是**加电自检（Power On Self Test，POST）**。\n\n## POST（加电自检）\n\nPOST用于计算机刚接通电源时对硬件部分的检测，如果自检中发现不是很严重的错误，系统会根据检测代码**给出提示信息或鸣笛警告**。\n\n**之所以使用鸣笛警告，是因为此时的显卡还没有完成初始化，无法将错误信息显示在屏幕上，只能通过声音报告错误**。\n\n检测的过程是逐一进行的，BIOS厂商对每个设备都提供了一个`POST CODE`，当对某个设备进行检测时，就会把这个POST CODE装到诊断的端口，如果没通过，这个CODE就会被保留，进行报警。\n\n## 初始化设备\n\nPOST结束后，BIOS还会调用各设备的BIOS进行自检和初始化，比如显卡BIOS，其会自检和初始化显卡，这个时候显示器就可以显示了。所有设备都是在这个时候被激活的。除了初始化设备，BIOS还会初始化[中断向量表](https://www.cnblogs.com/jadeshu/p/10663505.html)。\n\n## 启动Bootloader\n\n在检测和初始化各种设备之后，BIOS会查找用户自定义的启动顺序，默认是磁盘，当然也可以是光盘和U盘（以前重装操作系统时就会用到光盘和U盘）：\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5npilzacmlg0.webp\" alt=\"image\" style=\"zoom:80%;\" /></div>\n\n根据顺序，BIOS会把排在最前面的设备的**MBR（主引导记录）**，即<u>第0磁道第一个扇区的512字节</u>，读到**RAM绝对地址0x7C00处**，并跳转到这个地址。\n\n<p class=\"note note-primary\">MBR格式</p>\n\nMBR不属于任何一个操作系统，其512字节的内容如下：\n\n---\n\n- **启动代码(446B)**\n\n&emsp;&emsp;检查分区表的准确性，并将系统控制转移给硬盘上的Bootloader程序(比如现在常用的grub)。\n\n- **磁盘分区表(16 X 4B)**\n\n&emsp;&emsp;DPT，由四个分区表组成，每个16B，说明磁盘的分区情况。\n\n- **结束标志(2B)**\n\n&emsp;&emsp;该标志错误，无法启动。\n\n---\n\n# Bootloader\n\n所谓的Bootloader程序就是用来<font color=purple>**加载操作系统内核文件到内存**</font>，这类程序的主要功能为：\n\n---\n\n1. 从实模式使能保护模式，从16位寻址空间切换到32位寻址空间，使能**段机制**。\n2. 从硬盘读取ELF格式的kernel（跟在MBR后面的扇区）并放到内存中固定位置，这个过程一般分两步，最终是**执行`boot`命令**，加载系统引导菜单(`/boot/grub/menu.lst或grub.lst`)，`内核vmlinuz`和`RAM磁盘initrd`。\n3. 跳转到操作系统入口点执行，控制权交操作系统。\n\n---\n\n我们这里以GNU的**grub**为例。grub可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。grub被载入一般包括两个步骤：\n\n---\n\n1. 装载基本的引导装载程序—stage1，其主要功能是装载第二引导程序:stage2。\n2. 装载第二引导装载程序——stage2，这第二引导装载程序用于引出更高级的功能， 以允许用户装载入一个特定的操作系统。在grub中，这步是给用户显示一个菜单或是让用户输入命令。**该阶段引导的最终状态就是执行boot命令，将操作系统内核加载进入内存中，进而将控制权转交给内核。**\n\n---\n\n当内核加载完成后，内存被映射为：\n\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.38oakvdk2ge0.webp\" alt=\"内存映射\" style=\"zoom: 60%;\" />\n</div>\n\n\n## UEFI\n\n现在说BIOS，主要指的是UEFI，而不是传统的BIOS。不管是传统BIOS还是UEFI，都是经过ROM→RAM→BOOT的过程，主干是没有区别的，那么我们为什么需要UEFI呢？\n\n可以参考这个回答：[UEFI 引导与 BIOS 引导在原理上有什么区别？](https://www.zhihu.com/question/21672895)\n\n# Linux内核设置和启动\n\nLinux内核启动后，执行的是一系列检测，检测完成后跳转到`start_kernel函数`。这个函数会以依次初始化各个模块，比如页表、中断向量等，然后变成0号进程。0号进程会fork出1号kernel_init进程，`kernel_init`会执行init程序，大体的过程如下：\n\n---\n\n1. init进程读取`/etc/inittab`文件，作用是设定Linux的运行等级，决定进程运行模式。\n2. Linux执行第一个用户层文件`/etc/rc.d/rc.sysinit`，该文件功能包括：设定PATH运行变量、设定网络配置、启动swap分区、设定/proc、系统函数等.\n3. 读取`/etc/modules.conf`及`/etc/modules.d`目录下的文件来加载系统内核模块。\n4. 启动一些服务，之后执行`/etc/rc.d/rc.local`文件。\n5. 最后执行/bin/login程序，启动到登录界面，让用户输入用户名和密码。\n\n---\n\n完成用户的启动后，0号进程进入cpu_idle,变成idle进程。到这Linux差不多就启动好了。\n\n# 参考\n\n> 1. http://home.ustc.edu.cn/~hchunhui/linux_boot.html\n> 2. [https://437436999.github.io/2020/02/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/](https://437436999.github.io/2020/02/15/操作系统启动过程/)\n> 3. https://www.anquanke.com/post/id/227940\n","source":"_posts/Linux系统启动时.md","raw":"---\ntitle: Linux系统启动时\ndate: 2022-10-02 11:44:09\ntags:\n- 操作系统\n- Linux\n- 软硬件交互\n- BIOS\ncategories:\n- 操作系统\nbanner_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2vpyuzqapia0.webp\nindex_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2vpyuzqapia0.webp\nexcerpt: 从我们按下开机键到显示器上显示登录界面，这段时间里到底发生了什么？这篇文章将做一个简单的介绍\n---\n\n在Jyy老师的一节OS课上，内容是简单介绍Linux的启动流程，听完后我想更具体点知道这个启动的流程，所以特地搜素了一圈资料，以解答我心中之疑惑。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1zna45ggj5i8.webp\" alt=\"Linux启动流程\" style=\"zoom: 67%;\" /></div>\n\n# CPU Reset\n\n启动的第一步就是**Reset CPU**，即<u>设置CPU的各个寄存器为固定、已知的状态</u>。当我们按下电源按钮后，电源就开始给设备供电，一开始供电并不稳定，主板检测到后，就会一直给CPU发送**RESET信号**，此时的CPU就会清除寄存器上的残留数据并进行寄存器的设置：\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.3gbzr1spgf40.webp\" alt=\"image\" style=\"zoom:67%;\" /></div>\n\n在这之中最重要的寄存器是**CS（代码段）**和**EIP（指令指针）**。CS中隐式的Base（基地址）会与EIP相加，即`ffff 0000 H+fff0 H = ffff fff0 H`,其结果地址`0fff fff0 H` 被称为**重置向量**，<font color=purple>**主要包括一条跳转指令，指向BIOS的入口地址**</font>。\n\n<p class=\"note note-primary\">为什么重置向量不直接设为BIOS地址，而是跳转到BIOS呢？</p>\n\n<details>\n<summary>跳转到BIOS的解释</summary>\n<p><b>注意X86芯片一开始运行在实模式下，实模式只有20位寻址（1M空间），</b>而我们的重置向量是fff0H，到ffffH只有很短的距离，空间很小，不足以放下BIOS程序，所以要跳转。</p>\n<p><b>至于为什么不一开始就把重置向量设置为BIOS入口，</b>可能是希望把ROM放到可寻址空间的高层，以留出更大空间给内存。</p>\n</details>\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.4nbqyewemxw0.webp\" alt=\"实模式内存布局\" style=\"zoom: 80%;\" />\n</div>\n\n<p class=\"note note-info\">多核系统的CPU RESET</p>\n\n<details>\n<summary>多核系统下CPU RESET的解释</summary>\n    <p>多核计算机下，一开始要执行某个协议，系统将选取一个CPU来执行，其他CPU都等待，这个被选取的主CPU叫<b>Bootstrapping CPU（BSP）</b>。只有主CPU继续执行，其它CPU都进入一个等待状态，等待BSP给它们发指令，它们再开始继续执行。</p>\n</details>\n\n# BIOS执行\n\nBIOS是固定在EPROM中的程序，一般由硬件厂商写死，其负责引导系统的启动。其首先执行的程序的就是**加电自检（Power On Self Test，POST）**。\n\n## POST（加电自检）\n\nPOST用于计算机刚接通电源时对硬件部分的检测，如果自检中发现不是很严重的错误，系统会根据检测代码**给出提示信息或鸣笛警告**。\n\n**之所以使用鸣笛警告，是因为此时的显卡还没有完成初始化，无法将错误信息显示在屏幕上，只能通过声音报告错误**。\n\n检测的过程是逐一进行的，BIOS厂商对每个设备都提供了一个`POST CODE`，当对某个设备进行检测时，就会把这个POST CODE装到诊断的端口，如果没通过，这个CODE就会被保留，进行报警。\n\n## 初始化设备\n\nPOST结束后，BIOS还会调用各设备的BIOS进行自检和初始化，比如显卡BIOS，其会自检和初始化显卡，这个时候显示器就可以显示了。所有设备都是在这个时候被激活的。除了初始化设备，BIOS还会初始化[中断向量表](https://www.cnblogs.com/jadeshu/p/10663505.html)。\n\n## 启动Bootloader\n\n在检测和初始化各种设备之后，BIOS会查找用户自定义的启动顺序，默认是磁盘，当然也可以是光盘和U盘（以前重装操作系统时就会用到光盘和U盘）：\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5npilzacmlg0.webp\" alt=\"image\" style=\"zoom:80%;\" /></div>\n\n根据顺序，BIOS会把排在最前面的设备的**MBR（主引导记录）**，即<u>第0磁道第一个扇区的512字节</u>，读到**RAM绝对地址0x7C00处**，并跳转到这个地址。\n\n<p class=\"note note-primary\">MBR格式</p>\n\nMBR不属于任何一个操作系统，其512字节的内容如下：\n\n---\n\n- **启动代码(446B)**\n\n&emsp;&emsp;检查分区表的准确性，并将系统控制转移给硬盘上的Bootloader程序(比如现在常用的grub)。\n\n- **磁盘分区表(16 X 4B)**\n\n&emsp;&emsp;DPT，由四个分区表组成，每个16B，说明磁盘的分区情况。\n\n- **结束标志(2B)**\n\n&emsp;&emsp;该标志错误，无法启动。\n\n---\n\n# Bootloader\n\n所谓的Bootloader程序就是用来<font color=purple>**加载操作系统内核文件到内存**</font>，这类程序的主要功能为：\n\n---\n\n1. 从实模式使能保护模式，从16位寻址空间切换到32位寻址空间，使能**段机制**。\n2. 从硬盘读取ELF格式的kernel（跟在MBR后面的扇区）并放到内存中固定位置，这个过程一般分两步，最终是**执行`boot`命令**，加载系统引导菜单(`/boot/grub/menu.lst或grub.lst`)，`内核vmlinuz`和`RAM磁盘initrd`。\n3. 跳转到操作系统入口点执行，控制权交操作系统。\n\n---\n\n我们这里以GNU的**grub**为例。grub可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。grub被载入一般包括两个步骤：\n\n---\n\n1. 装载基本的引导装载程序—stage1，其主要功能是装载第二引导程序:stage2。\n2. 装载第二引导装载程序——stage2，这第二引导装载程序用于引出更高级的功能， 以允许用户装载入一个特定的操作系统。在grub中，这步是给用户显示一个菜单或是让用户输入命令。**该阶段引导的最终状态就是执行boot命令，将操作系统内核加载进入内存中，进而将控制权转交给内核。**\n\n---\n\n当内核加载完成后，内存被映射为：\n\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.38oakvdk2ge0.webp\" alt=\"内存映射\" style=\"zoom: 60%;\" />\n</div>\n\n\n## UEFI\n\n现在说BIOS，主要指的是UEFI，而不是传统的BIOS。不管是传统BIOS还是UEFI，都是经过ROM→RAM→BOOT的过程，主干是没有区别的，那么我们为什么需要UEFI呢？\n\n可以参考这个回答：[UEFI 引导与 BIOS 引导在原理上有什么区别？](https://www.zhihu.com/question/21672895)\n\n# Linux内核设置和启动\n\nLinux内核启动后，执行的是一系列检测，检测完成后跳转到`start_kernel函数`。这个函数会以依次初始化各个模块，比如页表、中断向量等，然后变成0号进程。0号进程会fork出1号kernel_init进程，`kernel_init`会执行init程序，大体的过程如下：\n\n---\n\n1. init进程读取`/etc/inittab`文件，作用是设定Linux的运行等级，决定进程运行模式。\n2. Linux执行第一个用户层文件`/etc/rc.d/rc.sysinit`，该文件功能包括：设定PATH运行变量、设定网络配置、启动swap分区、设定/proc、系统函数等.\n3. 读取`/etc/modules.conf`及`/etc/modules.d`目录下的文件来加载系统内核模块。\n4. 启动一些服务，之后执行`/etc/rc.d/rc.local`文件。\n5. 最后执行/bin/login程序，启动到登录界面，让用户输入用户名和密码。\n\n---\n\n完成用户的启动后，0号进程进入cpu_idle,变成idle进程。到这Linux差不多就启动好了。\n\n# 参考\n\n> 1. http://home.ustc.edu.cn/~hchunhui/linux_boot.html\n> 2. [https://437436999.github.io/2020/02/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/](https://437436999.github.io/2020/02/15/操作系统启动过程/)\n> 3. https://www.anquanke.com/post/id/227940\n","slug":"Linux系统启动时","published":1,"updated":"2022-10-02T06:05:48.821Z","_id":"cl8qxsjgw0000bkru2ebtf3xh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在Jyy老师的一节OS课上，内容是简单介绍Linux的启动流程，听完后我想更具体点知道这个启动的流程，所以特地搜素了一圈资料，以解答我心中之疑惑。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1zna45ggj5i8.webp\" alt=\"Linux启动流程\" style=\"zoom: 67%;\" /></div>\n\n<h1 id=\"CPU-Reset\"><a href=\"#CPU-Reset\" class=\"headerlink\" title=\"CPU Reset\"></a>CPU Reset</h1><p>启动的第一步就是<strong>Reset CPU</strong>，即<u>设置CPU的各个寄存器为固定、已知的状态</u>。当我们按下电源按钮后，电源就开始给设备供电，一开始供电并不稳定，主板检测到后，就会一直给CPU发送<strong>RESET信号</strong>，此时的CPU就会清除寄存器上的残留数据并进行寄存器的设置：</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.3gbzr1spgf40.webp\" alt=\"image\" style=\"zoom:67%;\" /></div>\n\n<p>在这之中最重要的寄存器是<strong>CS（代码段）</strong>和<strong>EIP（指令指针）</strong>。CS中隐式的Base（基地址）会与EIP相加，即<code>ffff 0000 H+fff0 H = ffff fff0 H</code>,其结果地址<code>0fff fff0 H</code> 被称为<strong>重置向量</strong>，<font color=purple><strong>主要包括一条跳转指令，指向BIOS的入口地址</strong></font>。</p>\n<p class=\"note note-primary\">为什么重置向量不直接设为BIOS地址，而是跳转到BIOS呢？</p>\n\n<details>\n<summary>跳转到BIOS的解释</summary>\n<p><b>注意X86芯片一开始运行在实模式下，实模式只有20位寻址（1M空间），</b>而我们的重置向量是fff0H，到ffffH只有很短的距离，空间很小，不足以放下BIOS程序，所以要跳转。</p>\n<p><b>至于为什么不一开始就把重置向量设置为BIOS入口，</b>可能是希望把ROM放到可寻址空间的高层，以留出更大空间给内存。</p>\n</details>\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.4nbqyewemxw0.webp\" alt=\"实模式内存布局\" style=\"zoom: 80%;\" />\n</div>\n\n<p class=\"note note-info\">多核系统的CPU RESET</p>\n\n<details>\n<summary>多核系统下CPU RESET的解释</summary>\n    <p>多核计算机下，一开始要执行某个协议，系统将选取一个CPU来执行，其他CPU都等待，这个被选取的主CPU叫<b>Bootstrapping CPU（BSP）</b>。只有主CPU继续执行，其它CPU都进入一个等待状态，等待BSP给它们发指令，它们再开始继续执行。</p>\n</details>\n\n<h1 id=\"BIOS执行\"><a href=\"#BIOS执行\" class=\"headerlink\" title=\"BIOS执行\"></a>BIOS执行</h1><p>BIOS是固定在EPROM中的程序，一般由硬件厂商写死，其负责引导系统的启动。其首先执行的程序的就是<strong>加电自检（Power On Self Test，POST）</strong>。</p>\n<h2 id=\"POST（加电自检）\"><a href=\"#POST（加电自检）\" class=\"headerlink\" title=\"POST（加电自检）\"></a>POST（加电自检）</h2><p>POST用于计算机刚接通电源时对硬件部分的检测，如果自检中发现不是很严重的错误，系统会根据检测代码<strong>给出提示信息或鸣笛警告</strong>。</p>\n<p><strong>之所以使用鸣笛警告，是因为此时的显卡还没有完成初始化，无法将错误信息显示在屏幕上，只能通过声音报告错误</strong>。</p>\n<p>检测的过程是逐一进行的，BIOS厂商对每个设备都提供了一个<code>POST CODE</code>，当对某个设备进行检测时，就会把这个POST CODE装到诊断的端口，如果没通过，这个CODE就会被保留，进行报警。</p>\n<h2 id=\"初始化设备\"><a href=\"#初始化设备\" class=\"headerlink\" title=\"初始化设备\"></a>初始化设备</h2><p>POST结束后，BIOS还会调用各设备的BIOS进行自检和初始化，比如显卡BIOS，其会自检和初始化显卡，这个时候显示器就可以显示了。所有设备都是在这个时候被激活的。除了初始化设备，BIOS还会初始化<a href=\"https://www.cnblogs.com/jadeshu/p/10663505.html\">中断向量表</a>。</p>\n<h2 id=\"启动Bootloader\"><a href=\"#启动Bootloader\" class=\"headerlink\" title=\"启动Bootloader\"></a>启动Bootloader</h2><p>在检测和初始化各种设备之后，BIOS会查找用户自定义的启动顺序，默认是磁盘，当然也可以是光盘和U盘（以前重装操作系统时就会用到光盘和U盘）：</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5npilzacmlg0.webp\" alt=\"image\" style=\"zoom:80%;\" /></div>\n\n<p>根据顺序，BIOS会把排在最前面的设备的<strong>MBR（主引导记录）</strong>，即<u>第0磁道第一个扇区的512字节</u>，读到<strong>RAM绝对地址0x7C00处</strong>，并跳转到这个地址。</p>\n<p class=\"note note-primary\">MBR格式</p>\n\n<p>MBR不属于任何一个操作系统，其512字节的内容如下：</p>\n<hr>\n<ul>\n<li><strong>启动代码(446B)</strong></li>\n</ul>\n<p>&emsp;&emsp;检查分区表的准确性，并将系统控制转移给硬盘上的Bootloader程序(比如现在常用的grub)。</p>\n<ul>\n<li><strong>磁盘分区表(16 X 4B)</strong></li>\n</ul>\n<p>&emsp;&emsp;DPT，由四个分区表组成，每个16B，说明磁盘的分区情况。</p>\n<ul>\n<li><strong>结束标志(2B)</strong></li>\n</ul>\n<p>&emsp;&emsp;该标志错误，无法启动。</p>\n<hr>\n<h1 id=\"Bootloader\"><a href=\"#Bootloader\" class=\"headerlink\" title=\"Bootloader\"></a>Bootloader</h1><p>所谓的Bootloader程序就是用来<font color=purple><strong>加载操作系统内核文件到内存</strong></font>，这类程序的主要功能为：</p>\n<hr>\n<ol>\n<li>从实模式使能保护模式，从16位寻址空间切换到32位寻址空间，使能<strong>段机制</strong>。</li>\n<li>从硬盘读取ELF格式的kernel（跟在MBR后面的扇区）并放到内存中固定位置，这个过程一般分两步，最终是<strong>执行<code>boot</code>命令</strong>，加载系统引导菜单(<code>/boot/grub/menu.lst或grub.lst</code>)，<code>内核vmlinuz</code>和<code>RAM磁盘initrd</code>。</li>\n<li>跳转到操作系统入口点执行，控制权交操作系统。</li>\n</ol>\n<hr>\n<p>我们这里以GNU的<strong>grub</strong>为例。grub可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。grub被载入一般包括两个步骤：</p>\n<hr>\n<ol>\n<li>装载基本的引导装载程序—stage1，其主要功能是装载第二引导程序:stage2。</li>\n<li>装载第二引导装载程序——stage2，这第二引导装载程序用于引出更高级的功能， 以允许用户装载入一个特定的操作系统。在grub中，这步是给用户显示一个菜单或是让用户输入命令。<strong>该阶段引导的最终状态就是执行boot命令，将操作系统内核加载进入内存中，进而将控制权转交给内核。</strong></li>\n</ol>\n<hr>\n<p>当内核加载完成后，内存被映射为：</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.38oakvdk2ge0.webp\" alt=\"内存映射\" style=\"zoom: 60%;\" />\n</div>\n\n\n<h2 id=\"UEFI\"><a href=\"#UEFI\" class=\"headerlink\" title=\"UEFI\"></a>UEFI</h2><p>现在说BIOS，主要指的是UEFI，而不是传统的BIOS。不管是传统BIOS还是UEFI，都是经过ROM→RAM→BOOT的过程，主干是没有区别的，那么我们为什么需要UEFI呢？</p>\n<p>可以参考这个回答：<a href=\"https://www.zhihu.com/question/21672895\">UEFI 引导与 BIOS 引导在原理上有什么区别？</a></p>\n<h1 id=\"Linux内核设置和启动\"><a href=\"#Linux内核设置和启动\" class=\"headerlink\" title=\"Linux内核设置和启动\"></a>Linux内核设置和启动</h1><p>Linux内核启动后，执行的是一系列检测，检测完成后跳转到<code>start_kernel函数</code>。这个函数会以依次初始化各个模块，比如页表、中断向量等，然后变成0号进程。0号进程会fork出1号kernel_init进程，<code>kernel_init</code>会执行init程序，大体的过程如下：</p>\n<hr>\n<ol>\n<li>init进程读取<code>/etc/inittab</code>文件，作用是设定Linux的运行等级，决定进程运行模式。</li>\n<li>Linux执行第一个用户层文件<code>/etc/rc.d/rc.sysinit</code>，该文件功能包括：设定PATH运行变量、设定网络配置、启动swap分区、设定/proc、系统函数等.</li>\n<li>读取<code>/etc/modules.conf</code>及<code>/etc/modules.d</code>目录下的文件来加载系统内核模块。</li>\n<li>启动一些服务，之后执行<code>/etc/rc.d/rc.local</code>文件。</li>\n<li>最后执行/bin/login程序，启动到登录界面，让用户输入用户名和密码。</li>\n</ol>\n<hr>\n<p>完成用户的启动后，0号进程进入cpu_idle,变成idle进程。到这Linux差不多就启动好了。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><blockquote>\n<ol>\n<li><a href=\"http://home.ustc.edu.cn/~hchunhui/linux_boot.html\">http://home.ustc.edu.cn/~hchunhui/linux_boot.html</a></li>\n<li><a href=\"https://437436999.github.io/2020/02/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/\">https://437436999.github.io/2020/02/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</a></li>\n<li><a href=\"https://www.anquanke.com/post/id/227940\">https://www.anquanke.com/post/id/227940</a></li>\n</ol>\n</blockquote>\n","site":{"data":{}},"more":"<p>在Jyy老师的一节OS课上，内容是简单介绍Linux的启动流程，听完后我想更具体点知道这个启动的流程，所以特地搜素了一圈资料，以解答我心中之疑惑。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1zna45ggj5i8.webp\" alt=\"Linux启动流程\" style=\"zoom: 67%;\" /></div>\n\n<h1 id=\"CPU-Reset\"><a href=\"#CPU-Reset\" class=\"headerlink\" title=\"CPU Reset\"></a>CPU Reset</h1><p>启动的第一步就是<strong>Reset CPU</strong>，即<u>设置CPU的各个寄存器为固定、已知的状态</u>。当我们按下电源按钮后，电源就开始给设备供电，一开始供电并不稳定，主板检测到后，就会一直给CPU发送<strong>RESET信号</strong>，此时的CPU就会清除寄存器上的残留数据并进行寄存器的设置：</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.3gbzr1spgf40.webp\" alt=\"image\" style=\"zoom:67%;\" /></div>\n\n<p>在这之中最重要的寄存器是<strong>CS（代码段）</strong>和<strong>EIP（指令指针）</strong>。CS中隐式的Base（基地址）会与EIP相加，即<code>ffff 0000 H+fff0 H = ffff fff0 H</code>,其结果地址<code>0fff fff0 H</code> 被称为<strong>重置向量</strong>，<font color=purple><strong>主要包括一条跳转指令，指向BIOS的入口地址</strong></font>。</p>\n<p class=\"note note-primary\">为什么重置向量不直接设为BIOS地址，而是跳转到BIOS呢？</p>\n\n<details>\n<summary>跳转到BIOS的解释</summary>\n<p><b>注意X86芯片一开始运行在实模式下，实模式只有20位寻址（1M空间），</b>而我们的重置向量是fff0H，到ffffH只有很短的距离，空间很小，不足以放下BIOS程序，所以要跳转。</p>\n<p><b>至于为什么不一开始就把重置向量设置为BIOS入口，</b>可能是希望把ROM放到可寻址空间的高层，以留出更大空间给内存。</p>\n</details>\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.4nbqyewemxw0.webp\" alt=\"实模式内存布局\" style=\"zoom: 80%;\" />\n</div>\n\n<p class=\"note note-info\">多核系统的CPU RESET</p>\n\n<details>\n<summary>多核系统下CPU RESET的解释</summary>\n    <p>多核计算机下，一开始要执行某个协议，系统将选取一个CPU来执行，其他CPU都等待，这个被选取的主CPU叫<b>Bootstrapping CPU（BSP）</b>。只有主CPU继续执行，其它CPU都进入一个等待状态，等待BSP给它们发指令，它们再开始继续执行。</p>\n</details>\n\n<h1 id=\"BIOS执行\"><a href=\"#BIOS执行\" class=\"headerlink\" title=\"BIOS执行\"></a>BIOS执行</h1><p>BIOS是固定在EPROM中的程序，一般由硬件厂商写死，其负责引导系统的启动。其首先执行的程序的就是<strong>加电自检（Power On Self Test，POST）</strong>。</p>\n<h2 id=\"POST（加电自检）\"><a href=\"#POST（加电自检）\" class=\"headerlink\" title=\"POST（加电自检）\"></a>POST（加电自检）</h2><p>POST用于计算机刚接通电源时对硬件部分的检测，如果自检中发现不是很严重的错误，系统会根据检测代码<strong>给出提示信息或鸣笛警告</strong>。</p>\n<p><strong>之所以使用鸣笛警告，是因为此时的显卡还没有完成初始化，无法将错误信息显示在屏幕上，只能通过声音报告错误</strong>。</p>\n<p>检测的过程是逐一进行的，BIOS厂商对每个设备都提供了一个<code>POST CODE</code>，当对某个设备进行检测时，就会把这个POST CODE装到诊断的端口，如果没通过，这个CODE就会被保留，进行报警。</p>\n<h2 id=\"初始化设备\"><a href=\"#初始化设备\" class=\"headerlink\" title=\"初始化设备\"></a>初始化设备</h2><p>POST结束后，BIOS还会调用各设备的BIOS进行自检和初始化，比如显卡BIOS，其会自检和初始化显卡，这个时候显示器就可以显示了。所有设备都是在这个时候被激活的。除了初始化设备，BIOS还会初始化<a href=\"https://www.cnblogs.com/jadeshu/p/10663505.html\">中断向量表</a>。</p>\n<h2 id=\"启动Bootloader\"><a href=\"#启动Bootloader\" class=\"headerlink\" title=\"启动Bootloader\"></a>启动Bootloader</h2><p>在检测和初始化各种设备之后，BIOS会查找用户自定义的启动顺序，默认是磁盘，当然也可以是光盘和U盘（以前重装操作系统时就会用到光盘和U盘）：</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5npilzacmlg0.webp\" alt=\"image\" style=\"zoom:80%;\" /></div>\n\n<p>根据顺序，BIOS会把排在最前面的设备的<strong>MBR（主引导记录）</strong>，即<u>第0磁道第一个扇区的512字节</u>，读到<strong>RAM绝对地址0x7C00处</strong>，并跳转到这个地址。</p>\n<p class=\"note note-primary\">MBR格式</p>\n\n<p>MBR不属于任何一个操作系统，其512字节的内容如下：</p>\n<hr>\n<ul>\n<li><strong>启动代码(446B)</strong></li>\n</ul>\n<p>&emsp;&emsp;检查分区表的准确性，并将系统控制转移给硬盘上的Bootloader程序(比如现在常用的grub)。</p>\n<ul>\n<li><strong>磁盘分区表(16 X 4B)</strong></li>\n</ul>\n<p>&emsp;&emsp;DPT，由四个分区表组成，每个16B，说明磁盘的分区情况。</p>\n<ul>\n<li><strong>结束标志(2B)</strong></li>\n</ul>\n<p>&emsp;&emsp;该标志错误，无法启动。</p>\n<hr>\n<h1 id=\"Bootloader\"><a href=\"#Bootloader\" class=\"headerlink\" title=\"Bootloader\"></a>Bootloader</h1><p>所谓的Bootloader程序就是用来<font color=purple><strong>加载操作系统内核文件到内存</strong></font>，这类程序的主要功能为：</p>\n<hr>\n<ol>\n<li>从实模式使能保护模式，从16位寻址空间切换到32位寻址空间，使能<strong>段机制</strong>。</li>\n<li>从硬盘读取ELF格式的kernel（跟在MBR后面的扇区）并放到内存中固定位置，这个过程一般分两步，最终是<strong>执行<code>boot</code>命令</strong>，加载系统引导菜单(<code>/boot/grub/menu.lst或grub.lst</code>)，<code>内核vmlinuz</code>和<code>RAM磁盘initrd</code>。</li>\n<li>跳转到操作系统入口点执行，控制权交操作系统。</li>\n</ol>\n<hr>\n<p>我们这里以GNU的<strong>grub</strong>为例。grub可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。grub被载入一般包括两个步骤：</p>\n<hr>\n<ol>\n<li>装载基本的引导装载程序—stage1，其主要功能是装载第二引导程序:stage2。</li>\n<li>装载第二引导装载程序——stage2，这第二引导装载程序用于引出更高级的功能， 以允许用户装载入一个特定的操作系统。在grub中，这步是给用户显示一个菜单或是让用户输入命令。<strong>该阶段引导的最终状态就是执行boot命令，将操作系统内核加载进入内存中，进而将控制权转交给内核。</strong></li>\n</ol>\n<hr>\n<p>当内核加载完成后，内存被映射为：</p>\n<div align=center>\n<img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.38oakvdk2ge0.webp\" alt=\"内存映射\" style=\"zoom: 60%;\" />\n</div>\n\n\n<h2 id=\"UEFI\"><a href=\"#UEFI\" class=\"headerlink\" title=\"UEFI\"></a>UEFI</h2><p>现在说BIOS，主要指的是UEFI，而不是传统的BIOS。不管是传统BIOS还是UEFI，都是经过ROM→RAM→BOOT的过程，主干是没有区别的，那么我们为什么需要UEFI呢？</p>\n<p>可以参考这个回答：<a href=\"https://www.zhihu.com/question/21672895\">UEFI 引导与 BIOS 引导在原理上有什么区别？</a></p>\n<h1 id=\"Linux内核设置和启动\"><a href=\"#Linux内核设置和启动\" class=\"headerlink\" title=\"Linux内核设置和启动\"></a>Linux内核设置和启动</h1><p>Linux内核启动后，执行的是一系列检测，检测完成后跳转到<code>start_kernel函数</code>。这个函数会以依次初始化各个模块，比如页表、中断向量等，然后变成0号进程。0号进程会fork出1号kernel_init进程，<code>kernel_init</code>会执行init程序，大体的过程如下：</p>\n<hr>\n<ol>\n<li>init进程读取<code>/etc/inittab</code>文件，作用是设定Linux的运行等级，决定进程运行模式。</li>\n<li>Linux执行第一个用户层文件<code>/etc/rc.d/rc.sysinit</code>，该文件功能包括：设定PATH运行变量、设定网络配置、启动swap分区、设定/proc、系统函数等.</li>\n<li>读取<code>/etc/modules.conf</code>及<code>/etc/modules.d</code>目录下的文件来加载系统内核模块。</li>\n<li>启动一些服务，之后执行<code>/etc/rc.d/rc.local</code>文件。</li>\n<li>最后执行/bin/login程序，启动到登录界面，让用户输入用户名和密码。</li>\n</ol>\n<hr>\n<p>完成用户的启动后，0号进程进入cpu_idle,变成idle进程。到这Linux差不多就启动好了。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><blockquote>\n<ol>\n<li><a href=\"http://home.ustc.edu.cn/~hchunhui/linux_boot.html\">http://home.ustc.edu.cn/~hchunhui/linux_boot.html</a></li>\n<li><a href=\"https://437436999.github.io/2020/02/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/\">https://437436999.github.io/2020/02/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</a></li>\n<li><a href=\"https://www.anquanke.com/post/id/227940\">https://www.anquanke.com/post/id/227940</a></li>\n</ol>\n</blockquote>\n"},{"title":"近代中国知识分子的探索之路","date":"2022-10-04T00:55:26.000Z","banner_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.3qbdx6eu6yg0.webp","index_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.wnyzpf0qz9c.webp","excerpt":"《解读中国经济》—近代的屈辱与社会主义的救赎之路","_content":"\n# 近代之耻辱\n\n对于中国来说，清朝中期到新中国成立之前这一百多年是耻辱的，中国丢掉了尊严，打仗打不赢，不是割地就是赔款。作为曾经的世界老大混成这鸟样，领导班子肯定得负责，但我们也不能全怪清政府，教科书上总写着是因为清政府的腐败无能，所以才导致中国堕落到如此地步，但事实可能并不与之相符。\n\n![不平等条约](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5zm15vf1sxg0.webp)\n\n清朝历史上其实并没有出现过让老百姓没日子过的主子，民间的反清势力也并不是因为日子过不下去了才造反的，纯粹是出于民族情结；至于腐败贪污，试问哪个朝代没有。所以呢，将中国积弱的责任一股脑扣在清朝统治者的头上，那还真是不太公平。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.ahmj3nz8juw.webp\" alt=\"image\" style=\"zoom:47%;\" />\n</div>\n\n\n中国之所以落后于西方，这原因也在[李约瑟之谜](https://www.sailyang.top/2022/10/01/%E6%9D%8E%E7%BA%A6%E7%91%9F%E4%B9%8B%E8%B0%9C/)中说了，直接原因还是在工业革命上。技术上差距的不断拉大，让残酷的现实一次次摆在了中国人身上。我国儒家文化强调**忠君爱国，以天下为己任**，中国知识分子们由此对国家形成了强烈的责任感。这种责任感表现为两方面：\n\n---\n\n1. 一方面，知识分子们有一种让国家重新强盛起来的使命感。\n2. 另一方面，面对一次次战败和欺凌而有无力反抗的屈辱，知识分子们背着巨大的挫折感。\n\n---\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6cffna8clfw0.webp\" alt=\"image\" style=\"zoom: 33%;\" /></div>\n\n**复兴中国**是理解近代中国政治、经济和文化的重要线索。\n\n> 在新崛起文明与古老文明的冲突中，知识分子对于国外文明的反应和理解必然会涉及文明和文化的含义。——《文明的冲突》\n\n# 探索之路\n\n**何谓文化和文明？**\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.nclq9gqysgw.webp\" alt=\"image\" style=\"zoom: 80%;\" /></div>\n\n马克思认为，<u>经济基础决定上层建筑，两者合一块就是文化体系</u>。\n\n马林诺夫斯基认为，<u>文化是器物、制度组织和精神伦理价值三者的有机结合</u>。\n\n有了对文化与文明的认识后，我们来看看先辈们探寻救国之道的思路。\n\n## 鸦片战争→中学为体，西学为用\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5xtmxcw7vyw0.webp\" alt=\"汉阳铁厂\" style=\"zoom:60%;\" /></div>\n\n1840的鸦片战争引起了中国知识分子的深沉反思，反思的结果呢，就是<u>俺们大清朝的器物，也就是武器比不上洋人，所以吃了败仗。那么自然而然的，我只要有洋人的洋枪洋炮，大清朝的威严不就回来了</u>？由此，便引发了**洋务运动**，其内容就是”<u>中学为体，西学为用</u>“。\n\n有一点不能忽视，为什么这个时候不主张全盘西化呢？因为<font color=purple>**当时的中国知识分子对自己国家的制度和文化还是很有自信的，认为中国文化的社会组织和价值体系都具有优越性，他们还是把自己看成”天朝上国“**。</font>\n\n洋务运动还是取得了一定的成果，最突出的成就就是三只水师（北洋、南洋和福建水师）的建立。\n\n## 中日甲午战争→戊戌变法、民主革命\n\n日本明治维新后发展特别快，开始对中国的小弟朝鲜虎视眈眈，由此便引发了中日甲午战争。战争开始之前，舆论一边倒向中国，因为中国可是拥有最先进的海军军舰（从西方买的），而日本可买不起这样的军舰。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.74brmnciudw0.webp\" alt=\"中日甲午战争\" style=\"zoom:80%;\" /></div>\n\n但中国还是吃了败仗，根本原因**在于现代化的枪炮有了，可是没有现代军队的组织和纪律，使不出这洋枪洋炮的威力，自然是吃败仗**。这场败仗送走了台湾，知识分子们又开始反思了，小日本同样是被西方欺负，但是三十年间，跟西方学制度，使用君主立宪，废除科举（科举的弊端不在制度而是在考的内容），很快就超过了咱们这天朝上国。\n\n中国的知识分子由此形成了两种思路：一种是保皇派，主张君主立宪，代表就是维新运动的”戊戌变法“，但最后失败了；第二种是革命派，是以孙中山为代表的海外华侨和留学生，他们**主张美国的制度：总统制，因此必须推翻清政府，建立一个民主制国家**。\n\n不管是哪派，中国的知识分子们已经反思到制度和社会组织的问题了，其基本思路是一致的，就是要**在中国推行一场社会和政治制度的大变革**。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.175kxk8ocwow.webp\" alt=\"五四革命\" style=\"zoom:80%;\" /></div>\n\n可是还是差一点，这最后一点呢，就是**”五四革命“**。俗话说，五四革命带来了德先生和赛先生，没错，<font color=purple>**差的就是现代的精神和价值观”民主“ 和”科学“**</font>。\n\n## 社会主义思潮\n\n经过上面这么一个思想的渐进变化过程，从器物→制度→现代精神，中国的知识分子分为了两派：**主张全盘西化**和**社会主义**。\n\n那么，为什么社会主义思潮会盛行呢？\n\n首先要明白，中国人虽然不得不向洋人低头，但是内心是不愿屈服的，俗话说争口气。如果有这样一种制度，比西方洋人的制度还优越，那么就会很有市场。当时西方还处于资本主义早期，资本家和工人的矛盾是很大的，冲突频发，由此诞生了马克思主义。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6doc15b96kw0.webp\" alt=\"image\" style=\"zoom:60%;\" /></div>\n\n当时中国流行一句话，”<u>毕其功于一役</u>“，什么意思呢？**就是主张共产主义，越过资本主义这一发展阶段**，这在孙中山的三民主义里有体现，所谓的民生主义就是共产主义。除此之外呢，俄国建立了全世界第一个社会主义政权，还取消了对中国的不平等条约，这虽是顺水人情（俄国当时搞不过西方国家，在华利益本来就不保），但可让中国感激涕零，起到了很大的鼓舞作用，**这也是为什么孙中山开始联俄联共了**。\n\n# 社会主义革命道路的探索\n\n马克思列宁主义为中国共产党的建立奠定了基础，但是社会主义运动在中国的开展还是要经历一系列思想和认知问题的探究的。\n\n## 马克思主义与列宁主义的区别\n\n按照马克思的历史唯物主义，社会主义革命只在资本家与工人阶级的矛盾积累到一定程度才爆发。因为工人社会资源稀少，势单力薄，所以需要积少成多，联合工人阶级，而且一个国家还不够，因为一个国家的工人暴动，周边国家的资本家为了自保，肯定会帮助这个国家镇压，所以**需要在发达资本主义国家同时发生社会主义革命，革命才会成功**。\n\n列宁主张**社会主义革命可以在单一国家发生，而且不一定是发达资本主义国家**，但前提是<u>必须有一个由社会精英组成的共产党来领导这场革命</u>。以这些精英为核心。团结无产阶级大众，就能取代革命的成功。事实上，列宁确实做到了，俄国真的推翻了沙皇的统治。\n\n## 列宁主义为何在中国行不通\n\n俄国的模式是列宁主义模式，先成立一个共产党，然后发动城市暴动，由此推翻沙皇，建立了苏联。可是呢，这在中国却行不通，早期的中共的确是这么干的，可是屡战屡败。这是为什么呢？\n\n简单说就是环境不同，没有因地制宜，那具体是环境上哪不同呢？\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2w7ld2ikoh40.webp\" alt=\"发生在租界的五卅运动\" style=\"zoom:80%;\" /></div>\n\n**在俄国，工业集中在城市，主要是贵族拥有；而在中国，工业集中在租界，为外国人所有，跟中国政府关系不是很大**。在俄国沙皇时代，沙皇去镇压工人暴动，社会的矛盾指向的是沙皇的政府，人们认为是沙皇的政府在庇佑资本家去剥削底层人民；在中国的租界里，不是中国政府在剥削中国人民，而是洋人资本家在用自己政府的武力镇压，那么矛头对的不是中国政府（蒋介石政府），而是洋人。蒋介石渔翁得利，还得了人心。\n\n列宁主义在中国的失败告诉我们，外国的理论不能照搬照抄，前提发生了变化，理论产生的效果可能大不相同。<font color=purple>**理论不是真理，理论是一种假说，只在特定条件下才能得以应用和实现**</font>。\n\n## 农村包围城市战略的成功\n\n那马克思主义和列宁主义怎么改造成适合我国国情呢？这就要说到毛主席的农村包围城市了。\n\n马列主义认为，发动革命的一个前提是<u>社会存在不公平和财富分配严重不均的情况</u>。中国的城市是存在资本家和工人的矛盾，但别忘了，**中国社会更为广大的根基是农民**。中国农村里，分地主、贫农和无地农民，按照50年代刚刚革命成功统计，中国占3%的地址控制了26%的土地，占68%的贫农拥有22%的土地，土地分配的差距是非常大的，**这种分配不均是远远大于城市的**。毛泽东的“打土豪，分田地”显然更符合我国国情，把地主的土地分给农民，农民自然跟着共产党混了。\n\n农村包围城市战略成功的另一个原因是，**传统社会中，中国政府对农村的控制力是很低的，**为什么呢？因为政府的管理只到县一级，县以下的都靠士绅（地主）管理。农民一暴动，国民党政府就要派兵镇压农民，镇压“打土豪，分田地”运动，这就相当于沙皇政府镇压工人运动。这样矛头自然对准国民党政府，从而使之丧失了执政的合法性与民心。毛主席不得不说真是活学活用理论，他突破了马列主义只依靠最先进的工人阶级这一理论，选择依靠更为广大的农民群众。\n\n共产党在当时的核心战略是“**团结大多数，打击一小撮**”，<u>这一小撮不是所有的资本家，而是当时以“蒋宋孔陈”为代表的官僚资本</u>，那些收到打压的民族资本家是共产党要团结的。\n\n# 照搬苏联老大哥的经济措施\n\n## 为什么重工业优先？\n\n新中国成立后，推行了重工业优先的发展策略，并开始了计划经济体制。这套制度从1950~1978，执行了28年，最后证明确实行不通。那么，**为什么毛泽东在革命时，活学活用马列主义，而在新中国成立后，却照搬苏联的经验来建设新中国呢？**难道是毛主席不懂经济和建设，只懂革命？那显然是错的，因为毛主席不仅没有治国的经验，革命的经验也是没有的😅。\n\n实际上，照搬苏联经验，也是毛主席实事求是的行为。因为革命时，中国与苏联目标一致，但是环境不一致，所以不能照搬；但是建设新中国时，和苏联的目标一致，环境也是一致的，所以认为可以照搬苏联经验。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.3k1pgjt6f2w0.webp\" alt=\"image\" style=\"zoom:80%;\" /></div>\n\n新中国是脆弱的，要想中国富强，当务之急是需要强大的国防，而强大的国防需要强大的军事工业，而强大的军事工业必须要有强大的重工业打地基。因此，中国选择重工业优先的策略，目的是不再让中国受洋人的欺凌。苏联的经验为中国提供了参照，因为苏联在1929之前，也是一个贫穷的农业国家，但是在斯大林的领导下，工业化非常快，迅速形成了自己的重工业体系和国防体系；而当时的西方国家因为经济大萧条，日子并不好过。这么一对比，自然深入一众发展中国家的心里，包括中国的领导人们。\n\n## 重工业优先发展与要素禀赋的矛盾\n\n重工业有三个基本特性：\n\n---\n\n1. 建设周期长：为什么设那么多五年计划啊？就是这个原因。重工业建设周期长；而轻工业可能当年投资，当年投产，当年就能收益。\n2. 如果是贫穷落后的发展中国家，**设备得进口**。\n3. **一次性投入非常大**，几十亿都很常见。\n\n---\n\n一个贫穷的农业国也有三个基本特性：\n\n---\n\n1. 剩余少：所谓自给自足的小农经济，就是导致剩余少的原因。大部分人是农民，生产活动集中在种地，自己人吃完剩下的产品是很少的，这部分拿到市场去换资金，显然资金是非常少的，这就导致资本的积累不足，资金的价格就非常高。\n2. 可供出口的产品少：出口少，就会导致赚到的外汇少，所以外汇价格（汇率）很很高。\n3. 资金分散，难以集中：说白了就是银行少，拿不到钱，老百姓自己手里就那么点钱，没必要送到银行去。只要钱不进银行，就会有资金动员困难的问题。\n\n---\n\n上面这矛盾就很明显了，如果正常情况下民间借贷的月利率是2.5%，年利率就是30%左右。如果一个项目要十年投产，投产之后才能盈利，那么按照年利率30%复利计算，十年之后要还的本息和是原贷款的13.7倍，而要保持这样的高利润，是很稀少的。此外，机器要进口，外汇价格又高，导致**工业建设的成本肯定偏高，资金又难集中**。\n\n欸嘿，那怎么办呢？苏联当时遇到这个问题，推行的是<u>计划经济体制</u>，把国家的资源集中起来；中国在20年后也遇到了这个问题，而计划经济也确实比较有效于建设重工业，所以呢，俺们就照搬照抄了，属实是实事求是的行为。\n","source":"_posts/近代屈辱与社会主义革命.md","raw":"---\ntitle: 近代中国知识分子的探索之路\ndate: 2022-10-04 08:55:26\ntags:\n - 中国经济\ncategories:\n- 经济学\n- 中国经济\nbanner_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.3qbdx6eu6yg0.webp\nindex_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.wnyzpf0qz9c.webp\nexcerpt: 《解读中国经济》—近代的屈辱与社会主义的救赎之路\n---\n\n# 近代之耻辱\n\n对于中国来说，清朝中期到新中国成立之前这一百多年是耻辱的，中国丢掉了尊严，打仗打不赢，不是割地就是赔款。作为曾经的世界老大混成这鸟样，领导班子肯定得负责，但我们也不能全怪清政府，教科书上总写着是因为清政府的腐败无能，所以才导致中国堕落到如此地步，但事实可能并不与之相符。\n\n![不平等条约](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5zm15vf1sxg0.webp)\n\n清朝历史上其实并没有出现过让老百姓没日子过的主子，民间的反清势力也并不是因为日子过不下去了才造反的，纯粹是出于民族情结；至于腐败贪污，试问哪个朝代没有。所以呢，将中国积弱的责任一股脑扣在清朝统治者的头上，那还真是不太公平。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.ahmj3nz8juw.webp\" alt=\"image\" style=\"zoom:47%;\" />\n</div>\n\n\n中国之所以落后于西方，这原因也在[李约瑟之谜](https://www.sailyang.top/2022/10/01/%E6%9D%8E%E7%BA%A6%E7%91%9F%E4%B9%8B%E8%B0%9C/)中说了，直接原因还是在工业革命上。技术上差距的不断拉大，让残酷的现实一次次摆在了中国人身上。我国儒家文化强调**忠君爱国，以天下为己任**，中国知识分子们由此对国家形成了强烈的责任感。这种责任感表现为两方面：\n\n---\n\n1. 一方面，知识分子们有一种让国家重新强盛起来的使命感。\n2. 另一方面，面对一次次战败和欺凌而有无力反抗的屈辱，知识分子们背着巨大的挫折感。\n\n---\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6cffna8clfw0.webp\" alt=\"image\" style=\"zoom: 33%;\" /></div>\n\n**复兴中国**是理解近代中国政治、经济和文化的重要线索。\n\n> 在新崛起文明与古老文明的冲突中，知识分子对于国外文明的反应和理解必然会涉及文明和文化的含义。——《文明的冲突》\n\n# 探索之路\n\n**何谓文化和文明？**\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.nclq9gqysgw.webp\" alt=\"image\" style=\"zoom: 80%;\" /></div>\n\n马克思认为，<u>经济基础决定上层建筑，两者合一块就是文化体系</u>。\n\n马林诺夫斯基认为，<u>文化是器物、制度组织和精神伦理价值三者的有机结合</u>。\n\n有了对文化与文明的认识后，我们来看看先辈们探寻救国之道的思路。\n\n## 鸦片战争→中学为体，西学为用\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5xtmxcw7vyw0.webp\" alt=\"汉阳铁厂\" style=\"zoom:60%;\" /></div>\n\n1840的鸦片战争引起了中国知识分子的深沉反思，反思的结果呢，就是<u>俺们大清朝的器物，也就是武器比不上洋人，所以吃了败仗。那么自然而然的，我只要有洋人的洋枪洋炮，大清朝的威严不就回来了</u>？由此，便引发了**洋务运动**，其内容就是”<u>中学为体，西学为用</u>“。\n\n有一点不能忽视，为什么这个时候不主张全盘西化呢？因为<font color=purple>**当时的中国知识分子对自己国家的制度和文化还是很有自信的，认为中国文化的社会组织和价值体系都具有优越性，他们还是把自己看成”天朝上国“**。</font>\n\n洋务运动还是取得了一定的成果，最突出的成就就是三只水师（北洋、南洋和福建水师）的建立。\n\n## 中日甲午战争→戊戌变法、民主革命\n\n日本明治维新后发展特别快，开始对中国的小弟朝鲜虎视眈眈，由此便引发了中日甲午战争。战争开始之前，舆论一边倒向中国，因为中国可是拥有最先进的海军军舰（从西方买的），而日本可买不起这样的军舰。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.74brmnciudw0.webp\" alt=\"中日甲午战争\" style=\"zoom:80%;\" /></div>\n\n但中国还是吃了败仗，根本原因**在于现代化的枪炮有了，可是没有现代军队的组织和纪律，使不出这洋枪洋炮的威力，自然是吃败仗**。这场败仗送走了台湾，知识分子们又开始反思了，小日本同样是被西方欺负，但是三十年间，跟西方学制度，使用君主立宪，废除科举（科举的弊端不在制度而是在考的内容），很快就超过了咱们这天朝上国。\n\n中国的知识分子由此形成了两种思路：一种是保皇派，主张君主立宪，代表就是维新运动的”戊戌变法“，但最后失败了；第二种是革命派，是以孙中山为代表的海外华侨和留学生，他们**主张美国的制度：总统制，因此必须推翻清政府，建立一个民主制国家**。\n\n不管是哪派，中国的知识分子们已经反思到制度和社会组织的问题了，其基本思路是一致的，就是要**在中国推行一场社会和政治制度的大变革**。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.175kxk8ocwow.webp\" alt=\"五四革命\" style=\"zoom:80%;\" /></div>\n\n可是还是差一点，这最后一点呢，就是**”五四革命“**。俗话说，五四革命带来了德先生和赛先生，没错，<font color=purple>**差的就是现代的精神和价值观”民主“ 和”科学“**</font>。\n\n## 社会主义思潮\n\n经过上面这么一个思想的渐进变化过程，从器物→制度→现代精神，中国的知识分子分为了两派：**主张全盘西化**和**社会主义**。\n\n那么，为什么社会主义思潮会盛行呢？\n\n首先要明白，中国人虽然不得不向洋人低头，但是内心是不愿屈服的，俗话说争口气。如果有这样一种制度，比西方洋人的制度还优越，那么就会很有市场。当时西方还处于资本主义早期，资本家和工人的矛盾是很大的，冲突频发，由此诞生了马克思主义。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6doc15b96kw0.webp\" alt=\"image\" style=\"zoom:60%;\" /></div>\n\n当时中国流行一句话，”<u>毕其功于一役</u>“，什么意思呢？**就是主张共产主义，越过资本主义这一发展阶段**，这在孙中山的三民主义里有体现，所谓的民生主义就是共产主义。除此之外呢，俄国建立了全世界第一个社会主义政权，还取消了对中国的不平等条约，这虽是顺水人情（俄国当时搞不过西方国家，在华利益本来就不保），但可让中国感激涕零，起到了很大的鼓舞作用，**这也是为什么孙中山开始联俄联共了**。\n\n# 社会主义革命道路的探索\n\n马克思列宁主义为中国共产党的建立奠定了基础，但是社会主义运动在中国的开展还是要经历一系列思想和认知问题的探究的。\n\n## 马克思主义与列宁主义的区别\n\n按照马克思的历史唯物主义，社会主义革命只在资本家与工人阶级的矛盾积累到一定程度才爆发。因为工人社会资源稀少，势单力薄，所以需要积少成多，联合工人阶级，而且一个国家还不够，因为一个国家的工人暴动，周边国家的资本家为了自保，肯定会帮助这个国家镇压，所以**需要在发达资本主义国家同时发生社会主义革命，革命才会成功**。\n\n列宁主张**社会主义革命可以在单一国家发生，而且不一定是发达资本主义国家**，但前提是<u>必须有一个由社会精英组成的共产党来领导这场革命</u>。以这些精英为核心。团结无产阶级大众，就能取代革命的成功。事实上，列宁确实做到了，俄国真的推翻了沙皇的统治。\n\n## 列宁主义为何在中国行不通\n\n俄国的模式是列宁主义模式，先成立一个共产党，然后发动城市暴动，由此推翻沙皇，建立了苏联。可是呢，这在中国却行不通，早期的中共的确是这么干的，可是屡战屡败。这是为什么呢？\n\n简单说就是环境不同，没有因地制宜，那具体是环境上哪不同呢？\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2w7ld2ikoh40.webp\" alt=\"发生在租界的五卅运动\" style=\"zoom:80%;\" /></div>\n\n**在俄国，工业集中在城市，主要是贵族拥有；而在中国，工业集中在租界，为外国人所有，跟中国政府关系不是很大**。在俄国沙皇时代，沙皇去镇压工人暴动，社会的矛盾指向的是沙皇的政府，人们认为是沙皇的政府在庇佑资本家去剥削底层人民；在中国的租界里，不是中国政府在剥削中国人民，而是洋人资本家在用自己政府的武力镇压，那么矛头对的不是中国政府（蒋介石政府），而是洋人。蒋介石渔翁得利，还得了人心。\n\n列宁主义在中国的失败告诉我们，外国的理论不能照搬照抄，前提发生了变化，理论产生的效果可能大不相同。<font color=purple>**理论不是真理，理论是一种假说，只在特定条件下才能得以应用和实现**</font>。\n\n## 农村包围城市战略的成功\n\n那马克思主义和列宁主义怎么改造成适合我国国情呢？这就要说到毛主席的农村包围城市了。\n\n马列主义认为，发动革命的一个前提是<u>社会存在不公平和财富分配严重不均的情况</u>。中国的城市是存在资本家和工人的矛盾，但别忘了，**中国社会更为广大的根基是农民**。中国农村里，分地主、贫农和无地农民，按照50年代刚刚革命成功统计，中国占3%的地址控制了26%的土地，占68%的贫农拥有22%的土地，土地分配的差距是非常大的，**这种分配不均是远远大于城市的**。毛泽东的“打土豪，分田地”显然更符合我国国情，把地主的土地分给农民，农民自然跟着共产党混了。\n\n农村包围城市战略成功的另一个原因是，**传统社会中，中国政府对农村的控制力是很低的，**为什么呢？因为政府的管理只到县一级，县以下的都靠士绅（地主）管理。农民一暴动，国民党政府就要派兵镇压农民，镇压“打土豪，分田地”运动，这就相当于沙皇政府镇压工人运动。这样矛头自然对准国民党政府，从而使之丧失了执政的合法性与民心。毛主席不得不说真是活学活用理论，他突破了马列主义只依靠最先进的工人阶级这一理论，选择依靠更为广大的农民群众。\n\n共产党在当时的核心战略是“**团结大多数，打击一小撮**”，<u>这一小撮不是所有的资本家，而是当时以“蒋宋孔陈”为代表的官僚资本</u>，那些收到打压的民族资本家是共产党要团结的。\n\n# 照搬苏联老大哥的经济措施\n\n## 为什么重工业优先？\n\n新中国成立后，推行了重工业优先的发展策略，并开始了计划经济体制。这套制度从1950~1978，执行了28年，最后证明确实行不通。那么，**为什么毛泽东在革命时，活学活用马列主义，而在新中国成立后，却照搬苏联的经验来建设新中国呢？**难道是毛主席不懂经济和建设，只懂革命？那显然是错的，因为毛主席不仅没有治国的经验，革命的经验也是没有的😅。\n\n实际上，照搬苏联经验，也是毛主席实事求是的行为。因为革命时，中国与苏联目标一致，但是环境不一致，所以不能照搬；但是建设新中国时，和苏联的目标一致，环境也是一致的，所以认为可以照搬苏联经验。\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.3k1pgjt6f2w0.webp\" alt=\"image\" style=\"zoom:80%;\" /></div>\n\n新中国是脆弱的，要想中国富强，当务之急是需要强大的国防，而强大的国防需要强大的军事工业，而强大的军事工业必须要有强大的重工业打地基。因此，中国选择重工业优先的策略，目的是不再让中国受洋人的欺凌。苏联的经验为中国提供了参照，因为苏联在1929之前，也是一个贫穷的农业国家，但是在斯大林的领导下，工业化非常快，迅速形成了自己的重工业体系和国防体系；而当时的西方国家因为经济大萧条，日子并不好过。这么一对比，自然深入一众发展中国家的心里，包括中国的领导人们。\n\n## 重工业优先发展与要素禀赋的矛盾\n\n重工业有三个基本特性：\n\n---\n\n1. 建设周期长：为什么设那么多五年计划啊？就是这个原因。重工业建设周期长；而轻工业可能当年投资，当年投产，当年就能收益。\n2. 如果是贫穷落后的发展中国家，**设备得进口**。\n3. **一次性投入非常大**，几十亿都很常见。\n\n---\n\n一个贫穷的农业国也有三个基本特性：\n\n---\n\n1. 剩余少：所谓自给自足的小农经济，就是导致剩余少的原因。大部分人是农民，生产活动集中在种地，自己人吃完剩下的产品是很少的，这部分拿到市场去换资金，显然资金是非常少的，这就导致资本的积累不足，资金的价格就非常高。\n2. 可供出口的产品少：出口少，就会导致赚到的外汇少，所以外汇价格（汇率）很很高。\n3. 资金分散，难以集中：说白了就是银行少，拿不到钱，老百姓自己手里就那么点钱，没必要送到银行去。只要钱不进银行，就会有资金动员困难的问题。\n\n---\n\n上面这矛盾就很明显了，如果正常情况下民间借贷的月利率是2.5%，年利率就是30%左右。如果一个项目要十年投产，投产之后才能盈利，那么按照年利率30%复利计算，十年之后要还的本息和是原贷款的13.7倍，而要保持这样的高利润，是很稀少的。此外，机器要进口，外汇价格又高，导致**工业建设的成本肯定偏高，资金又难集中**。\n\n欸嘿，那怎么办呢？苏联当时遇到这个问题，推行的是<u>计划经济体制</u>，把国家的资源集中起来；中国在20年后也遇到了这个问题，而计划经济也确实比较有效于建设重工业，所以呢，俺们就照搬照抄了，属实是实事求是的行为。\n","slug":"近代屈辱与社会主义革命","published":1,"updated":"2022-10-15T10:43:07.949Z","_id":"cl8vrh3du0000gsru5bzcb2tg","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"近代之耻辱\"><a href=\"#近代之耻辱\" class=\"headerlink\" title=\"近代之耻辱\"></a>近代之耻辱</h1><p>对于中国来说，清朝中期到新中国成立之前这一百多年是耻辱的，中国丢掉了尊严，打仗打不赢，不是割地就是赔款。作为曾经的世界老大混成这鸟样，领导班子肯定得负责，但我们也不能全怪清政府，教科书上总写着是因为清政府的腐败无能，所以才导致中国堕落到如此地步，但事实可能并不与之相符。</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5zm15vf1sxg0.webp\" alt=\"不平等条约\"></p>\n<p>清朝历史上其实并没有出现过让老百姓没日子过的主子，民间的反清势力也并不是因为日子过不下去了才造反的，纯粹是出于民族情结；至于腐败贪污，试问哪个朝代没有。所以呢，将中国积弱的责任一股脑扣在清朝统治者的头上，那还真是不太公平。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.ahmj3nz8juw.webp\" alt=\"image\" style=\"zoom:47%;\" />\n</div>\n\n\n<p>中国之所以落后于西方，这原因也在<a href=\"https://www.sailyang.top/2022/10/01/%E6%9D%8E%E7%BA%A6%E7%91%9F%E4%B9%8B%E8%B0%9C/\">李约瑟之谜</a>中说了，直接原因还是在工业革命上。技术上差距的不断拉大，让残酷的现实一次次摆在了中国人身上。我国儒家文化强调<strong>忠君爱国，以天下为己任</strong>，中国知识分子们由此对国家形成了强烈的责任感。这种责任感表现为两方面：</p>\n<hr>\n<ol>\n<li>一方面，知识分子们有一种让国家重新强盛起来的使命感。</li>\n<li>另一方面，面对一次次战败和欺凌而有无力反抗的屈辱，知识分子们背着巨大的挫折感。</li>\n</ol>\n<hr>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6cffna8clfw0.webp\" alt=\"image\" style=\"zoom: 33%;\" /></div>\n\n<p><strong>复兴中国</strong>是理解近代中国政治、经济和文化的重要线索。</p>\n<blockquote>\n<p>在新崛起文明与古老文明的冲突中，知识分子对于国外文明的反应和理解必然会涉及文明和文化的含义。——《文明的冲突》</p>\n</blockquote>\n<h1 id=\"探索之路\"><a href=\"#探索之路\" class=\"headerlink\" title=\"探索之路\"></a>探索之路</h1><p><strong>何谓文化和文明？</strong></p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.nclq9gqysgw.webp\" alt=\"image\" style=\"zoom: 80%;\" /></div>\n\n<p>马克思认为，<u>经济基础决定上层建筑，两者合一块就是文化体系</u>。</p>\n<p>马林诺夫斯基认为，<u>文化是器物、制度组织和精神伦理价值三者的有机结合</u>。</p>\n<p>有了对文化与文明的认识后，我们来看看先辈们探寻救国之道的思路。</p>\n<h2 id=\"鸦片战争→中学为体，西学为用\"><a href=\"#鸦片战争→中学为体，西学为用\" class=\"headerlink\" title=\"鸦片战争→中学为体，西学为用\"></a>鸦片战争→中学为体，西学为用</h2><div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5xtmxcw7vyw0.webp\" alt=\"汉阳铁厂\" style=\"zoom:60%;\" /></div>\n\n<p>1840的鸦片战争引起了中国知识分子的深沉反思，反思的结果呢，就是<u>俺们大清朝的器物，也就是武器比不上洋人，所以吃了败仗。那么自然而然的，我只要有洋人的洋枪洋炮，大清朝的威严不就回来了</u>？由此，便引发了<strong>洋务运动</strong>，其内容就是”<u>中学为体，西学为用</u>“。</p>\n<p>有一点不能忽视，为什么这个时候不主张全盘西化呢？因为<font color=purple><strong>当时的中国知识分子对自己国家的制度和文化还是很有自信的，认为中国文化的社会组织和价值体系都具有优越性，他们还是把自己看成”天朝上国“</strong>。</font></p>\n<p>洋务运动还是取得了一定的成果，最突出的成就就是三只水师（北洋、南洋和福建水师）的建立。</p>\n<h2 id=\"中日甲午战争→戊戌变法、民主革命\"><a href=\"#中日甲午战争→戊戌变法、民主革命\" class=\"headerlink\" title=\"中日甲午战争→戊戌变法、民主革命\"></a>中日甲午战争→戊戌变法、民主革命</h2><p>日本明治维新后发展特别快，开始对中国的小弟朝鲜虎视眈眈，由此便引发了中日甲午战争。战争开始之前，舆论一边倒向中国，因为中国可是拥有最先进的海军军舰（从西方买的），而日本可买不起这样的军舰。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.74brmnciudw0.webp\" alt=\"中日甲午战争\" style=\"zoom:80%;\" /></div>\n\n<p>但中国还是吃了败仗，根本原因<strong>在于现代化的枪炮有了，可是没有现代军队的组织和纪律，使不出这洋枪洋炮的威力，自然是吃败仗</strong>。这场败仗送走了台湾，知识分子们又开始反思了，小日本同样是被西方欺负，但是三十年间，跟西方学制度，使用君主立宪，废除科举（科举的弊端不在制度而是在考的内容），很快就超过了咱们这天朝上国。</p>\n<p>中国的知识分子由此形成了两种思路：一种是保皇派，主张君主立宪，代表就是维新运动的”戊戌变法“，但最后失败了；第二种是革命派，是以孙中山为代表的海外华侨和留学生，他们<strong>主张美国的制度：总统制，因此必须推翻清政府，建立一个民主制国家</strong>。</p>\n<p>不管是哪派，中国的知识分子们已经反思到制度和社会组织的问题了，其基本思路是一致的，就是要<strong>在中国推行一场社会和政治制度的大变革</strong>。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.175kxk8ocwow.webp\" alt=\"五四革命\" style=\"zoom:80%;\" /></div>\n\n<p>可是还是差一点，这最后一点呢，就是<strong>”五四革命“</strong>。俗话说，五四革命带来了德先生和赛先生，没错，<font color=purple><strong>差的就是现代的精神和价值观”民主“ 和”科学“</strong></font>。</p>\n<h2 id=\"社会主义思潮\"><a href=\"#社会主义思潮\" class=\"headerlink\" title=\"社会主义思潮\"></a>社会主义思潮</h2><p>经过上面这么一个思想的渐进变化过程，从器物→制度→现代精神，中国的知识分子分为了两派：<strong>主张全盘西化</strong>和<strong>社会主义</strong>。</p>\n<p>那么，为什么社会主义思潮会盛行呢？</p>\n<p>首先要明白，中国人虽然不得不向洋人低头，但是内心是不愿屈服的，俗话说争口气。如果有这样一种制度，比西方洋人的制度还优越，那么就会很有市场。当时西方还处于资本主义早期，资本家和工人的矛盾是很大的，冲突频发，由此诞生了马克思主义。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6doc15b96kw0.webp\" alt=\"image\" style=\"zoom:60%;\" /></div>\n\n<p>当时中国流行一句话，”<u>毕其功于一役</u>“，什么意思呢？<strong>就是主张共产主义，越过资本主义这一发展阶段</strong>，这在孙中山的三民主义里有体现，所谓的民生主义就是共产主义。除此之外呢，俄国建立了全世界第一个社会主义政权，还取消了对中国的不平等条约，这虽是顺水人情（俄国当时搞不过西方国家，在华利益本来就不保），但可让中国感激涕零，起到了很大的鼓舞作用，<strong>这也是为什么孙中山开始联俄联共了</strong>。</p>\n<h1 id=\"社会主义革命道路的探索\"><a href=\"#社会主义革命道路的探索\" class=\"headerlink\" title=\"社会主义革命道路的探索\"></a>社会主义革命道路的探索</h1><p>马克思列宁主义为中国共产党的建立奠定了基础，但是社会主义运动在中国的开展还是要经历一系列思想和认知问题的探究的。</p>\n<h2 id=\"马克思主义与列宁主义的区别\"><a href=\"#马克思主义与列宁主义的区别\" class=\"headerlink\" title=\"马克思主义与列宁主义的区别\"></a>马克思主义与列宁主义的区别</h2><p>按照马克思的历史唯物主义，社会主义革命只在资本家与工人阶级的矛盾积累到一定程度才爆发。因为工人社会资源稀少，势单力薄，所以需要积少成多，联合工人阶级，而且一个国家还不够，因为一个国家的工人暴动，周边国家的资本家为了自保，肯定会帮助这个国家镇压，所以<strong>需要在发达资本主义国家同时发生社会主义革命，革命才会成功</strong>。</p>\n<p>列宁主张<strong>社会主义革命可以在单一国家发生，而且不一定是发达资本主义国家</strong>，但前提是<u>必须有一个由社会精英组成的共产党来领导这场革命</u>。以这些精英为核心。团结无产阶级大众，就能取代革命的成功。事实上，列宁确实做到了，俄国真的推翻了沙皇的统治。</p>\n<h2 id=\"列宁主义为何在中国行不通\"><a href=\"#列宁主义为何在中国行不通\" class=\"headerlink\" title=\"列宁主义为何在中国行不通\"></a>列宁主义为何在中国行不通</h2><p>俄国的模式是列宁主义模式，先成立一个共产党，然后发动城市暴动，由此推翻沙皇，建立了苏联。可是呢，这在中国却行不通，早期的中共的确是这么干的，可是屡战屡败。这是为什么呢？</p>\n<p>简单说就是环境不同，没有因地制宜，那具体是环境上哪不同呢？</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2w7ld2ikoh40.webp\" alt=\"发生在租界的五卅运动\" style=\"zoom:80%;\" /></div>\n\n<p><strong>在俄国，工业集中在城市，主要是贵族拥有；而在中国，工业集中在租界，为外国人所有，跟中国政府关系不是很大</strong>。在俄国沙皇时代，沙皇去镇压工人暴动，社会的矛盾指向的是沙皇的政府，人们认为是沙皇的政府在庇佑资本家去剥削底层人民；在中国的租界里，不是中国政府在剥削中国人民，而是洋人资本家在用自己政府的武力镇压，那么矛头对的不是中国政府（蒋介石政府），而是洋人。蒋介石渔翁得利，还得了人心。</p>\n<p>列宁主义在中国的失败告诉我们，外国的理论不能照搬照抄，前提发生了变化，理论产生的效果可能大不相同。<font color=purple><strong>理论不是真理，理论是一种假说，只在特定条件下才能得以应用和实现</strong></font>。</p>\n<h2 id=\"农村包围城市战略的成功\"><a href=\"#农村包围城市战略的成功\" class=\"headerlink\" title=\"农村包围城市战略的成功\"></a>农村包围城市战略的成功</h2><p>那马克思主义和列宁主义怎么改造成适合我国国情呢？这就要说到毛主席的农村包围城市了。</p>\n<p>马列主义认为，发动革命的一个前提是<u>社会存在不公平和财富分配严重不均的情况</u>。中国的城市是存在资本家和工人的矛盾，但别忘了，<strong>中国社会更为广大的根基是农民</strong>。中国农村里，分地主、贫农和无地农民，按照50年代刚刚革命成功统计，中国占3%的地址控制了26%的土地，占68%的贫农拥有22%的土地，土地分配的差距是非常大的，<strong>这种分配不均是远远大于城市的</strong>。毛泽东的“打土豪，分田地”显然更符合我国国情，把地主的土地分给农民，农民自然跟着共产党混了。</p>\n<p>农村包围城市战略成功的另一个原因是，<strong>传统社会中，中国政府对农村的控制力是很低的，</strong>为什么呢？因为政府的管理只到县一级，县以下的都靠士绅（地主）管理。农民一暴动，国民党政府就要派兵镇压农民，镇压“打土豪，分田地”运动，这就相当于沙皇政府镇压工人运动。这样矛头自然对准国民党政府，从而使之丧失了执政的合法性与民心。毛主席不得不说真是活学活用理论，他突破了马列主义只依靠最先进的工人阶级这一理论，选择依靠更为广大的农民群众。</p>\n<p>共产党在当时的核心战略是“<strong>团结大多数，打击一小撮</strong>”，<u>这一小撮不是所有的资本家，而是当时以“蒋宋孔陈”为代表的官僚资本</u>，那些收到打压的民族资本家是共产党要团结的。</p>\n<h1 id=\"照搬苏联老大哥的经济措施\"><a href=\"#照搬苏联老大哥的经济措施\" class=\"headerlink\" title=\"照搬苏联老大哥的经济措施\"></a>照搬苏联老大哥的经济措施</h1><h2 id=\"为什么重工业优先？\"><a href=\"#为什么重工业优先？\" class=\"headerlink\" title=\"为什么重工业优先？\"></a>为什么重工业优先？</h2><p>新中国成立后，推行了重工业优先的发展策略，并开始了计划经济体制。这套制度从1950~1978，执行了28年，最后证明确实行不通。那么，<strong>为什么毛泽东在革命时，活学活用马列主义，而在新中国成立后，却照搬苏联的经验来建设新中国呢？</strong>难道是毛主席不懂经济和建设，只懂革命？那显然是错的，因为毛主席不仅没有治国的经验，革命的经验也是没有的😅。</p>\n<p>实际上，照搬苏联经验，也是毛主席实事求是的行为。因为革命时，中国与苏联目标一致，但是环境不一致，所以不能照搬；但是建设新中国时，和苏联的目标一致，环境也是一致的，所以认为可以照搬苏联经验。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.3k1pgjt6f2w0.webp\" alt=\"image\" style=\"zoom:80%;\" /></div>\n\n<p>新中国是脆弱的，要想中国富强，当务之急是需要强大的国防，而强大的国防需要强大的军事工业，而强大的军事工业必须要有强大的重工业打地基。因此，中国选择重工业优先的策略，目的是不再让中国受洋人的欺凌。苏联的经验为中国提供了参照，因为苏联在1929之前，也是一个贫穷的农业国家，但是在斯大林的领导下，工业化非常快，迅速形成了自己的重工业体系和国防体系；而当时的西方国家因为经济大萧条，日子并不好过。这么一对比，自然深入一众发展中国家的心里，包括中国的领导人们。</p>\n<h2 id=\"重工业优先发展与要素禀赋的矛盾\"><a href=\"#重工业优先发展与要素禀赋的矛盾\" class=\"headerlink\" title=\"重工业优先发展与要素禀赋的矛盾\"></a>重工业优先发展与要素禀赋的矛盾</h2><p>重工业有三个基本特性：</p>\n<hr>\n<ol>\n<li>建设周期长：为什么设那么多五年计划啊？就是这个原因。重工业建设周期长；而轻工业可能当年投资，当年投产，当年就能收益。</li>\n<li>如果是贫穷落后的发展中国家，<strong>设备得进口</strong>。</li>\n<li><strong>一次性投入非常大</strong>，几十亿都很常见。</li>\n</ol>\n<hr>\n<p>一个贫穷的农业国也有三个基本特性：</p>\n<hr>\n<ol>\n<li>剩余少：所谓自给自足的小农经济，就是导致剩余少的原因。大部分人是农民，生产活动集中在种地，自己人吃完剩下的产品是很少的，这部分拿到市场去换资金，显然资金是非常少的，这就导致资本的积累不足，资金的价格就非常高。</li>\n<li>可供出口的产品少：出口少，就会导致赚到的外汇少，所以外汇价格（汇率）很很高。</li>\n<li>资金分散，难以集中：说白了就是银行少，拿不到钱，老百姓自己手里就那么点钱，没必要送到银行去。只要钱不进银行，就会有资金动员困难的问题。</li>\n</ol>\n<hr>\n<p>上面这矛盾就很明显了，如果正常情况下民间借贷的月利率是2.5%，年利率就是30%左右。如果一个项目要十年投产，投产之后才能盈利，那么按照年利率30%复利计算，十年之后要还的本息和是原贷款的13.7倍，而要保持这样的高利润，是很稀少的。此外，机器要进口，外汇价格又高，导致<strong>工业建设的成本肯定偏高，资金又难集中</strong>。</p>\n<p>欸嘿，那怎么办呢？苏联当时遇到这个问题，推行的是<u>计划经济体制</u>，把国家的资源集中起来；中国在20年后也遇到了这个问题，而计划经济也确实比较有效于建设重工业，所以呢，俺们就照搬照抄了，属实是实事求是的行为。</p>\n","site":{"data":{}},"more":"<h1 id=\"近代之耻辱\"><a href=\"#近代之耻辱\" class=\"headerlink\" title=\"近代之耻辱\"></a>近代之耻辱</h1><p>对于中国来说，清朝中期到新中国成立之前这一百多年是耻辱的，中国丢掉了尊严，打仗打不赢，不是割地就是赔款。作为曾经的世界老大混成这鸟样，领导班子肯定得负责，但我们也不能全怪清政府，教科书上总写着是因为清政府的腐败无能，所以才导致中国堕落到如此地步，但事实可能并不与之相符。</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5zm15vf1sxg0.webp\" alt=\"不平等条约\"></p>\n<p>清朝历史上其实并没有出现过让老百姓没日子过的主子，民间的反清势力也并不是因为日子过不下去了才造反的，纯粹是出于民族情结；至于腐败贪污，试问哪个朝代没有。所以呢，将中国积弱的责任一股脑扣在清朝统治者的头上，那还真是不太公平。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.ahmj3nz8juw.webp\" alt=\"image\" style=\"zoom:47%;\" />\n</div>\n\n\n<p>中国之所以落后于西方，这原因也在<a href=\"https://www.sailyang.top/2022/10/01/%E6%9D%8E%E7%BA%A6%E7%91%9F%E4%B9%8B%E8%B0%9C/\">李约瑟之谜</a>中说了，直接原因还是在工业革命上。技术上差距的不断拉大，让残酷的现实一次次摆在了中国人身上。我国儒家文化强调<strong>忠君爱国，以天下为己任</strong>，中国知识分子们由此对国家形成了强烈的责任感。这种责任感表现为两方面：</p>\n<hr>\n<ol>\n<li>一方面，知识分子们有一种让国家重新强盛起来的使命感。</li>\n<li>另一方面，面对一次次战败和欺凌而有无力反抗的屈辱，知识分子们背着巨大的挫折感。</li>\n</ol>\n<hr>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6cffna8clfw0.webp\" alt=\"image\" style=\"zoom: 33%;\" /></div>\n\n<p><strong>复兴中国</strong>是理解近代中国政治、经济和文化的重要线索。</p>\n<blockquote>\n<p>在新崛起文明与古老文明的冲突中，知识分子对于国外文明的反应和理解必然会涉及文明和文化的含义。——《文明的冲突》</p>\n</blockquote>\n<h1 id=\"探索之路\"><a href=\"#探索之路\" class=\"headerlink\" title=\"探索之路\"></a>探索之路</h1><p><strong>何谓文化和文明？</strong></p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.nclq9gqysgw.webp\" alt=\"image\" style=\"zoom: 80%;\" /></div>\n\n<p>马克思认为，<u>经济基础决定上层建筑，两者合一块就是文化体系</u>。</p>\n<p>马林诺夫斯基认为，<u>文化是器物、制度组织和精神伦理价值三者的有机结合</u>。</p>\n<p>有了对文化与文明的认识后，我们来看看先辈们探寻救国之道的思路。</p>\n<h2 id=\"鸦片战争→中学为体，西学为用\"><a href=\"#鸦片战争→中学为体，西学为用\" class=\"headerlink\" title=\"鸦片战争→中学为体，西学为用\"></a>鸦片战争→中学为体，西学为用</h2><div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5xtmxcw7vyw0.webp\" alt=\"汉阳铁厂\" style=\"zoom:60%;\" /></div>\n\n<p>1840的鸦片战争引起了中国知识分子的深沉反思，反思的结果呢，就是<u>俺们大清朝的器物，也就是武器比不上洋人，所以吃了败仗。那么自然而然的，我只要有洋人的洋枪洋炮，大清朝的威严不就回来了</u>？由此，便引发了<strong>洋务运动</strong>，其内容就是”<u>中学为体，西学为用</u>“。</p>\n<p>有一点不能忽视，为什么这个时候不主张全盘西化呢？因为<font color=purple><strong>当时的中国知识分子对自己国家的制度和文化还是很有自信的，认为中国文化的社会组织和价值体系都具有优越性，他们还是把自己看成”天朝上国“</strong>。</font></p>\n<p>洋务运动还是取得了一定的成果，最突出的成就就是三只水师（北洋、南洋和福建水师）的建立。</p>\n<h2 id=\"中日甲午战争→戊戌变法、民主革命\"><a href=\"#中日甲午战争→戊戌变法、民主革命\" class=\"headerlink\" title=\"中日甲午战争→戊戌变法、民主革命\"></a>中日甲午战争→戊戌变法、民主革命</h2><p>日本明治维新后发展特别快，开始对中国的小弟朝鲜虎视眈眈，由此便引发了中日甲午战争。战争开始之前，舆论一边倒向中国，因为中国可是拥有最先进的海军军舰（从西方买的），而日本可买不起这样的军舰。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.74brmnciudw0.webp\" alt=\"中日甲午战争\" style=\"zoom:80%;\" /></div>\n\n<p>但中国还是吃了败仗，根本原因<strong>在于现代化的枪炮有了，可是没有现代军队的组织和纪律，使不出这洋枪洋炮的威力，自然是吃败仗</strong>。这场败仗送走了台湾，知识分子们又开始反思了，小日本同样是被西方欺负，但是三十年间，跟西方学制度，使用君主立宪，废除科举（科举的弊端不在制度而是在考的内容），很快就超过了咱们这天朝上国。</p>\n<p>中国的知识分子由此形成了两种思路：一种是保皇派，主张君主立宪，代表就是维新运动的”戊戌变法“，但最后失败了；第二种是革命派，是以孙中山为代表的海外华侨和留学生，他们<strong>主张美国的制度：总统制，因此必须推翻清政府，建立一个民主制国家</strong>。</p>\n<p>不管是哪派，中国的知识分子们已经反思到制度和社会组织的问题了，其基本思路是一致的，就是要<strong>在中国推行一场社会和政治制度的大变革</strong>。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.175kxk8ocwow.webp\" alt=\"五四革命\" style=\"zoom:80%;\" /></div>\n\n<p>可是还是差一点，这最后一点呢，就是<strong>”五四革命“</strong>。俗话说，五四革命带来了德先生和赛先生，没错，<font color=purple><strong>差的就是现代的精神和价值观”民主“ 和”科学“</strong></font>。</p>\n<h2 id=\"社会主义思潮\"><a href=\"#社会主义思潮\" class=\"headerlink\" title=\"社会主义思潮\"></a>社会主义思潮</h2><p>经过上面这么一个思想的渐进变化过程，从器物→制度→现代精神，中国的知识分子分为了两派：<strong>主张全盘西化</strong>和<strong>社会主义</strong>。</p>\n<p>那么，为什么社会主义思潮会盛行呢？</p>\n<p>首先要明白，中国人虽然不得不向洋人低头，但是内心是不愿屈服的，俗话说争口气。如果有这样一种制度，比西方洋人的制度还优越，那么就会很有市场。当时西方还处于资本主义早期，资本家和工人的矛盾是很大的，冲突频发，由此诞生了马克思主义。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6doc15b96kw0.webp\" alt=\"image\" style=\"zoom:60%;\" /></div>\n\n<p>当时中国流行一句话，”<u>毕其功于一役</u>“，什么意思呢？<strong>就是主张共产主义，越过资本主义这一发展阶段</strong>，这在孙中山的三民主义里有体现，所谓的民生主义就是共产主义。除此之外呢，俄国建立了全世界第一个社会主义政权，还取消了对中国的不平等条约，这虽是顺水人情（俄国当时搞不过西方国家，在华利益本来就不保），但可让中国感激涕零，起到了很大的鼓舞作用，<strong>这也是为什么孙中山开始联俄联共了</strong>。</p>\n<h1 id=\"社会主义革命道路的探索\"><a href=\"#社会主义革命道路的探索\" class=\"headerlink\" title=\"社会主义革命道路的探索\"></a>社会主义革命道路的探索</h1><p>马克思列宁主义为中国共产党的建立奠定了基础，但是社会主义运动在中国的开展还是要经历一系列思想和认知问题的探究的。</p>\n<h2 id=\"马克思主义与列宁主义的区别\"><a href=\"#马克思主义与列宁主义的区别\" class=\"headerlink\" title=\"马克思主义与列宁主义的区别\"></a>马克思主义与列宁主义的区别</h2><p>按照马克思的历史唯物主义，社会主义革命只在资本家与工人阶级的矛盾积累到一定程度才爆发。因为工人社会资源稀少，势单力薄，所以需要积少成多，联合工人阶级，而且一个国家还不够，因为一个国家的工人暴动，周边国家的资本家为了自保，肯定会帮助这个国家镇压，所以<strong>需要在发达资本主义国家同时发生社会主义革命，革命才会成功</strong>。</p>\n<p>列宁主张<strong>社会主义革命可以在单一国家发生，而且不一定是发达资本主义国家</strong>，但前提是<u>必须有一个由社会精英组成的共产党来领导这场革命</u>。以这些精英为核心。团结无产阶级大众，就能取代革命的成功。事实上，列宁确实做到了，俄国真的推翻了沙皇的统治。</p>\n<h2 id=\"列宁主义为何在中国行不通\"><a href=\"#列宁主义为何在中国行不通\" class=\"headerlink\" title=\"列宁主义为何在中国行不通\"></a>列宁主义为何在中国行不通</h2><p>俄国的模式是列宁主义模式，先成立一个共产党，然后发动城市暴动，由此推翻沙皇，建立了苏联。可是呢，这在中国却行不通，早期的中共的确是这么干的，可是屡战屡败。这是为什么呢？</p>\n<p>简单说就是环境不同，没有因地制宜，那具体是环境上哪不同呢？</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2w7ld2ikoh40.webp\" alt=\"发生在租界的五卅运动\" style=\"zoom:80%;\" /></div>\n\n<p><strong>在俄国，工业集中在城市，主要是贵族拥有；而在中国，工业集中在租界，为外国人所有，跟中国政府关系不是很大</strong>。在俄国沙皇时代，沙皇去镇压工人暴动，社会的矛盾指向的是沙皇的政府，人们认为是沙皇的政府在庇佑资本家去剥削底层人民；在中国的租界里，不是中国政府在剥削中国人民，而是洋人资本家在用自己政府的武力镇压，那么矛头对的不是中国政府（蒋介石政府），而是洋人。蒋介石渔翁得利，还得了人心。</p>\n<p>列宁主义在中国的失败告诉我们，外国的理论不能照搬照抄，前提发生了变化，理论产生的效果可能大不相同。<font color=purple><strong>理论不是真理，理论是一种假说，只在特定条件下才能得以应用和实现</strong></font>。</p>\n<h2 id=\"农村包围城市战略的成功\"><a href=\"#农村包围城市战略的成功\" class=\"headerlink\" title=\"农村包围城市战略的成功\"></a>农村包围城市战略的成功</h2><p>那马克思主义和列宁主义怎么改造成适合我国国情呢？这就要说到毛主席的农村包围城市了。</p>\n<p>马列主义认为，发动革命的一个前提是<u>社会存在不公平和财富分配严重不均的情况</u>。中国的城市是存在资本家和工人的矛盾，但别忘了，<strong>中国社会更为广大的根基是农民</strong>。中国农村里，分地主、贫农和无地农民，按照50年代刚刚革命成功统计，中国占3%的地址控制了26%的土地，占68%的贫农拥有22%的土地，土地分配的差距是非常大的，<strong>这种分配不均是远远大于城市的</strong>。毛泽东的“打土豪，分田地”显然更符合我国国情，把地主的土地分给农民，农民自然跟着共产党混了。</p>\n<p>农村包围城市战略成功的另一个原因是，<strong>传统社会中，中国政府对农村的控制力是很低的，</strong>为什么呢？因为政府的管理只到县一级，县以下的都靠士绅（地主）管理。农民一暴动，国民党政府就要派兵镇压农民，镇压“打土豪，分田地”运动，这就相当于沙皇政府镇压工人运动。这样矛头自然对准国民党政府，从而使之丧失了执政的合法性与民心。毛主席不得不说真是活学活用理论，他突破了马列主义只依靠最先进的工人阶级这一理论，选择依靠更为广大的农民群众。</p>\n<p>共产党在当时的核心战略是“<strong>团结大多数，打击一小撮</strong>”，<u>这一小撮不是所有的资本家，而是当时以“蒋宋孔陈”为代表的官僚资本</u>，那些收到打压的民族资本家是共产党要团结的。</p>\n<h1 id=\"照搬苏联老大哥的经济措施\"><a href=\"#照搬苏联老大哥的经济措施\" class=\"headerlink\" title=\"照搬苏联老大哥的经济措施\"></a>照搬苏联老大哥的经济措施</h1><h2 id=\"为什么重工业优先？\"><a href=\"#为什么重工业优先？\" class=\"headerlink\" title=\"为什么重工业优先？\"></a>为什么重工业优先？</h2><p>新中国成立后，推行了重工业优先的发展策略，并开始了计划经济体制。这套制度从1950~1978，执行了28年，最后证明确实行不通。那么，<strong>为什么毛泽东在革命时，活学活用马列主义，而在新中国成立后，却照搬苏联的经验来建设新中国呢？</strong>难道是毛主席不懂经济和建设，只懂革命？那显然是错的，因为毛主席不仅没有治国的经验，革命的经验也是没有的😅。</p>\n<p>实际上，照搬苏联经验，也是毛主席实事求是的行为。因为革命时，中国与苏联目标一致，但是环境不一致，所以不能照搬；但是建设新中国时，和苏联的目标一致，环境也是一致的，所以认为可以照搬苏联经验。</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.3k1pgjt6f2w0.webp\" alt=\"image\" style=\"zoom:80%;\" /></div>\n\n<p>新中国是脆弱的，要想中国富强，当务之急是需要强大的国防，而强大的国防需要强大的军事工业，而强大的军事工业必须要有强大的重工业打地基。因此，中国选择重工业优先的策略，目的是不再让中国受洋人的欺凌。苏联的经验为中国提供了参照，因为苏联在1929之前，也是一个贫穷的农业国家，但是在斯大林的领导下，工业化非常快，迅速形成了自己的重工业体系和国防体系；而当时的西方国家因为经济大萧条，日子并不好过。这么一对比，自然深入一众发展中国家的心里，包括中国的领导人们。</p>\n<h2 id=\"重工业优先发展与要素禀赋的矛盾\"><a href=\"#重工业优先发展与要素禀赋的矛盾\" class=\"headerlink\" title=\"重工业优先发展与要素禀赋的矛盾\"></a>重工业优先发展与要素禀赋的矛盾</h2><p>重工业有三个基本特性：</p>\n<hr>\n<ol>\n<li>建设周期长：为什么设那么多五年计划啊？就是这个原因。重工业建设周期长；而轻工业可能当年投资，当年投产，当年就能收益。</li>\n<li>如果是贫穷落后的发展中国家，<strong>设备得进口</strong>。</li>\n<li><strong>一次性投入非常大</strong>，几十亿都很常见。</li>\n</ol>\n<hr>\n<p>一个贫穷的农业国也有三个基本特性：</p>\n<hr>\n<ol>\n<li>剩余少：所谓自给自足的小农经济，就是导致剩余少的原因。大部分人是农民，生产活动集中在种地，自己人吃完剩下的产品是很少的，这部分拿到市场去换资金，显然资金是非常少的，这就导致资本的积累不足，资金的价格就非常高。</li>\n<li>可供出口的产品少：出口少，就会导致赚到的外汇少，所以外汇价格（汇率）很很高。</li>\n<li>资金分散，难以集中：说白了就是银行少，拿不到钱，老百姓自己手里就那么点钱，没必要送到银行去。只要钱不进银行，就会有资金动员困难的问题。</li>\n</ol>\n<hr>\n<p>上面这矛盾就很明显了，如果正常情况下民间借贷的月利率是2.5%，年利率就是30%左右。如果一个项目要十年投产，投产之后才能盈利，那么按照年利率30%复利计算，十年之后要还的本息和是原贷款的13.7倍，而要保持这样的高利润，是很稀少的。此外，机器要进口，外汇价格又高，导致<strong>工业建设的成本肯定偏高，资金又难集中</strong>。</p>\n<p>欸嘿，那怎么办呢？苏联当时遇到这个问题，推行的是<u>计划经济体制</u>，把国家的资源集中起来；中国在20年后也遇到了这个问题，而计划经济也确实比较有效于建设重工业，所以呢，俺们就照搬照抄了，属实是实事求是的行为。</p>\n"},{"title":"BitTorrent协议简介","date":"2022-10-09T00:55:26.000Z","banner_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2rrho9v2cfa0.webp","index_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2rrho9v2cfa0.webp","excerpt":"对BitTorrent协议的简介","_content":"\n最近经常会下载一些电影，都是通过一个torrent文件+迅雷下载的，这个torrent文件被称为BT种子，说实话这个名字非常熟悉，中学时经常会听到朋友说起，比如有没有种子什么的😅，但是我一直不太了解这种下载方式。这几天使用这种方式下载的时候，发现和一般通过http协议下载的方式有很大不同，于是我就不禁好奇起来，这种下载方式是如何工作的呢？\n# 概念介绍\n这种下载方式依托于[BitTorrent](https://en.wikipedia.org/wiki/BitTorrent)协议，BitTorrent是一种internet transfer protocol，同样作为一种transfer protocol，BitTorrent与http,ftp(file transfer protocol)这些协议最大的不同在于**BitTorrent是一种distributed transfer protocol（分布式传输协议），什么意思呢**？\nhttp/FTP protocol都是让用户从一个目标站点的服务器上下载文件，而当用户过多时，就会超出服务器的带宽限制，导致下载出现问题；而BitTorrent将文件分片，每个用户都会下载文件的分片，在下载时也会将自己的文件分片发给其他正在下载的用户，这就形成了一种**图结构**，**点对点式**（[Peer-to-peer](https://en.wikipedia.org/wiki/Peer-to-peer)）的分发文件分片： \n\n![P2P结构](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5dixodre9sk0.webp)\n\n正是由于这一特性，BitTorrent在大文件下载和多人同时下载时有非常好的表现。\n\n# Torrent文件\ntorrent文件，也就是所谓的BT种子，是我们了解这种下载方式的关键，所以下面就来简单介绍一下这种文件的格式与结构。\n## 编码方式：bencoding\ntorrent文件的编码格式是bencoding,这种编码由ASCII码进行编码，包含以下数据结构：\n\n| **string** | 字符串\"hello\"在bencoding中就是5:hello，即长度标识+:+字符串 |\n| --- | --- |\n| **integer** | i开头,e结尾，比如123就可以用i123e表示，456用i456e表示 |\n| **List** | l开头,e结尾，比如[132,\"hello\"]就表示为li123e5:helloe |\n| **Dictionary** | d开头,e结尾，key必须是string,value可以是四种数据结构的任意一种，比如{'fruit':5,'meat':8}就可表示为d5:fruiti5e4:meati8ee。除此之外，还要注意，Dictionary必须是有序字典，所有key必须按[字典序](https://zh.m.wikipedia.org/wiki/%E5%AD%97%E5%85%B8%E5%BA%8F)升序排列。 |\n\n虽然Bencoding比用纯二进制编码效率低，但由于结构简单而且不受字节存储顺序影响（所有数字以十进制编码，不存在[大端小端的问题](http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F)），因此具有很好的跨平台性，而且具有较好的灵活性，即使存在故障的字典键，只要将其忽略并更换新的就能兼容补充。\n## 文件格式\ntorrent文件本身是一个字典，类似于Json,里面包含了一些key，那么具体包含哪些key呢？首先我们直接打开一个torrent文件:\n\n![torrent文件](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5efiz2romt40.webp)\n\n可以看到除了第一行以外，全都是乱码，说明这是一个二进制文件。我们现在已经知道了torrent文件是用Bencoding方式编码的，通过解析器(留个坑)，就可以将其转化为可读的格式:\n\n```cpp\n{\n    \"announce\": \"udp://engplus.ru:6969/announce\",\n    \"announce-list\": [\n        [\n            \"udp://engplus.ru:6969/announce\"\n        ],\n        [\n            \"udp://cutiegirl.ru:6969/announce\"\n        ],\n        [\n            \"udp://bubu.mapfactor.com:6969/announce\"\n        ],\n        [\n            \"udp://bt2.archive.org:6969/announce\"\n        ]\n    ],\n    \"created by\": \"qBittorrent v4.3.91\",\n    \"creation date\": \"2021-02-12 03:02:32\",\n    \"info_hash\": \"7cda8188321724d1ce7a0ab0b4f9208023dd1521\",\n    \"info\": {\n        \"length\": 4936930690,\n        \"path\": [\"BT\\u4e16\\u754c\\u7f51(btsj5.com).txt\"],\n        \"name\": \"\\u91dc\\u5c71\\u884c.\\u7279\\u6548\\u5b57\\u5e55.2016.BD1080P.AAC.x264.CHS.BTSJ5\",\n        \"piece length\": 1048576,\n        \"pieces\": [\n            \"10e72eba2cbdc9d9b9791706fcbfb84e51093c86\",\n            \"d91472ddd5e943caa54f8520fcb35fb106033cf2\",\n            \"214e6470e412215c9cf462ea752adc6a7c90e92f\",\n            \"214e6470e412215c9cf462ea752adc6a7c90e92f\",\n            \"903012943eab4ed903f1bc35079f6075f01da4ff\",\n            \"d118c6af14e0f3e06f8008e712322d06088d9c05\",\n            \"500813dd3b29e0c88e0127a2fdf7851be2472a58\",\n            \"…………\"\n        ]\n    }\n}\n```\n从上面我们可以看出一些torrent的字段，下面进行一个汇总：\n\n<img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1rwj23d240ww.webp\" alt=\"torrent字段\" style=\"zoom:80%;\"  align=\"center\"/>\n\n# BT下载流程\n## 简单概述\n整个的一个BT下载流程是怎样的呢？\n\n1. 制作Torrent种子文件，制作的过程中要指定发布的文件or文件夹、Tracker URL（即announce字段）、是否启用DHT等等。除此之外，还要将要发布的文件切成块（一般是256KB），用SHA1哈希算法计算每块的哈希值，最后上传到Tracker服务器。\n2. BT客户端（如迅雷）得到.torrent文件后，就会根据文件中的announce字段找到Tracker服务器地址（连接方式有UDP也有HTTP），然后客户端就会通过Tracker GET请求得到服务，发送哈希值给Tracker，让其查找。\n3. 在找到哈希信息后，Tracker服务器就会反连客户端的IP地址和Port（如果是公网），然后返回正在下载这个文件的所有公网用户的IP地址和Port List,之后会将这个客户端的IP地址和Port保存下来，供其他人使用。\n4. BT客户端得到这些其他用户IP后，就可以直接连接到这些IP和端口下载资料了。BT客户端会到所有的用户去寻找自己要下载的东西。BT客户端每找到一个用户就建立一个Socket来下载，所以下载的人越多，速度就越快。\n## peer之间的通信\n下面来看一下点与点之间是如何建立连接的。在使用BT协议下载时，所有正在下载同一资源的peer都是对等的，两个peer之间相互建立的连接也是对等的，对等节点建立的连接的数据传输方向也是双向的，数据可由任何一端发送到另一端。\n首先是TCP层的连接，当一个客户端向其他peer发送一个TCP连接请求，这个请求由以下字段组成：\n> 1. pstrlen,固定值为19B\n> 2. pstr,值为\"BitTorrent protocol\"\n> 3. reserved，保留8字节字段，一般全设置为0、\n> 4. info_hash，必须与请求Tracker时发送的info_hash相同\n> 5. peer_id，必须与请求Tracker时发送的peer_id相同\n\n在发送上述握手后，应该会受到相同格式的握手，然后我们就将返回的info_hash和发送的进行匹配，以此来确定是否是同一文件，若没问题，那么就握手成功。握手成功后，就会进行**数据的传输**：\n\n---\n\n1. 提供数据的peer会对下载者发送Bitfield，告诉自己拥有的这个文件的哪些块，这些信息就用Bitfield存储（一个二进制bit数组，数组值为1就表示有这个块）。\n2. 初始化状态下，BT客户端对其他的peer都是**choked状态**（阻断）。当下载者准备好了，就会发送**Unchoked消息**，可以进行消息传输。\n3. 下载者发送Interested消息，告诉提供数据的peer自己要开始下载了。\n4. 下载者发送Request消息，其中Payload包含具体的某个块的信息（序号，begin,length）。\n5. 提供数据的peer向下载者发送Piece，即真正的块数据。\n---\n\n# DHT网络和磁力链接\n## DHT网络\n通过上面对BitTorrent的简单介绍，我们发现BT十分依赖于Tracker服务器，如果Tracker服务器全挂彩了，那么BT也就没用了，也没有办法解决这个问题呢？\nDHT，即**全称分布式哈希表**(Distributed Hash Table)可以有效地解决这个问题，其示意图如下：\n\n![DHT](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.569wnzvy9ss0.webp)\n\nDHT是一种分布式存储方法，在不需要服务器的情况下，每个节点负责一个小范围的路由，并负责存储一小部分数据，从而实现整个DHT网络的寻址和存储。在DHT网络中，每一个peer都是一个Node，有自己的哈希值。每个Node即是上传和下载piece的BT下载节点；也是**一个小型Tracker，其会保留自己附近的一部分节点信息**。\n\n实现DHT的一种算法：[Khashmir](https://www.tribler.org/Khashmir/)，简单介绍一下：\nDHT的每个节点都保存了一张表，上面记录着自己周围节点的ID，当我们向节点A查询B的信息时，就会检索A的表看看有没有B，有就返回B的信息；**没有就返回距离B最近（用XOR计算)的k个节点，然后继续向着k个节点寻找B**。\n\n## 磁力链接\n2009年，作为世界第一Tracker服务商海盗湾，关闭了Tracker服务器，因为涉及侵权问题，随后基于DHT网络的**磁力链接**（Magnet URI scheme）就走上了主流舞台，目前已经成为最流行的下载方式。\n例如有这样一串链接：`magnet:?xt=urn:btih:53SWOUDWKG6ORSKTJHHE3QXTIBOGU5WU`\n\n- magnet是协议名，xt是资源定位点，urn:btih是Hash方法\n- 后面的一串40位16进制数是本文件内容的Hash值，BT下载客户端就是根据这个Hash值在DHT中定位下载文件。\n# 参考资料\n\n[1] [BitTorrent 简介](https://blog.csdn.net/riba2534/article/details/115602512?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165154457716781685369761%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165154457716781685369761&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115602512.142%5Ev9%5Epc_search_result_control_group,157%5Ev4%5Econtrol&utm_term=BitTorrent&spm=1018.2226.3001.4187)\n\n[2] [https://en.wikipedia.org/wiki/BitTorrent#Design](https://en.wikipedia.org/wiki/BitTorrent#Design)\n\n[3] [磁力链接 - 维基百科，自由的百科全书](https://zh.m.wikipedia.org/wiki/%E7%A3%81%E5%8A%9B%E9%93%BE%E6%8E%A5)\n\n[4] [XIU2/TrackersListCollection](https://trackerslist.com/#/zh)\n\n# 小结\n本章内容主要用于总结一些BitTorrent协议和DHT协议的相关知识，由于还未深入学习计算机网络，一些细节的了解还不是很到位，等我到时候学了计算机网络再来深入学习一下😄，这里先留个坑。\n","source":"_posts/BitTorrent协议.md","raw":"---\ntitle: BitTorrent协议简介\ndate: 2022-10-09 08:55:26\ntags:\n - P2P\ncategories:\n- 计算机网络\n- 分布式\nbanner_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2rrho9v2cfa0.webp\nindex_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2rrho9v2cfa0.webp\nexcerpt:  对BitTorrent协议的简介\n---\n\n最近经常会下载一些电影，都是通过一个torrent文件+迅雷下载的，这个torrent文件被称为BT种子，说实话这个名字非常熟悉，中学时经常会听到朋友说起，比如有没有种子什么的😅，但是我一直不太了解这种下载方式。这几天使用这种方式下载的时候，发现和一般通过http协议下载的方式有很大不同，于是我就不禁好奇起来，这种下载方式是如何工作的呢？\n# 概念介绍\n这种下载方式依托于[BitTorrent](https://en.wikipedia.org/wiki/BitTorrent)协议，BitTorrent是一种internet transfer protocol，同样作为一种transfer protocol，BitTorrent与http,ftp(file transfer protocol)这些协议最大的不同在于**BitTorrent是一种distributed transfer protocol（分布式传输协议），什么意思呢**？\nhttp/FTP protocol都是让用户从一个目标站点的服务器上下载文件，而当用户过多时，就会超出服务器的带宽限制，导致下载出现问题；而BitTorrent将文件分片，每个用户都会下载文件的分片，在下载时也会将自己的文件分片发给其他正在下载的用户，这就形成了一种**图结构**，**点对点式**（[Peer-to-peer](https://en.wikipedia.org/wiki/Peer-to-peer)）的分发文件分片： \n\n![P2P结构](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5dixodre9sk0.webp)\n\n正是由于这一特性，BitTorrent在大文件下载和多人同时下载时有非常好的表现。\n\n# Torrent文件\ntorrent文件，也就是所谓的BT种子，是我们了解这种下载方式的关键，所以下面就来简单介绍一下这种文件的格式与结构。\n## 编码方式：bencoding\ntorrent文件的编码格式是bencoding,这种编码由ASCII码进行编码，包含以下数据结构：\n\n| **string** | 字符串\"hello\"在bencoding中就是5:hello，即长度标识+:+字符串 |\n| --- | --- |\n| **integer** | i开头,e结尾，比如123就可以用i123e表示，456用i456e表示 |\n| **List** | l开头,e结尾，比如[132,\"hello\"]就表示为li123e5:helloe |\n| **Dictionary** | d开头,e结尾，key必须是string,value可以是四种数据结构的任意一种，比如{'fruit':5,'meat':8}就可表示为d5:fruiti5e4:meati8ee。除此之外，还要注意，Dictionary必须是有序字典，所有key必须按[字典序](https://zh.m.wikipedia.org/wiki/%E5%AD%97%E5%85%B8%E5%BA%8F)升序排列。 |\n\n虽然Bencoding比用纯二进制编码效率低，但由于结构简单而且不受字节存储顺序影响（所有数字以十进制编码，不存在[大端小端的问题](http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F)），因此具有很好的跨平台性，而且具有较好的灵活性，即使存在故障的字典键，只要将其忽略并更换新的就能兼容补充。\n## 文件格式\ntorrent文件本身是一个字典，类似于Json,里面包含了一些key，那么具体包含哪些key呢？首先我们直接打开一个torrent文件:\n\n![torrent文件](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5efiz2romt40.webp)\n\n可以看到除了第一行以外，全都是乱码，说明这是一个二进制文件。我们现在已经知道了torrent文件是用Bencoding方式编码的，通过解析器(留个坑)，就可以将其转化为可读的格式:\n\n```cpp\n{\n    \"announce\": \"udp://engplus.ru:6969/announce\",\n    \"announce-list\": [\n        [\n            \"udp://engplus.ru:6969/announce\"\n        ],\n        [\n            \"udp://cutiegirl.ru:6969/announce\"\n        ],\n        [\n            \"udp://bubu.mapfactor.com:6969/announce\"\n        ],\n        [\n            \"udp://bt2.archive.org:6969/announce\"\n        ]\n    ],\n    \"created by\": \"qBittorrent v4.3.91\",\n    \"creation date\": \"2021-02-12 03:02:32\",\n    \"info_hash\": \"7cda8188321724d1ce7a0ab0b4f9208023dd1521\",\n    \"info\": {\n        \"length\": 4936930690,\n        \"path\": [\"BT\\u4e16\\u754c\\u7f51(btsj5.com).txt\"],\n        \"name\": \"\\u91dc\\u5c71\\u884c.\\u7279\\u6548\\u5b57\\u5e55.2016.BD1080P.AAC.x264.CHS.BTSJ5\",\n        \"piece length\": 1048576,\n        \"pieces\": [\n            \"10e72eba2cbdc9d9b9791706fcbfb84e51093c86\",\n            \"d91472ddd5e943caa54f8520fcb35fb106033cf2\",\n            \"214e6470e412215c9cf462ea752adc6a7c90e92f\",\n            \"214e6470e412215c9cf462ea752adc6a7c90e92f\",\n            \"903012943eab4ed903f1bc35079f6075f01da4ff\",\n            \"d118c6af14e0f3e06f8008e712322d06088d9c05\",\n            \"500813dd3b29e0c88e0127a2fdf7851be2472a58\",\n            \"…………\"\n        ]\n    }\n}\n```\n从上面我们可以看出一些torrent的字段，下面进行一个汇总：\n\n<img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1rwj23d240ww.webp\" alt=\"torrent字段\" style=\"zoom:80%;\"  align=\"center\"/>\n\n# BT下载流程\n## 简单概述\n整个的一个BT下载流程是怎样的呢？\n\n1. 制作Torrent种子文件，制作的过程中要指定发布的文件or文件夹、Tracker URL（即announce字段）、是否启用DHT等等。除此之外，还要将要发布的文件切成块（一般是256KB），用SHA1哈希算法计算每块的哈希值，最后上传到Tracker服务器。\n2. BT客户端（如迅雷）得到.torrent文件后，就会根据文件中的announce字段找到Tracker服务器地址（连接方式有UDP也有HTTP），然后客户端就会通过Tracker GET请求得到服务，发送哈希值给Tracker，让其查找。\n3. 在找到哈希信息后，Tracker服务器就会反连客户端的IP地址和Port（如果是公网），然后返回正在下载这个文件的所有公网用户的IP地址和Port List,之后会将这个客户端的IP地址和Port保存下来，供其他人使用。\n4. BT客户端得到这些其他用户IP后，就可以直接连接到这些IP和端口下载资料了。BT客户端会到所有的用户去寻找自己要下载的东西。BT客户端每找到一个用户就建立一个Socket来下载，所以下载的人越多，速度就越快。\n## peer之间的通信\n下面来看一下点与点之间是如何建立连接的。在使用BT协议下载时，所有正在下载同一资源的peer都是对等的，两个peer之间相互建立的连接也是对等的，对等节点建立的连接的数据传输方向也是双向的，数据可由任何一端发送到另一端。\n首先是TCP层的连接，当一个客户端向其他peer发送一个TCP连接请求，这个请求由以下字段组成：\n> 1. pstrlen,固定值为19B\n> 2. pstr,值为\"BitTorrent protocol\"\n> 3. reserved，保留8字节字段，一般全设置为0、\n> 4. info_hash，必须与请求Tracker时发送的info_hash相同\n> 5. peer_id，必须与请求Tracker时发送的peer_id相同\n\n在发送上述握手后，应该会受到相同格式的握手，然后我们就将返回的info_hash和发送的进行匹配，以此来确定是否是同一文件，若没问题，那么就握手成功。握手成功后，就会进行**数据的传输**：\n\n---\n\n1. 提供数据的peer会对下载者发送Bitfield，告诉自己拥有的这个文件的哪些块，这些信息就用Bitfield存储（一个二进制bit数组，数组值为1就表示有这个块）。\n2. 初始化状态下，BT客户端对其他的peer都是**choked状态**（阻断）。当下载者准备好了，就会发送**Unchoked消息**，可以进行消息传输。\n3. 下载者发送Interested消息，告诉提供数据的peer自己要开始下载了。\n4. 下载者发送Request消息，其中Payload包含具体的某个块的信息（序号，begin,length）。\n5. 提供数据的peer向下载者发送Piece，即真正的块数据。\n---\n\n# DHT网络和磁力链接\n## DHT网络\n通过上面对BitTorrent的简单介绍，我们发现BT十分依赖于Tracker服务器，如果Tracker服务器全挂彩了，那么BT也就没用了，也没有办法解决这个问题呢？\nDHT，即**全称分布式哈希表**(Distributed Hash Table)可以有效地解决这个问题，其示意图如下：\n\n![DHT](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.569wnzvy9ss0.webp)\n\nDHT是一种分布式存储方法，在不需要服务器的情况下，每个节点负责一个小范围的路由，并负责存储一小部分数据，从而实现整个DHT网络的寻址和存储。在DHT网络中，每一个peer都是一个Node，有自己的哈希值。每个Node即是上传和下载piece的BT下载节点；也是**一个小型Tracker，其会保留自己附近的一部分节点信息**。\n\n实现DHT的一种算法：[Khashmir](https://www.tribler.org/Khashmir/)，简单介绍一下：\nDHT的每个节点都保存了一张表，上面记录着自己周围节点的ID，当我们向节点A查询B的信息时，就会检索A的表看看有没有B，有就返回B的信息；**没有就返回距离B最近（用XOR计算)的k个节点，然后继续向着k个节点寻找B**。\n\n## 磁力链接\n2009年，作为世界第一Tracker服务商海盗湾，关闭了Tracker服务器，因为涉及侵权问题，随后基于DHT网络的**磁力链接**（Magnet URI scheme）就走上了主流舞台，目前已经成为最流行的下载方式。\n例如有这样一串链接：`magnet:?xt=urn:btih:53SWOUDWKG6ORSKTJHHE3QXTIBOGU5WU`\n\n- magnet是协议名，xt是资源定位点，urn:btih是Hash方法\n- 后面的一串40位16进制数是本文件内容的Hash值，BT下载客户端就是根据这个Hash值在DHT中定位下载文件。\n# 参考资料\n\n[1] [BitTorrent 简介](https://blog.csdn.net/riba2534/article/details/115602512?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165154457716781685369761%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165154457716781685369761&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115602512.142%5Ev9%5Epc_search_result_control_group,157%5Ev4%5Econtrol&utm_term=BitTorrent&spm=1018.2226.3001.4187)\n\n[2] [https://en.wikipedia.org/wiki/BitTorrent#Design](https://en.wikipedia.org/wiki/BitTorrent#Design)\n\n[3] [磁力链接 - 维基百科，自由的百科全书](https://zh.m.wikipedia.org/wiki/%E7%A3%81%E5%8A%9B%E9%93%BE%E6%8E%A5)\n\n[4] [XIU2/TrackersListCollection](https://trackerslist.com/#/zh)\n\n# 小结\n本章内容主要用于总结一些BitTorrent协议和DHT协议的相关知识，由于还未深入学习计算机网络，一些细节的了解还不是很到位，等我到时候学了计算机网络再来深入学习一下😄，这里先留个坑。\n","slug":"BitTorrent协议","published":1,"updated":"2022-10-11T07:41:51.505Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl99pv6r10000tkru6lo72m0h","content":"<p>最近经常会下载一些电影，都是通过一个torrent文件+迅雷下载的，这个torrent文件被称为BT种子，说实话这个名字非常熟悉，中学时经常会听到朋友说起，比如有没有种子什么的😅，但是我一直不太了解这种下载方式。这几天使用这种方式下载的时候，发现和一般通过http协议下载的方式有很大不同，于是我就不禁好奇起来，这种下载方式是如何工作的呢？</p>\n<h1 id=\"概念介绍\"><a href=\"#概念介绍\" class=\"headerlink\" title=\"概念介绍\"></a>概念介绍</h1><p>这种下载方式依托于<a href=\"https://en.wikipedia.org/wiki/BitTorrent\">BitTorrent</a>协议，BitTorrent是一种internet transfer protocol，同样作为一种transfer protocol，BitTorrent与http,ftp(file transfer protocol)这些协议最大的不同在于<strong>BitTorrent是一种distributed transfer protocol（分布式传输协议），什么意思呢</strong>？<br>http/FTP protocol都是让用户从一个目标站点的服务器上下载文件，而当用户过多时，就会超出服务器的带宽限制，导致下载出现问题；而BitTorrent将文件分片，每个用户都会下载文件的分片，在下载时也会将自己的文件分片发给其他正在下载的用户，这就形成了一种<strong>图结构</strong>，<strong>点对点式</strong>（<a href=\"https://en.wikipedia.org/wiki/Peer-to-peer\">Peer-to-peer</a>）的分发文件分片： </p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5dixodre9sk0.webp\" alt=\"P2P结构\"></p>\n<p>正是由于这一特性，BitTorrent在大文件下载和多人同时下载时有非常好的表现。</p>\n<h1 id=\"Torrent文件\"><a href=\"#Torrent文件\" class=\"headerlink\" title=\"Torrent文件\"></a>Torrent文件</h1><p>torrent文件，也就是所谓的BT种子，是我们了解这种下载方式的关键，所以下面就来简单介绍一下这种文件的格式与结构。</p>\n<h2 id=\"编码方式：bencoding\"><a href=\"#编码方式：bencoding\" class=\"headerlink\" title=\"编码方式：bencoding\"></a>编码方式：bencoding</h2><p>torrent文件的编码格式是bencoding,这种编码由ASCII码进行编码，包含以下数据结构：</p>\n<table>\n<thead>\n<tr>\n<th><strong>string</strong></th>\n<th>字符串”hello”在bencoding中就是5:hello，即长度标识+:+字符串</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>integer</strong></td>\n<td>i开头,e结尾，比如123就可以用i123e表示，456用i456e表示</td>\n</tr>\n<tr>\n<td><strong>List</strong></td>\n<td>l开头,e结尾，比如[132,”hello”]就表示为li123e5:helloe</td>\n</tr>\n<tr>\n<td><strong>Dictionary</strong></td>\n<td>d开头,e结尾，key必须是string,value可以是四种数据结构的任意一种，比如{‘fruit’:5,’meat’:8}就可表示为d5:fruiti5e4:meati8ee。除此之外，还要注意，Dictionary必须是有序字典，所有key必须按<a href=\"https://zh.m.wikipedia.org/wiki/%E5%AD%97%E5%85%B8%E5%BA%8F\">字典序</a>升序排列。</td>\n</tr>\n</tbody></table>\n<p>虽然Bencoding比用纯二进制编码效率低，但由于结构简单而且不受字节存储顺序影响（所有数字以十进制编码，不存在<a href=\"http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F\">大端小端的问题</a>），因此具有很好的跨平台性，而且具有较好的灵活性，即使存在故障的字典键，只要将其忽略并更换新的就能兼容补充。</p>\n<h2 id=\"文件格式\"><a href=\"#文件格式\" class=\"headerlink\" title=\"文件格式\"></a>文件格式</h2><p>torrent文件本身是一个字典，类似于Json,里面包含了一些key，那么具体包含哪些key呢？首先我们直接打开一个torrent文件:</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5efiz2romt40.webp\" alt=\"torrent文件\"></p>\n<p>可以看到除了第一行以外，全都是乱码，说明这是一个二进制文件。我们现在已经知道了torrent文件是用Bencoding方式编码的，通过解析器(留个坑)，就可以将其转化为可读的格式:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">&#123;<br>    <span class=\"hljs-string\">&quot;announce&quot;</span>: <span class=\"hljs-string\">&quot;udp://engplus.ru:6969/announce&quot;</span>,<br>    <span class=\"hljs-string\">&quot;announce-list&quot;</span>: [<br>        [<br>            <span class=\"hljs-string\">&quot;udp://engplus.ru:6969/announce&quot;</span><br>        ],<br>        [<br>            <span class=\"hljs-string\">&quot;udp://cutiegirl.ru:6969/announce&quot;</span><br>        ],<br>        [<br>            <span class=\"hljs-string\">&quot;udp://bubu.mapfactor.com:6969/announce&quot;</span><br>        ],<br>        [<br>            <span class=\"hljs-string\">&quot;udp://bt2.archive.org:6969/announce&quot;</span><br>        ]<br>    ],<br>    <span class=\"hljs-string\">&quot;created by&quot;</span>: <span class=\"hljs-string\">&quot;qBittorrent v4.3.91&quot;</span>,<br>    <span class=\"hljs-string\">&quot;creation date&quot;</span>: <span class=\"hljs-string\">&quot;2021-02-12 03:02:32&quot;</span>,<br>    <span class=\"hljs-string\">&quot;info_hash&quot;</span>: <span class=\"hljs-string\">&quot;7cda8188321724d1ce7a0ab0b4f9208023dd1521&quot;</span>,<br>    <span class=\"hljs-string\">&quot;info&quot;</span>: &#123;<br>        <span class=\"hljs-string\">&quot;length&quot;</span>: <span class=\"hljs-number\">4936930690</span>,<br>        <span class=\"hljs-string\">&quot;path&quot;</span>: [<span class=\"hljs-string\">&quot;BT\\u4e16\\u754c\\u7f51(btsj5.com).txt&quot;</span>],<br>        <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;\\u91dc\\u5c71\\u884c.\\u7279\\u6548\\u5b57\\u5e55.2016.BD1080P.AAC.x264.CHS.BTSJ5&quot;</span>,<br>        <span class=\"hljs-string\">&quot;piece length&quot;</span>: <span class=\"hljs-number\">1048576</span>,<br>        <span class=\"hljs-string\">&quot;pieces&quot;</span>: [<br>            <span class=\"hljs-string\">&quot;10e72eba2cbdc9d9b9791706fcbfb84e51093c86&quot;</span>,<br>            <span class=\"hljs-string\">&quot;d91472ddd5e943caa54f8520fcb35fb106033cf2&quot;</span>,<br>            <span class=\"hljs-string\">&quot;214e6470e412215c9cf462ea752adc6a7c90e92f&quot;</span>,<br>            <span class=\"hljs-string\">&quot;214e6470e412215c9cf462ea752adc6a7c90e92f&quot;</span>,<br>            <span class=\"hljs-string\">&quot;903012943eab4ed903f1bc35079f6075f01da4ff&quot;</span>,<br>            <span class=\"hljs-string\">&quot;d118c6af14e0f3e06f8008e712322d06088d9c05&quot;</span>,<br>            <span class=\"hljs-string\">&quot;500813dd3b29e0c88e0127a2fdf7851be2472a58&quot;</span>,<br>            <span class=\"hljs-string\">&quot;…………&quot;</span><br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>从上面我们可以看出一些torrent的字段，下面进行一个汇总：</p>\n<img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1rwj23d240ww.webp\" alt=\"torrent字段\" style=\"zoom:80%;\"  align=\"center\"/>\n\n<h1 id=\"BT下载流程\"><a href=\"#BT下载流程\" class=\"headerlink\" title=\"BT下载流程\"></a>BT下载流程</h1><h2 id=\"简单概述\"><a href=\"#简单概述\" class=\"headerlink\" title=\"简单概述\"></a>简单概述</h2><p>整个的一个BT下载流程是怎样的呢？</p>\n<ol>\n<li>制作Torrent种子文件，制作的过程中要指定发布的文件or文件夹、Tracker URL（即announce字段）、是否启用DHT等等。除此之外，还要将要发布的文件切成块（一般是256KB），用SHA1哈希算法计算每块的哈希值，最后上传到Tracker服务器。</li>\n<li>BT客户端（如迅雷）得到.torrent文件后，就会根据文件中的announce字段找到Tracker服务器地址（连接方式有UDP也有HTTP），然后客户端就会通过Tracker GET请求得到服务，发送哈希值给Tracker，让其查找。</li>\n<li>在找到哈希信息后，Tracker服务器就会反连客户端的IP地址和Port（如果是公网），然后返回正在下载这个文件的所有公网用户的IP地址和Port List,之后会将这个客户端的IP地址和Port保存下来，供其他人使用。</li>\n<li>BT客户端得到这些其他用户IP后，就可以直接连接到这些IP和端口下载资料了。BT客户端会到所有的用户去寻找自己要下载的东西。BT客户端每找到一个用户就建立一个Socket来下载，所以下载的人越多，速度就越快。<h2 id=\"peer之间的通信\"><a href=\"#peer之间的通信\" class=\"headerlink\" title=\"peer之间的通信\"></a>peer之间的通信</h2>下面来看一下点与点之间是如何建立连接的。在使用BT协议下载时，所有正在下载同一资源的peer都是对等的，两个peer之间相互建立的连接也是对等的，对等节点建立的连接的数据传输方向也是双向的，数据可由任何一端发送到另一端。<br>首先是TCP层的连接，当一个客户端向其他peer发送一个TCP连接请求，这个请求由以下字段组成：<blockquote>\n<ol>\n<li>pstrlen,固定值为19B</li>\n<li>pstr,值为”BitTorrent protocol”</li>\n<li>reserved，保留8字节字段，一般全设置为0、</li>\n<li>info_hash，必须与请求Tracker时发送的info_hash相同</li>\n<li>peer_id，必须与请求Tracker时发送的peer_id相同</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<p>在发送上述握手后，应该会受到相同格式的握手，然后我们就将返回的info_hash和发送的进行匹配，以此来确定是否是同一文件，若没问题，那么就握手成功。握手成功后，就会进行<strong>数据的传输</strong>：</p>\n<hr>\n<ol>\n<li>提供数据的peer会对下载者发送Bitfield，告诉自己拥有的这个文件的哪些块，这些信息就用Bitfield存储（一个二进制bit数组，数组值为1就表示有这个块）。</li>\n<li>初始化状态下，BT客户端对其他的peer都是<strong>choked状态</strong>（阻断）。当下载者准备好了，就会发送<strong>Unchoked消息</strong>，可以进行消息传输。</li>\n<li>下载者发送Interested消息，告诉提供数据的peer自己要开始下载了。</li>\n<li>下载者发送Request消息，其中Payload包含具体的某个块的信息（序号，begin,length）。</li>\n<li>提供数据的peer向下载者发送Piece，即真正的块数据。</li>\n</ol>\n<hr>\n<h1 id=\"DHT网络和磁力链接\"><a href=\"#DHT网络和磁力链接\" class=\"headerlink\" title=\"DHT网络和磁力链接\"></a>DHT网络和磁力链接</h1><h2 id=\"DHT网络\"><a href=\"#DHT网络\" class=\"headerlink\" title=\"DHT网络\"></a>DHT网络</h2><p>通过上面对BitTorrent的简单介绍，我们发现BT十分依赖于Tracker服务器，如果Tracker服务器全挂彩了，那么BT也就没用了，也没有办法解决这个问题呢？<br>DHT，即<strong>全称分布式哈希表</strong>(Distributed Hash Table)可以有效地解决这个问题，其示意图如下：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.569wnzvy9ss0.webp\" alt=\"DHT\"></p>\n<p>DHT是一种分布式存储方法，在不需要服务器的情况下，每个节点负责一个小范围的路由，并负责存储一小部分数据，从而实现整个DHT网络的寻址和存储。在DHT网络中，每一个peer都是一个Node，有自己的哈希值。每个Node即是上传和下载piece的BT下载节点；也是<strong>一个小型Tracker，其会保留自己附近的一部分节点信息</strong>。</p>\n<p>实现DHT的一种算法：<a href=\"https://www.tribler.org/Khashmir/\">Khashmir</a>，简单介绍一下：<br>DHT的每个节点都保存了一张表，上面记录着自己周围节点的ID，当我们向节点A查询B的信息时，就会检索A的表看看有没有B，有就返回B的信息；<strong>没有就返回距离B最近（用XOR计算)的k个节点，然后继续向着k个节点寻找B</strong>。</p>\n<h2 id=\"磁力链接\"><a href=\"#磁力链接\" class=\"headerlink\" title=\"磁力链接\"></a>磁力链接</h2><p>2009年，作为世界第一Tracker服务商海盗湾，关闭了Tracker服务器，因为涉及侵权问题，随后基于DHT网络的<strong>磁力链接</strong>（Magnet URI scheme）就走上了主流舞台，目前已经成为最流行的下载方式。<br>例如有这样一串链接：<code>magnet:?xt=urn:btih:53SWOUDWKG6ORSKTJHHE3QXTIBOGU5WU</code></p>\n<ul>\n<li>magnet是协议名，xt是资源定位点，urn:btih是Hash方法</li>\n<li>后面的一串40位16进制数是本文件内容的Hash值，BT下载客户端就是根据这个Hash值在DHT中定位下载文件。<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1></li>\n</ul>\n<p>[1] <a href=\"https://blog.csdn.net/riba2534/article/details/115602512?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165154457716781685369761%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165154457716781685369761&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115602512.142%5Ev9%5Epc_search_result_control_group,157%5Ev4%5Econtrol&utm_term=BitTorrent&spm=1018.2226.3001.4187\">BitTorrent 简介</a></p>\n<p>[2] <a href=\"https://en.wikipedia.org/wiki/BitTorrent#Design\">https://en.wikipedia.org/wiki/BitTorrent#Design</a></p>\n<p>[3] <a href=\"https://zh.m.wikipedia.org/wiki/%E7%A3%81%E5%8A%9B%E9%93%BE%E6%8E%A5\">磁力链接 - 维基百科，自由的百科全书</a></p>\n<p>[4] <a href=\"https://trackerslist.com/#/zh\">XIU2/TrackersListCollection</a></p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>本章内容主要用于总结一些BitTorrent协议和DHT协议的相关知识，由于还未深入学习计算机网络，一些细节的了解还不是很到位，等我到时候学了计算机网络再来深入学习一下😄，这里先留个坑。</p>\n","site":{"data":{}},"more":"<p>最近经常会下载一些电影，都是通过一个torrent文件+迅雷下载的，这个torrent文件被称为BT种子，说实话这个名字非常熟悉，中学时经常会听到朋友说起，比如有没有种子什么的😅，但是我一直不太了解这种下载方式。这几天使用这种方式下载的时候，发现和一般通过http协议下载的方式有很大不同，于是我就不禁好奇起来，这种下载方式是如何工作的呢？</p>\n<h1 id=\"概念介绍\"><a href=\"#概念介绍\" class=\"headerlink\" title=\"概念介绍\"></a>概念介绍</h1><p>这种下载方式依托于<a href=\"https://en.wikipedia.org/wiki/BitTorrent\">BitTorrent</a>协议，BitTorrent是一种internet transfer protocol，同样作为一种transfer protocol，BitTorrent与http,ftp(file transfer protocol)这些协议最大的不同在于<strong>BitTorrent是一种distributed transfer protocol（分布式传输协议），什么意思呢</strong>？<br>http/FTP protocol都是让用户从一个目标站点的服务器上下载文件，而当用户过多时，就会超出服务器的带宽限制，导致下载出现问题；而BitTorrent将文件分片，每个用户都会下载文件的分片，在下载时也会将自己的文件分片发给其他正在下载的用户，这就形成了一种<strong>图结构</strong>，<strong>点对点式</strong>（<a href=\"https://en.wikipedia.org/wiki/Peer-to-peer\">Peer-to-peer</a>）的分发文件分片： </p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5dixodre9sk0.webp\" alt=\"P2P结构\"></p>\n<p>正是由于这一特性，BitTorrent在大文件下载和多人同时下载时有非常好的表现。</p>\n<h1 id=\"Torrent文件\"><a href=\"#Torrent文件\" class=\"headerlink\" title=\"Torrent文件\"></a>Torrent文件</h1><p>torrent文件，也就是所谓的BT种子，是我们了解这种下载方式的关键，所以下面就来简单介绍一下这种文件的格式与结构。</p>\n<h2 id=\"编码方式：bencoding\"><a href=\"#编码方式：bencoding\" class=\"headerlink\" title=\"编码方式：bencoding\"></a>编码方式：bencoding</h2><p>torrent文件的编码格式是bencoding,这种编码由ASCII码进行编码，包含以下数据结构：</p>\n<table>\n<thead>\n<tr>\n<th><strong>string</strong></th>\n<th>字符串”hello”在bencoding中就是5:hello，即长度标识+:+字符串</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>integer</strong></td>\n<td>i开头,e结尾，比如123就可以用i123e表示，456用i456e表示</td>\n</tr>\n<tr>\n<td><strong>List</strong></td>\n<td>l开头,e结尾，比如[132,”hello”]就表示为li123e5:helloe</td>\n</tr>\n<tr>\n<td><strong>Dictionary</strong></td>\n<td>d开头,e结尾，key必须是string,value可以是四种数据结构的任意一种，比如{‘fruit’:5,’meat’:8}就可表示为d5:fruiti5e4:meati8ee。除此之外，还要注意，Dictionary必须是有序字典，所有key必须按<a href=\"https://zh.m.wikipedia.org/wiki/%E5%AD%97%E5%85%B8%E5%BA%8F\">字典序</a>升序排列。</td>\n</tr>\n</tbody></table>\n<p>虽然Bencoding比用纯二进制编码效率低，但由于结构简单而且不受字节存储顺序影响（所有数字以十进制编码，不存在<a href=\"http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F\">大端小端的问题</a>），因此具有很好的跨平台性，而且具有较好的灵活性，即使存在故障的字典键，只要将其忽略并更换新的就能兼容补充。</p>\n<h2 id=\"文件格式\"><a href=\"#文件格式\" class=\"headerlink\" title=\"文件格式\"></a>文件格式</h2><p>torrent文件本身是一个字典，类似于Json,里面包含了一些key，那么具体包含哪些key呢？首先我们直接打开一个torrent文件:</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5efiz2romt40.webp\" alt=\"torrent文件\"></p>\n<p>可以看到除了第一行以外，全都是乱码，说明这是一个二进制文件。我们现在已经知道了torrent文件是用Bencoding方式编码的，通过解析器(留个坑)，就可以将其转化为可读的格式:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">&#123;<br>    <span class=\"hljs-string\">&quot;announce&quot;</span>: <span class=\"hljs-string\">&quot;udp://engplus.ru:6969/announce&quot;</span>,<br>    <span class=\"hljs-string\">&quot;announce-list&quot;</span>: [<br>        [<br>            <span class=\"hljs-string\">&quot;udp://engplus.ru:6969/announce&quot;</span><br>        ],<br>        [<br>            <span class=\"hljs-string\">&quot;udp://cutiegirl.ru:6969/announce&quot;</span><br>        ],<br>        [<br>            <span class=\"hljs-string\">&quot;udp://bubu.mapfactor.com:6969/announce&quot;</span><br>        ],<br>        [<br>            <span class=\"hljs-string\">&quot;udp://bt2.archive.org:6969/announce&quot;</span><br>        ]<br>    ],<br>    <span class=\"hljs-string\">&quot;created by&quot;</span>: <span class=\"hljs-string\">&quot;qBittorrent v4.3.91&quot;</span>,<br>    <span class=\"hljs-string\">&quot;creation date&quot;</span>: <span class=\"hljs-string\">&quot;2021-02-12 03:02:32&quot;</span>,<br>    <span class=\"hljs-string\">&quot;info_hash&quot;</span>: <span class=\"hljs-string\">&quot;7cda8188321724d1ce7a0ab0b4f9208023dd1521&quot;</span>,<br>    <span class=\"hljs-string\">&quot;info&quot;</span>: &#123;<br>        <span class=\"hljs-string\">&quot;length&quot;</span>: <span class=\"hljs-number\">4936930690</span>,<br>        <span class=\"hljs-string\">&quot;path&quot;</span>: [<span class=\"hljs-string\">&quot;BT\\u4e16\\u754c\\u7f51(btsj5.com).txt&quot;</span>],<br>        <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;\\u91dc\\u5c71\\u884c.\\u7279\\u6548\\u5b57\\u5e55.2016.BD1080P.AAC.x264.CHS.BTSJ5&quot;</span>,<br>        <span class=\"hljs-string\">&quot;piece length&quot;</span>: <span class=\"hljs-number\">1048576</span>,<br>        <span class=\"hljs-string\">&quot;pieces&quot;</span>: [<br>            <span class=\"hljs-string\">&quot;10e72eba2cbdc9d9b9791706fcbfb84e51093c86&quot;</span>,<br>            <span class=\"hljs-string\">&quot;d91472ddd5e943caa54f8520fcb35fb106033cf2&quot;</span>,<br>            <span class=\"hljs-string\">&quot;214e6470e412215c9cf462ea752adc6a7c90e92f&quot;</span>,<br>            <span class=\"hljs-string\">&quot;214e6470e412215c9cf462ea752adc6a7c90e92f&quot;</span>,<br>            <span class=\"hljs-string\">&quot;903012943eab4ed903f1bc35079f6075f01da4ff&quot;</span>,<br>            <span class=\"hljs-string\">&quot;d118c6af14e0f3e06f8008e712322d06088d9c05&quot;</span>,<br>            <span class=\"hljs-string\">&quot;500813dd3b29e0c88e0127a2fdf7851be2472a58&quot;</span>,<br>            <span class=\"hljs-string\">&quot;…………&quot;</span><br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>从上面我们可以看出一些torrent的字段，下面进行一个汇总：</p>\n<img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1rwj23d240ww.webp\" alt=\"torrent字段\" style=\"zoom:80%;\"  align=\"center\"/>\n\n<h1 id=\"BT下载流程\"><a href=\"#BT下载流程\" class=\"headerlink\" title=\"BT下载流程\"></a>BT下载流程</h1><h2 id=\"简单概述\"><a href=\"#简单概述\" class=\"headerlink\" title=\"简单概述\"></a>简单概述</h2><p>整个的一个BT下载流程是怎样的呢？</p>\n<ol>\n<li>制作Torrent种子文件，制作的过程中要指定发布的文件or文件夹、Tracker URL（即announce字段）、是否启用DHT等等。除此之外，还要将要发布的文件切成块（一般是256KB），用SHA1哈希算法计算每块的哈希值，最后上传到Tracker服务器。</li>\n<li>BT客户端（如迅雷）得到.torrent文件后，就会根据文件中的announce字段找到Tracker服务器地址（连接方式有UDP也有HTTP），然后客户端就会通过Tracker GET请求得到服务，发送哈希值给Tracker，让其查找。</li>\n<li>在找到哈希信息后，Tracker服务器就会反连客户端的IP地址和Port（如果是公网），然后返回正在下载这个文件的所有公网用户的IP地址和Port List,之后会将这个客户端的IP地址和Port保存下来，供其他人使用。</li>\n<li>BT客户端得到这些其他用户IP后，就可以直接连接到这些IP和端口下载资料了。BT客户端会到所有的用户去寻找自己要下载的东西。BT客户端每找到一个用户就建立一个Socket来下载，所以下载的人越多，速度就越快。<h2 id=\"peer之间的通信\"><a href=\"#peer之间的通信\" class=\"headerlink\" title=\"peer之间的通信\"></a>peer之间的通信</h2>下面来看一下点与点之间是如何建立连接的。在使用BT协议下载时，所有正在下载同一资源的peer都是对等的，两个peer之间相互建立的连接也是对等的，对等节点建立的连接的数据传输方向也是双向的，数据可由任何一端发送到另一端。<br>首先是TCP层的连接，当一个客户端向其他peer发送一个TCP连接请求，这个请求由以下字段组成：<blockquote>\n<ol>\n<li>pstrlen,固定值为19B</li>\n<li>pstr,值为”BitTorrent protocol”</li>\n<li>reserved，保留8字节字段，一般全设置为0、</li>\n<li>info_hash，必须与请求Tracker时发送的info_hash相同</li>\n<li>peer_id，必须与请求Tracker时发送的peer_id相同</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<p>在发送上述握手后，应该会受到相同格式的握手，然后我们就将返回的info_hash和发送的进行匹配，以此来确定是否是同一文件，若没问题，那么就握手成功。握手成功后，就会进行<strong>数据的传输</strong>：</p>\n<hr>\n<ol>\n<li>提供数据的peer会对下载者发送Bitfield，告诉自己拥有的这个文件的哪些块，这些信息就用Bitfield存储（一个二进制bit数组，数组值为1就表示有这个块）。</li>\n<li>初始化状态下，BT客户端对其他的peer都是<strong>choked状态</strong>（阻断）。当下载者准备好了，就会发送<strong>Unchoked消息</strong>，可以进行消息传输。</li>\n<li>下载者发送Interested消息，告诉提供数据的peer自己要开始下载了。</li>\n<li>下载者发送Request消息，其中Payload包含具体的某个块的信息（序号，begin,length）。</li>\n<li>提供数据的peer向下载者发送Piece，即真正的块数据。</li>\n</ol>\n<hr>\n<h1 id=\"DHT网络和磁力链接\"><a href=\"#DHT网络和磁力链接\" class=\"headerlink\" title=\"DHT网络和磁力链接\"></a>DHT网络和磁力链接</h1><h2 id=\"DHT网络\"><a href=\"#DHT网络\" class=\"headerlink\" title=\"DHT网络\"></a>DHT网络</h2><p>通过上面对BitTorrent的简单介绍，我们发现BT十分依赖于Tracker服务器，如果Tracker服务器全挂彩了，那么BT也就没用了，也没有办法解决这个问题呢？<br>DHT，即<strong>全称分布式哈希表</strong>(Distributed Hash Table)可以有效地解决这个问题，其示意图如下：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.569wnzvy9ss0.webp\" alt=\"DHT\"></p>\n<p>DHT是一种分布式存储方法，在不需要服务器的情况下，每个节点负责一个小范围的路由，并负责存储一小部分数据，从而实现整个DHT网络的寻址和存储。在DHT网络中，每一个peer都是一个Node，有自己的哈希值。每个Node即是上传和下载piece的BT下载节点；也是<strong>一个小型Tracker，其会保留自己附近的一部分节点信息</strong>。</p>\n<p>实现DHT的一种算法：<a href=\"https://www.tribler.org/Khashmir/\">Khashmir</a>，简单介绍一下：<br>DHT的每个节点都保存了一张表，上面记录着自己周围节点的ID，当我们向节点A查询B的信息时，就会检索A的表看看有没有B，有就返回B的信息；<strong>没有就返回距离B最近（用XOR计算)的k个节点，然后继续向着k个节点寻找B</strong>。</p>\n<h2 id=\"磁力链接\"><a href=\"#磁力链接\" class=\"headerlink\" title=\"磁力链接\"></a>磁力链接</h2><p>2009年，作为世界第一Tracker服务商海盗湾，关闭了Tracker服务器，因为涉及侵权问题，随后基于DHT网络的<strong>磁力链接</strong>（Magnet URI scheme）就走上了主流舞台，目前已经成为最流行的下载方式。<br>例如有这样一串链接：<code>magnet:?xt=urn:btih:53SWOUDWKG6ORSKTJHHE3QXTIBOGU5WU</code></p>\n<ul>\n<li>magnet是协议名，xt是资源定位点，urn:btih是Hash方法</li>\n<li>后面的一串40位16进制数是本文件内容的Hash值，BT下载客户端就是根据这个Hash值在DHT中定位下载文件。<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1></li>\n</ul>\n<p>[1] <a href=\"https://blog.csdn.net/riba2534/article/details/115602512?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165154457716781685369761%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165154457716781685369761&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115602512.142%5Ev9%5Epc_search_result_control_group,157%5Ev4%5Econtrol&utm_term=BitTorrent&spm=1018.2226.3001.4187\">BitTorrent 简介</a></p>\n<p>[2] <a href=\"https://en.wikipedia.org/wiki/BitTorrent#Design\">https://en.wikipedia.org/wiki/BitTorrent#Design</a></p>\n<p>[3] <a href=\"https://zh.m.wikipedia.org/wiki/%E7%A3%81%E5%8A%9B%E9%93%BE%E6%8E%A5\">磁力链接 - 维基百科，自由的百科全书</a></p>\n<p>[4] <a href=\"https://trackerslist.com/#/zh\">XIU2/TrackersListCollection</a></p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>本章内容主要用于总结一些BitTorrent协议和DHT协议的相关知识，由于还未深入学习计算机网络，一些细节的了解还不是很到位，等我到时候学了计算机网络再来深入学习一下😄，这里先留个坑。</p>\n"},{"title":"servlet和jsp","date":"2022-10-15T00:55:26.000Z","banner_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1etvdeo7ddy8.webp","index_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1etvdeo7ddy8.webp","excerpt":"入门javaweb，对servlet和jsp的思考","_content":"\n# 前言\n\n最近两周在学习Java Web，从了解Tomcat开始，再到学习Servlet，前端三件套等等，这个过程中我学习到了许多知识，也引发了我的一些思考，我认为有必要将这些思考记录下来，**技术总是会过时的，但技术背后的思想不会那么快过时**，而思考能帮助我理解这些技术背后的思想，因此有必要将这些思考记录下来。\n\n# Tomcat\n\n## web服务简介\n\n目前大部分的web服务是以**TCP/IP+HTTP协议**为基础的，那么这样的一个web服务到底是怎样的工作流程呢？\n\n我们拿B站举例，假设我们在浏览器中点击B站的链接或者在地址栏中输入`https://www.bilibili.com`，浏览器就会封装好一个用于请求的数据包，然后经过网络发送到B站的服务器。服务器会根据网络层协议，比如HTTP协议，解析我们发送的请求数据包，然后将静态资源（html,css等等）和从数据库取出的数据等资源封装到响应数据包中，然后发送回我们的浏览器，也就是客户端，之后我们就能看到B站的主页页面了：\n\n<div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.44vbajds3m60.webp\" alt=\"web服务\" style=\"zoom:67%;\" /></div>\n\n以上就是比较典型的web服务过程，当然实际情况要复杂的多，比如在实际地处理客户端（浏览器）数据之前，服务器要和客户端建立连接，这就涉及TCP的三次握手；又比如数据出现差错了怎么办，该怎么校验，怎么解决？又或者是丢包了该怎么办？但这些不是我们在web开发时要考虑的问题，因为这大部分是交给**TCP、HTTP这些网络协议**处理的，在这之上，我们获得的数据还要**经过服务器端程序的一层封装**。\n\n## Tomcat简介\n\nTomcat就是前文提到的一种服务器端程序，它实际上是一个**http服务器+servlet容器**。\n\n作为http服务器，Tomcat为web开发者封装了应用层及其下层的协议，交给开发者的只是**封装好的Request和Response对象**，这样的好处是使得开发者能够更加专注于业务逻辑。\n\n那么servlet容器又是什么呢？\n\n前文说了web服务的第三步是调用服务器端的处理程序去处理封装好的Request对象，然后返回响应对象。其实这些处理程序就是Servlet，而Servlet容器就是用来管理Servlet的，**Tomcat的主体就是由连接器和不同种类的Servlet容器建立起来的**，其核心架构如下：\n\n<div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.25mfalet1zy8.webp\" alt=\"Tomcat架构\" style=\"zoom:80%;\" /></div>\n\n一个web应用可以有多个service，比如支付service，订单处理service等等，而一个service中又有连接器和容器，这个容器就是我们说的**servlet**，它负责处理数据，其结构是像**俄罗斯套娃**一样的；而连接器就负责外部数据和servlet容器的连接，**之前说的封装应用层及其下层协议数据**就是连接器干的活。\n\n![servlet层次结构](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.nibbm6csbsg.webp)\n\n上图展现了容器的内部结构，一层套一层，大层管理小层，具体细节就不多说了。\n\n# Servlet\n\nServlet的本质呢就是一个Java接口，对于这个Servlet接口，会有不同的实现，我们所说的Servlet就是这些不同的实现。典型的Servlet继承关系如下：\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.ehnty66lhp.webp\" alt=\"servlet继承关系\" style=\"zoom:80%;\" /></div>\n\n**GenericServlet抽象类**实现了**Servlet接口**，其中核心方法为**init()**、**service()**和**destroy()**，**HttpServlet抽象类**专门用来处理HTTP请求，它继承自**GenericServlet抽象类**，实际上重写了**service()**方法，<font color=purple>**在这个service方法里，我们处理客户端发过来的http请求。**</font>\n\n一个Web服务的主要三部分就是**接受请求→处理请求→响应请求**。因为`处理请求(业务逻辑)`是不同的，所以提取出来交给**Servlet**，由程序员来编写业务逻辑；而其它两部分大同小异，所以交给Tomcat里的**连接器组件**干（**解析和封装请求和响应包**）。\n\n## Servlet生命周期\n\n 说到Servlet就不能不提Servlet的生命周期，一个Servlet的生命周期是**创建**→服务→**销毁**：\n\n- 一个Servlet是在被第一次调用时创建，之后服务无数次。\n- 直到服务器关闭后，才销毁Servlet。\n\n这就涉及一个问题，**第一个使用Servlet的用户收到响应的时间就会很长**，因为要等对应服务的Servlet启动嘛；如果系统很小，这当然不是事，但是一旦系统变得复杂了，效率就不是很高；解决办法是<u>我们把常用的servlet在服务器启动的时候，就给它启动</u>。\n\n# JSP\n\n在说JSP之前，我们得知道浏览器上的页面到底是什么东西，实际上一个**静态页面**的主体就是**html + css**，html文件就是给页面上的各种组件布局，css就是定制不同组件的样式，比如颜色啊，位置啊等等，我们的浏览器解析html和css后，就会生成我们看到的页面。所谓的http响应呢，实际上就是服务器发送给客户端浏览器的内容大部分是以html和css为主体的静态资源。\n\n早期的JAVA WEB开发呢，实际上就是美工把html文件交给程序员，然后程序员用一行行out.println()将html语句拼接起来响应给客户端，其思路就是<font color=purple>**用Servlet程序将html代码和处理好的数据拼好再放回去**</font>。<u>同时期的PHP呢，搞了一套**在html中嵌入代码来动态生成html内容的方法**，这样就避免了手动print()一行行html的麻烦</u>。\n\n**JSP**呢，就是sun公司仿照PHP，ASP这些工具的思路创建的东西。JSP文件看上去和HTML文件长得差不多，只不过多了一些java代码和不属于html的标签，举个例子：\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>\n<c:set var=\"user\" value=\"${sessionScope.reader}\"></c:set>\n<div class=\"person\" >\n    <link rel=\"stylesheet\" href=\"${pageContext.request.contextPath}/resources/css/person.css\"/>\n<h1>个人信息</h1>\n<table >\n    <tr>\n        <td class=\"column\">用户名</td>\n        <td class=\"value\">\n            <c:out value=\"${user.userName}\"></c:out>\n        </td>\n    </tr>\n    <tr>\n        <td class=\"column\">用户类型</td>\n        <td class=\"value\">\n            <c:if test=\"${user.userType=='admin'}\" var=\"result\">\n                <c:out value=\"管理员\"></c:out>\n            </c:if>\n            <c:if test=\"${user.userType=='reader'}\" var=\"result\">\n                <c:out value=\"读者\"></c:out>\n            </c:if>\n        </td>\n    </tr>\n    <tr>\n        <td class=\"column\">用户密码</td>\n        <td class=\"value\">\n      \t\t <c:out value=\"${user.passwd}\"></c:out>\n        </td>\n    </tr>\n        <c:if test=\"${user.userType=='reader'}\" var=\"res\">\n            <tr>\n                <td class=\"column\">借阅中数量</td>\n                <td class=\"value\">\n                    <c:out value=\"${user.rendingCount}\"></c:out>\n                </td>\n            </tr>\n            <tr>\n                <td class=\"column\">总借阅数</td>\n                <td class=\"value\">\n                    <c:out value=\"${user.havaRendCount}\"></c:out>\n                </td>\n            </tr>\n        </c:if>\n</table>\n</div>\n```\n\n这就是一个jsp文件，其实jsp就是由**html+Java代码**组成的，那为什么上面的jsp文件中没有出现java代码呢？这是因为java代码被jsp标签取代了，jsp标签实际上就是封装好的java代码，因此实际上jsp标签还是java代码，只不过推荐使用这种写法。\n\n虽然格式上jsp和html差不多，但实际上两者根本不是一回事，**jsp实际上是一个servlet，是在服务器端发挥作用的，而不是像html在浏览器展示数据的**。你servlet不是每次都要一行行println那些html文件吗？那多麻烦啊是不是，你直接把代码写在html里，由服务器来帮你解析成servlet，这样不就省事多了吗？\n\n所以jsp本质上呢是servlet代码的简便写法，方便我们把动态数据嵌入到静态的html中，具体的servlet代码交给服务器里专门的jsp处理程序生成，其最后返回给客户端的，还是一个html静态资源。\n\n","source":"_posts/对JavaWeb的思考1.md","raw":"---\ntitle: servlet和jsp\ndate: 2022-10-15 08:55:26\ntags:\n - JavaWeb\ncategories:\n- web开发\n- java web\nbanner_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1etvdeo7ddy8.webp\nindex_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1etvdeo7ddy8.webp\nexcerpt: 入门javaweb，对servlet和jsp的思考\n---\n\n# 前言\n\n最近两周在学习Java Web，从了解Tomcat开始，再到学习Servlet，前端三件套等等，这个过程中我学习到了许多知识，也引发了我的一些思考，我认为有必要将这些思考记录下来，**技术总是会过时的，但技术背后的思想不会那么快过时**，而思考能帮助我理解这些技术背后的思想，因此有必要将这些思考记录下来。\n\n# Tomcat\n\n## web服务简介\n\n目前大部分的web服务是以**TCP/IP+HTTP协议**为基础的，那么这样的一个web服务到底是怎样的工作流程呢？\n\n我们拿B站举例，假设我们在浏览器中点击B站的链接或者在地址栏中输入`https://www.bilibili.com`，浏览器就会封装好一个用于请求的数据包，然后经过网络发送到B站的服务器。服务器会根据网络层协议，比如HTTP协议，解析我们发送的请求数据包，然后将静态资源（html,css等等）和从数据库取出的数据等资源封装到响应数据包中，然后发送回我们的浏览器，也就是客户端，之后我们就能看到B站的主页页面了：\n\n<div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.44vbajds3m60.webp\" alt=\"web服务\" style=\"zoom:67%;\" /></div>\n\n以上就是比较典型的web服务过程，当然实际情况要复杂的多，比如在实际地处理客户端（浏览器）数据之前，服务器要和客户端建立连接，这就涉及TCP的三次握手；又比如数据出现差错了怎么办，该怎么校验，怎么解决？又或者是丢包了该怎么办？但这些不是我们在web开发时要考虑的问题，因为这大部分是交给**TCP、HTTP这些网络协议**处理的，在这之上，我们获得的数据还要**经过服务器端程序的一层封装**。\n\n## Tomcat简介\n\nTomcat就是前文提到的一种服务器端程序，它实际上是一个**http服务器+servlet容器**。\n\n作为http服务器，Tomcat为web开发者封装了应用层及其下层的协议，交给开发者的只是**封装好的Request和Response对象**，这样的好处是使得开发者能够更加专注于业务逻辑。\n\n那么servlet容器又是什么呢？\n\n前文说了web服务的第三步是调用服务器端的处理程序去处理封装好的Request对象，然后返回响应对象。其实这些处理程序就是Servlet，而Servlet容器就是用来管理Servlet的，**Tomcat的主体就是由连接器和不同种类的Servlet容器建立起来的**，其核心架构如下：\n\n<div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.25mfalet1zy8.webp\" alt=\"Tomcat架构\" style=\"zoom:80%;\" /></div>\n\n一个web应用可以有多个service，比如支付service，订单处理service等等，而一个service中又有连接器和容器，这个容器就是我们说的**servlet**，它负责处理数据，其结构是像**俄罗斯套娃**一样的；而连接器就负责外部数据和servlet容器的连接，**之前说的封装应用层及其下层协议数据**就是连接器干的活。\n\n![servlet层次结构](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.nibbm6csbsg.webp)\n\n上图展现了容器的内部结构，一层套一层，大层管理小层，具体细节就不多说了。\n\n# Servlet\n\nServlet的本质呢就是一个Java接口，对于这个Servlet接口，会有不同的实现，我们所说的Servlet就是这些不同的实现。典型的Servlet继承关系如下：\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.ehnty66lhp.webp\" alt=\"servlet继承关系\" style=\"zoom:80%;\" /></div>\n\n**GenericServlet抽象类**实现了**Servlet接口**，其中核心方法为**init()**、**service()**和**destroy()**，**HttpServlet抽象类**专门用来处理HTTP请求，它继承自**GenericServlet抽象类**，实际上重写了**service()**方法，<font color=purple>**在这个service方法里，我们处理客户端发过来的http请求。**</font>\n\n一个Web服务的主要三部分就是**接受请求→处理请求→响应请求**。因为`处理请求(业务逻辑)`是不同的，所以提取出来交给**Servlet**，由程序员来编写业务逻辑；而其它两部分大同小异，所以交给Tomcat里的**连接器组件**干（**解析和封装请求和响应包**）。\n\n## Servlet生命周期\n\n 说到Servlet就不能不提Servlet的生命周期，一个Servlet的生命周期是**创建**→服务→**销毁**：\n\n- 一个Servlet是在被第一次调用时创建，之后服务无数次。\n- 直到服务器关闭后，才销毁Servlet。\n\n这就涉及一个问题，**第一个使用Servlet的用户收到响应的时间就会很长**，因为要等对应服务的Servlet启动嘛；如果系统很小，这当然不是事，但是一旦系统变得复杂了，效率就不是很高；解决办法是<u>我们把常用的servlet在服务器启动的时候，就给它启动</u>。\n\n# JSP\n\n在说JSP之前，我们得知道浏览器上的页面到底是什么东西，实际上一个**静态页面**的主体就是**html + css**，html文件就是给页面上的各种组件布局，css就是定制不同组件的样式，比如颜色啊，位置啊等等，我们的浏览器解析html和css后，就会生成我们看到的页面。所谓的http响应呢，实际上就是服务器发送给客户端浏览器的内容大部分是以html和css为主体的静态资源。\n\n早期的JAVA WEB开发呢，实际上就是美工把html文件交给程序员，然后程序员用一行行out.println()将html语句拼接起来响应给客户端，其思路就是<font color=purple>**用Servlet程序将html代码和处理好的数据拼好再放回去**</font>。<u>同时期的PHP呢，搞了一套**在html中嵌入代码来动态生成html内容的方法**，这样就避免了手动print()一行行html的麻烦</u>。\n\n**JSP**呢，就是sun公司仿照PHP，ASP这些工具的思路创建的东西。JSP文件看上去和HTML文件长得差不多，只不过多了一些java代码和不属于html的标签，举个例子：\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>\n<c:set var=\"user\" value=\"${sessionScope.reader}\"></c:set>\n<div class=\"person\" >\n    <link rel=\"stylesheet\" href=\"${pageContext.request.contextPath}/resources/css/person.css\"/>\n<h1>个人信息</h1>\n<table >\n    <tr>\n        <td class=\"column\">用户名</td>\n        <td class=\"value\">\n            <c:out value=\"${user.userName}\"></c:out>\n        </td>\n    </tr>\n    <tr>\n        <td class=\"column\">用户类型</td>\n        <td class=\"value\">\n            <c:if test=\"${user.userType=='admin'}\" var=\"result\">\n                <c:out value=\"管理员\"></c:out>\n            </c:if>\n            <c:if test=\"${user.userType=='reader'}\" var=\"result\">\n                <c:out value=\"读者\"></c:out>\n            </c:if>\n        </td>\n    </tr>\n    <tr>\n        <td class=\"column\">用户密码</td>\n        <td class=\"value\">\n      \t\t <c:out value=\"${user.passwd}\"></c:out>\n        </td>\n    </tr>\n        <c:if test=\"${user.userType=='reader'}\" var=\"res\">\n            <tr>\n                <td class=\"column\">借阅中数量</td>\n                <td class=\"value\">\n                    <c:out value=\"${user.rendingCount}\"></c:out>\n                </td>\n            </tr>\n            <tr>\n                <td class=\"column\">总借阅数</td>\n                <td class=\"value\">\n                    <c:out value=\"${user.havaRendCount}\"></c:out>\n                </td>\n            </tr>\n        </c:if>\n</table>\n</div>\n```\n\n这就是一个jsp文件，其实jsp就是由**html+Java代码**组成的，那为什么上面的jsp文件中没有出现java代码呢？这是因为java代码被jsp标签取代了，jsp标签实际上就是封装好的java代码，因此实际上jsp标签还是java代码，只不过推荐使用这种写法。\n\n虽然格式上jsp和html差不多，但实际上两者根本不是一回事，**jsp实际上是一个servlet，是在服务器端发挥作用的，而不是像html在浏览器展示数据的**。你servlet不是每次都要一行行println那些html文件吗？那多麻烦啊是不是，你直接把代码写在html里，由服务器来帮你解析成servlet，这样不就省事多了吗？\n\n所以jsp本质上呢是servlet代码的简便写法，方便我们把动态数据嵌入到静态的html中，具体的servlet代码交给服务器里专门的jsp处理程序生成，其最后返回给客户端的，还是一个html静态资源。\n\n","slug":"对JavaWeb的思考1","published":1,"updated":"2022-11-20T02:43:01.487Z","_id":"cl99q176300001oru70qv4tex","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近两周在学习Java Web，从了解Tomcat开始，再到学习Servlet，前端三件套等等，这个过程中我学习到了许多知识，也引发了我的一些思考，我认为有必要将这些思考记录下来，<strong>技术总是会过时的，但技术背后的思想不会那么快过时</strong>，而思考能帮助我理解这些技术背后的思想，因此有必要将这些思考记录下来。</p>\n<h1 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h1><h2 id=\"web服务简介\"><a href=\"#web服务简介\" class=\"headerlink\" title=\"web服务简介\"></a>web服务简介</h2><p>目前大部分的web服务是以<strong>TCP/IP+HTTP协议</strong>为基础的，那么这样的一个web服务到底是怎样的工作流程呢？</p>\n<p>我们拿B站举例，假设我们在浏览器中点击B站的链接或者在地址栏中输入<code>https://www.bilibili.com</code>，浏览器就会封装好一个用于请求的数据包，然后经过网络发送到B站的服务器。服务器会根据网络层协议，比如HTTP协议，解析我们发送的请求数据包，然后将静态资源（html,css等等）和从数据库取出的数据等资源封装到响应数据包中，然后发送回我们的浏览器，也就是客户端，之后我们就能看到B站的主页页面了：</p>\n<div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.44vbajds3m60.webp\" alt=\"web服务\" style=\"zoom:67%;\" /></div>\n\n<p>以上就是比较典型的web服务过程，当然实际情况要复杂的多，比如在实际地处理客户端（浏览器）数据之前，服务器要和客户端建立连接，这就涉及TCP的三次握手；又比如数据出现差错了怎么办，该怎么校验，怎么解决？又或者是丢包了该怎么办？但这些不是我们在web开发时要考虑的问题，因为这大部分是交给<strong>TCP、HTTP这些网络协议</strong>处理的，在这之上，我们获得的数据还要<strong>经过服务器端程序的一层封装</strong>。</p>\n<h2 id=\"Tomcat简介\"><a href=\"#Tomcat简介\" class=\"headerlink\" title=\"Tomcat简介\"></a>Tomcat简介</h2><p>Tomcat就是前文提到的一种服务器端程序，它实际上是一个<strong>http服务器+servlet容器</strong>。</p>\n<p>作为http服务器，Tomcat为web开发者封装了应用层及其下层的协议，交给开发者的只是<strong>封装好的Request和Response对象</strong>，这样的好处是使得开发者能够更加专注于业务逻辑。</p>\n<p>那么servlet容器又是什么呢？</p>\n<p>前文说了web服务的第三步是调用服务器端的处理程序去处理封装好的Request对象，然后返回响应对象。其实这些处理程序就是Servlet，而Servlet容器就是用来管理Servlet的，<strong>Tomcat的主体就是由连接器和不同种类的Servlet容器建立起来的</strong>，其核心架构如下：</p>\n<div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.25mfalet1zy8.webp\" alt=\"Tomcat架构\" style=\"zoom:80%;\" /></div>\n\n<p>一个web应用可以有多个service，比如支付service，订单处理service等等，而一个service中又有连接器和容器，这个容器就是我们说的<strong>servlet</strong>，它负责处理数据，其结构是像<strong>俄罗斯套娃</strong>一样的；而连接器就负责外部数据和servlet容器的连接，<strong>之前说的封装应用层及其下层协议数据</strong>就是连接器干的活。</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.nibbm6csbsg.webp\" alt=\"servlet层次结构\"></p>\n<p>上图展现了容器的内部结构，一层套一层，大层管理小层，具体细节就不多说了。</p>\n<h1 id=\"Servlet\"><a href=\"#Servlet\" class=\"headerlink\" title=\"Servlet\"></a>Servlet</h1><p>Servlet的本质呢就是一个Java接口，对于这个Servlet接口，会有不同的实现，我们所说的Servlet就是这些不同的实现。典型的Servlet继承关系如下：</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.ehnty66lhp.webp\" alt=\"servlet继承关系\" style=\"zoom:80%;\" /></div>\n\n<p><strong>GenericServlet抽象类</strong>实现了<strong>Servlet接口</strong>，其中核心方法为<strong>init()<strong>、</strong>service()<strong>和</strong>destroy()<strong>，</strong>HttpServlet抽象类</strong>专门用来处理HTTP请求，它继承自<strong>GenericServlet抽象类</strong>，实际上重写了**service()**方法，<font color=purple><strong>在这个service方法里，我们处理客户端发过来的http请求。</strong></font></p>\n<p>一个Web服务的主要三部分就是<strong>接受请求→处理请求→响应请求</strong>。因为<code>处理请求(业务逻辑)</code>是不同的，所以提取出来交给<strong>Servlet</strong>，由程序员来编写业务逻辑；而其它两部分大同小异，所以交给Tomcat里的<strong>连接器组件</strong>干（<strong>解析和封装请求和响应包</strong>）。</p>\n<h2 id=\"Servlet生命周期\"><a href=\"#Servlet生命周期\" class=\"headerlink\" title=\"Servlet生命周期\"></a>Servlet生命周期</h2><p> 说到Servlet就不能不提Servlet的生命周期，一个Servlet的生命周期是<strong>创建</strong>→服务→<strong>销毁</strong>：</p>\n<ul>\n<li>一个Servlet是在被第一次调用时创建，之后服务无数次。</li>\n<li>直到服务器关闭后，才销毁Servlet。</li>\n</ul>\n<p>这就涉及一个问题，<strong>第一个使用Servlet的用户收到响应的时间就会很长</strong>，因为要等对应服务的Servlet启动嘛；如果系统很小，这当然不是事，但是一旦系统变得复杂了，效率就不是很高；解决办法是<u>我们把常用的servlet在服务器启动的时候，就给它启动</u>。</p>\n<h1 id=\"JSP\"><a href=\"#JSP\" class=\"headerlink\" title=\"JSP\"></a>JSP</h1><p>在说JSP之前，我们得知道浏览器上的页面到底是什么东西，实际上一个<strong>静态页面</strong>的主体就是<strong>html + css</strong>，html文件就是给页面上的各种组件布局，css就是定制不同组件的样式，比如颜色啊，位置啊等等，我们的浏览器解析html和css后，就会生成我们看到的页面。所谓的http响应呢，实际上就是服务器发送给客户端浏览器的内容大部分是以html和css为主体的静态资源。</p>\n<p>早期的JAVA WEB开发呢，实际上就是美工把html文件交给程序员，然后程序员用一行行out.println()将html语句拼接起来响应给客户端，其思路就是<font color=purple><strong>用Servlet程序将html代码和处理好的数据拼好再放回去</strong></font>。<u>同时期的PHP呢，搞了一套<strong>在html中嵌入代码来动态生成html内容的方法</strong>，这样就避免了手动print()一行行html的麻烦</u>。</p>\n<p><strong>JSP</strong>呢，就是sun公司仿照PHP，ASP这些工具的思路创建的东西。JSP文件看上去和HTML文件长得差不多，只不过多了一些java代码和不属于html的标签，举个例子：</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsp\">&lt;%@ page contentType=<span class=\"hljs-string\">&quot;text/html;charset=UTF-8&quot;</span> language=<span class=\"hljs-string\">&quot;java&quot;</span> %&gt;<br>&lt;%@ taglib uri=<span class=\"hljs-string\">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class=\"hljs-string\">&quot;c&quot;</span>%&gt;<br>&lt;c:set <span class=\"hljs-keyword\">var</span>=<span class=\"hljs-string\">&quot;user&quot;</span> value=<span class=\"hljs-string\">&quot;$&#123;sessionScope.reader&#125;&quot;</span>&gt;&lt;/c:set&gt;<br>&lt;div class=<span class=\"hljs-string\">&quot;person&quot;</span> &gt;<br>    &lt;link rel=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> href=<span class=\"hljs-string\">&quot;$&#123;pageContext.request.contextPath&#125;/resources/css/person.css&quot;</span>/&gt;<br>&lt;h1&gt;个人信息&lt;/h1&gt;<br>&lt;table &gt;<br>    &lt;tr&gt;<br>        &lt;td class=<span class=\"hljs-string\">&quot;column&quot;</span>&gt;用户名&lt;/td&gt;<br>        &lt;td class=<span class=\"hljs-string\">&quot;value&quot;</span>&gt;<br>            &lt;c:out value=<span class=\"hljs-string\">&quot;$&#123;user.userName&#125;&quot;</span>&gt;&lt;/c:out&gt;<br>        &lt;/td&gt;<br>    &lt;/tr&gt;<br>    &lt;tr&gt;<br>        &lt;td class=<span class=\"hljs-string\">&quot;column&quot;</span>&gt;用户类型&lt;/td&gt;<br>        &lt;td class=<span class=\"hljs-string\">&quot;value&quot;</span>&gt;<br>            &lt;c:<span class=\"hljs-keyword\">if</span> test=<span class=\"hljs-string\">&quot;$&#123;user.userType==&#x27;admin&#x27;&#125;&quot;</span> <span class=\"hljs-keyword\">var</span>=<span class=\"hljs-string\">&quot;result&quot;</span>&gt;<br>                &lt;c:out value=<span class=\"hljs-string\">&quot;管理员&quot;</span>&gt;&lt;/c:out&gt;<br>            &lt;/c:<span class=\"hljs-keyword\">if</span>&gt;<br>            &lt;c:<span class=\"hljs-keyword\">if</span> test=<span class=\"hljs-string\">&quot;$&#123;user.userType==&#x27;reader&#x27;&#125;&quot;</span> <span class=\"hljs-keyword\">var</span>=<span class=\"hljs-string\">&quot;result&quot;</span>&gt;<br>                &lt;c:out value=<span class=\"hljs-string\">&quot;读者&quot;</span>&gt;&lt;/c:out&gt;<br>            &lt;/c:<span class=\"hljs-keyword\">if</span>&gt;<br>        &lt;/td&gt;<br>    &lt;/tr&gt;<br>    &lt;tr&gt;<br>        &lt;td class=<span class=\"hljs-string\">&quot;column&quot;</span>&gt;用户密码&lt;/td&gt;<br>        &lt;td class=<span class=\"hljs-string\">&quot;value&quot;</span>&gt;<br>      \t\t &lt;c:out value=<span class=\"hljs-string\">&quot;$&#123;user.passwd&#125;&quot;</span>&gt;&lt;/c:out&gt;<br>        &lt;/td&gt;<br>    &lt;/tr&gt;<br>        &lt;c:<span class=\"hljs-keyword\">if</span> test=<span class=\"hljs-string\">&quot;$&#123;user.userType==&#x27;reader&#x27;&#125;&quot;</span> <span class=\"hljs-keyword\">var</span>=<span class=\"hljs-string\">&quot;res&quot;</span>&gt;<br>            &lt;tr&gt;<br>                &lt;td class=<span class=\"hljs-string\">&quot;column&quot;</span>&gt;借阅中数量&lt;/td&gt;<br>                &lt;td class=<span class=\"hljs-string\">&quot;value&quot;</span>&gt;<br>                    &lt;c:out value=<span class=\"hljs-string\">&quot;$&#123;user.rendingCount&#125;&quot;</span>&gt;&lt;/c:out&gt;<br>                &lt;/td&gt;<br>            &lt;/tr&gt;<br>            &lt;tr&gt;<br>                &lt;td class=<span class=\"hljs-string\">&quot;column&quot;</span>&gt;总借阅数&lt;/td&gt;<br>                &lt;td class=<span class=\"hljs-string\">&quot;value&quot;</span>&gt;<br>                    &lt;c:out value=<span class=\"hljs-string\">&quot;$&#123;user.havaRendCount&#125;&quot;</span>&gt;&lt;/c:out&gt;<br>                &lt;/td&gt;<br>            &lt;/tr&gt;<br>        &lt;/c:<span class=\"hljs-keyword\">if</span>&gt;<br>&lt;/table&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>\n\n<p>这就是一个jsp文件，其实jsp就是由<strong>html+Java代码</strong>组成的，那为什么上面的jsp文件中没有出现java代码呢？这是因为java代码被jsp标签取代了，jsp标签实际上就是封装好的java代码，因此实际上jsp标签还是java代码，只不过推荐使用这种写法。</p>\n<p>虽然格式上jsp和html差不多，但实际上两者根本不是一回事，<strong>jsp实际上是一个servlet，是在服务器端发挥作用的，而不是像html在浏览器展示数据的</strong>。你servlet不是每次都要一行行println那些html文件吗？那多麻烦啊是不是，你直接把代码写在html里，由服务器来帮你解析成servlet，这样不就省事多了吗？</p>\n<p>所以jsp本质上呢是servlet代码的简便写法，方便我们把动态数据嵌入到静态的html中，具体的servlet代码交给服务器里专门的jsp处理程序生成，其最后返回给客户端的，还是一个html静态资源。</p>\n","site":{"data":{}},"more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近两周在学习Java Web，从了解Tomcat开始，再到学习Servlet，前端三件套等等，这个过程中我学习到了许多知识，也引发了我的一些思考，我认为有必要将这些思考记录下来，<strong>技术总是会过时的，但技术背后的思想不会那么快过时</strong>，而思考能帮助我理解这些技术背后的思想，因此有必要将这些思考记录下来。</p>\n<h1 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h1><h2 id=\"web服务简介\"><a href=\"#web服务简介\" class=\"headerlink\" title=\"web服务简介\"></a>web服务简介</h2><p>目前大部分的web服务是以<strong>TCP/IP+HTTP协议</strong>为基础的，那么这样的一个web服务到底是怎样的工作流程呢？</p>\n<p>我们拿B站举例，假设我们在浏览器中点击B站的链接或者在地址栏中输入<code>https://www.bilibili.com</code>，浏览器就会封装好一个用于请求的数据包，然后经过网络发送到B站的服务器。服务器会根据网络层协议，比如HTTP协议，解析我们发送的请求数据包，然后将静态资源（html,css等等）和从数据库取出的数据等资源封装到响应数据包中，然后发送回我们的浏览器，也就是客户端，之后我们就能看到B站的主页页面了：</p>\n<div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.44vbajds3m60.webp\" alt=\"web服务\" style=\"zoom:67%;\" /></div>\n\n<p>以上就是比较典型的web服务过程，当然实际情况要复杂的多，比如在实际地处理客户端（浏览器）数据之前，服务器要和客户端建立连接，这就涉及TCP的三次握手；又比如数据出现差错了怎么办，该怎么校验，怎么解决？又或者是丢包了该怎么办？但这些不是我们在web开发时要考虑的问题，因为这大部分是交给<strong>TCP、HTTP这些网络协议</strong>处理的，在这之上，我们获得的数据还要<strong>经过服务器端程序的一层封装</strong>。</p>\n<h2 id=\"Tomcat简介\"><a href=\"#Tomcat简介\" class=\"headerlink\" title=\"Tomcat简介\"></a>Tomcat简介</h2><p>Tomcat就是前文提到的一种服务器端程序，它实际上是一个<strong>http服务器+servlet容器</strong>。</p>\n<p>作为http服务器，Tomcat为web开发者封装了应用层及其下层的协议，交给开发者的只是<strong>封装好的Request和Response对象</strong>，这样的好处是使得开发者能够更加专注于业务逻辑。</p>\n<p>那么servlet容器又是什么呢？</p>\n<p>前文说了web服务的第三步是调用服务器端的处理程序去处理封装好的Request对象，然后返回响应对象。其实这些处理程序就是Servlet，而Servlet容器就是用来管理Servlet的，<strong>Tomcat的主体就是由连接器和不同种类的Servlet容器建立起来的</strong>，其核心架构如下：</p>\n<div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.25mfalet1zy8.webp\" alt=\"Tomcat架构\" style=\"zoom:80%;\" /></div>\n\n<p>一个web应用可以有多个service，比如支付service，订单处理service等等，而一个service中又有连接器和容器，这个容器就是我们说的<strong>servlet</strong>，它负责处理数据，其结构是像<strong>俄罗斯套娃</strong>一样的；而连接器就负责外部数据和servlet容器的连接，<strong>之前说的封装应用层及其下层协议数据</strong>就是连接器干的活。</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.nibbm6csbsg.webp\" alt=\"servlet层次结构\"></p>\n<p>上图展现了容器的内部结构，一层套一层，大层管理小层，具体细节就不多说了。</p>\n<h1 id=\"Servlet\"><a href=\"#Servlet\" class=\"headerlink\" title=\"Servlet\"></a>Servlet</h1><p>Servlet的本质呢就是一个Java接口，对于这个Servlet接口，会有不同的实现，我们所说的Servlet就是这些不同的实现。典型的Servlet继承关系如下：</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.ehnty66lhp.webp\" alt=\"servlet继承关系\" style=\"zoom:80%;\" /></div>\n\n<p><strong>GenericServlet抽象类</strong>实现了<strong>Servlet接口</strong>，其中核心方法为<strong>init()<strong>、</strong>service()<strong>和</strong>destroy()<strong>，</strong>HttpServlet抽象类</strong>专门用来处理HTTP请求，它继承自<strong>GenericServlet抽象类</strong>，实际上重写了**service()**方法，<font color=purple><strong>在这个service方法里，我们处理客户端发过来的http请求。</strong></font></p>\n<p>一个Web服务的主要三部分就是<strong>接受请求→处理请求→响应请求</strong>。因为<code>处理请求(业务逻辑)</code>是不同的，所以提取出来交给<strong>Servlet</strong>，由程序员来编写业务逻辑；而其它两部分大同小异，所以交给Tomcat里的<strong>连接器组件</strong>干（<strong>解析和封装请求和响应包</strong>）。</p>\n<h2 id=\"Servlet生命周期\"><a href=\"#Servlet生命周期\" class=\"headerlink\" title=\"Servlet生命周期\"></a>Servlet生命周期</h2><p> 说到Servlet就不能不提Servlet的生命周期，一个Servlet的生命周期是<strong>创建</strong>→服务→<strong>销毁</strong>：</p>\n<ul>\n<li>一个Servlet是在被第一次调用时创建，之后服务无数次。</li>\n<li>直到服务器关闭后，才销毁Servlet。</li>\n</ul>\n<p>这就涉及一个问题，<strong>第一个使用Servlet的用户收到响应的时间就会很长</strong>，因为要等对应服务的Servlet启动嘛；如果系统很小，这当然不是事，但是一旦系统变得复杂了，效率就不是很高；解决办法是<u>我们把常用的servlet在服务器启动的时候，就给它启动</u>。</p>\n<h1 id=\"JSP\"><a href=\"#JSP\" class=\"headerlink\" title=\"JSP\"></a>JSP</h1><p>在说JSP之前，我们得知道浏览器上的页面到底是什么东西，实际上一个<strong>静态页面</strong>的主体就是<strong>html + css</strong>，html文件就是给页面上的各种组件布局，css就是定制不同组件的样式，比如颜色啊，位置啊等等，我们的浏览器解析html和css后，就会生成我们看到的页面。所谓的http响应呢，实际上就是服务器发送给客户端浏览器的内容大部分是以html和css为主体的静态资源。</p>\n<p>早期的JAVA WEB开发呢，实际上就是美工把html文件交给程序员，然后程序员用一行行out.println()将html语句拼接起来响应给客户端，其思路就是<font color=purple><strong>用Servlet程序将html代码和处理好的数据拼好再放回去</strong></font>。<u>同时期的PHP呢，搞了一套<strong>在html中嵌入代码来动态生成html内容的方法</strong>，这样就避免了手动print()一行行html的麻烦</u>。</p>\n<p><strong>JSP</strong>呢，就是sun公司仿照PHP，ASP这些工具的思路创建的东西。JSP文件看上去和HTML文件长得差不多，只不过多了一些java代码和不属于html的标签，举个例子：</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsp\">&lt;%@ page contentType=<span class=\"hljs-string\">&quot;text/html;charset=UTF-8&quot;</span> language=<span class=\"hljs-string\">&quot;java&quot;</span> %&gt;<br>&lt;%@ taglib uri=<span class=\"hljs-string\">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class=\"hljs-string\">&quot;c&quot;</span>%&gt;<br>&lt;c:set <span class=\"hljs-keyword\">var</span>=<span class=\"hljs-string\">&quot;user&quot;</span> value=<span class=\"hljs-string\">&quot;$&#123;sessionScope.reader&#125;&quot;</span>&gt;&lt;/c:set&gt;<br>&lt;div class=<span class=\"hljs-string\">&quot;person&quot;</span> &gt;<br>    &lt;link rel=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> href=<span class=\"hljs-string\">&quot;$&#123;pageContext.request.contextPath&#125;/resources/css/person.css&quot;</span>/&gt;<br>&lt;h1&gt;个人信息&lt;/h1&gt;<br>&lt;table &gt;<br>    &lt;tr&gt;<br>        &lt;td class=<span class=\"hljs-string\">&quot;column&quot;</span>&gt;用户名&lt;/td&gt;<br>        &lt;td class=<span class=\"hljs-string\">&quot;value&quot;</span>&gt;<br>            &lt;c:out value=<span class=\"hljs-string\">&quot;$&#123;user.userName&#125;&quot;</span>&gt;&lt;/c:out&gt;<br>        &lt;/td&gt;<br>    &lt;/tr&gt;<br>    &lt;tr&gt;<br>        &lt;td class=<span class=\"hljs-string\">&quot;column&quot;</span>&gt;用户类型&lt;/td&gt;<br>        &lt;td class=<span class=\"hljs-string\">&quot;value&quot;</span>&gt;<br>            &lt;c:<span class=\"hljs-keyword\">if</span> test=<span class=\"hljs-string\">&quot;$&#123;user.userType==&#x27;admin&#x27;&#125;&quot;</span> <span class=\"hljs-keyword\">var</span>=<span class=\"hljs-string\">&quot;result&quot;</span>&gt;<br>                &lt;c:out value=<span class=\"hljs-string\">&quot;管理员&quot;</span>&gt;&lt;/c:out&gt;<br>            &lt;/c:<span class=\"hljs-keyword\">if</span>&gt;<br>            &lt;c:<span class=\"hljs-keyword\">if</span> test=<span class=\"hljs-string\">&quot;$&#123;user.userType==&#x27;reader&#x27;&#125;&quot;</span> <span class=\"hljs-keyword\">var</span>=<span class=\"hljs-string\">&quot;result&quot;</span>&gt;<br>                &lt;c:out value=<span class=\"hljs-string\">&quot;读者&quot;</span>&gt;&lt;/c:out&gt;<br>            &lt;/c:<span class=\"hljs-keyword\">if</span>&gt;<br>        &lt;/td&gt;<br>    &lt;/tr&gt;<br>    &lt;tr&gt;<br>        &lt;td class=<span class=\"hljs-string\">&quot;column&quot;</span>&gt;用户密码&lt;/td&gt;<br>        &lt;td class=<span class=\"hljs-string\">&quot;value&quot;</span>&gt;<br>      \t\t &lt;c:out value=<span class=\"hljs-string\">&quot;$&#123;user.passwd&#125;&quot;</span>&gt;&lt;/c:out&gt;<br>        &lt;/td&gt;<br>    &lt;/tr&gt;<br>        &lt;c:<span class=\"hljs-keyword\">if</span> test=<span class=\"hljs-string\">&quot;$&#123;user.userType==&#x27;reader&#x27;&#125;&quot;</span> <span class=\"hljs-keyword\">var</span>=<span class=\"hljs-string\">&quot;res&quot;</span>&gt;<br>            &lt;tr&gt;<br>                &lt;td class=<span class=\"hljs-string\">&quot;column&quot;</span>&gt;借阅中数量&lt;/td&gt;<br>                &lt;td class=<span class=\"hljs-string\">&quot;value&quot;</span>&gt;<br>                    &lt;c:out value=<span class=\"hljs-string\">&quot;$&#123;user.rendingCount&#125;&quot;</span>&gt;&lt;/c:out&gt;<br>                &lt;/td&gt;<br>            &lt;/tr&gt;<br>            &lt;tr&gt;<br>                &lt;td class=<span class=\"hljs-string\">&quot;column&quot;</span>&gt;总借阅数&lt;/td&gt;<br>                &lt;td class=<span class=\"hljs-string\">&quot;value&quot;</span>&gt;<br>                    &lt;c:out value=<span class=\"hljs-string\">&quot;$&#123;user.havaRendCount&#125;&quot;</span>&gt;&lt;/c:out&gt;<br>                &lt;/td&gt;<br>            &lt;/tr&gt;<br>        &lt;/c:<span class=\"hljs-keyword\">if</span>&gt;<br>&lt;/table&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>\n\n<p>这就是一个jsp文件，其实jsp就是由<strong>html+Java代码</strong>组成的，那为什么上面的jsp文件中没有出现java代码呢？这是因为java代码被jsp标签取代了，jsp标签实际上就是封装好的java代码，因此实际上jsp标签还是java代码，只不过推荐使用这种写法。</p>\n<p>虽然格式上jsp和html差不多，但实际上两者根本不是一回事，<strong>jsp实际上是一个servlet，是在服务器端发挥作用的，而不是像html在浏览器展示数据的</strong>。你servlet不是每次都要一行行println那些html文件吗？那多麻烦啊是不是，你直接把代码写在html里，由服务器来帮你解析成servlet，这样不就省事多了吗？</p>\n<p>所以jsp本质上呢是servlet代码的简便写法，方便我们把动态数据嵌入到静态的html中，具体的servlet代码交给服务器里专门的jsp处理程序生成，其最后返回给客户端的，还是一个html静态资源。</p>\n"},{"title":"java多态与动态绑定","date":"2022-10-16T03:44:09.000Z","banner_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.tc1jjbxpfmo.webp","index_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.tc1jjbxpfmo.webp","excerpt":"介绍多态机制以及java的实现","_content":"\n# 面向对象基础\n\n我们先来聊聊什么是`面向对象（OOP）`。编程语言干的活绝大部分是<u>将实际的问题映射到机器模型之中</u>，而映射问题的思路是五花八门的。<u>面向对象</u>的基本思路就是**用编程语言去表达实际问题的元素，围绕这些元素进行操作**，这些元素在java中就被称为`对象`。\n\n比如说我现在要用OOP的思想去描述一个苹果，那么我会说：这个苹果的ID=xxxxx，颜色=红色，种类=红富士，产地=某地，是否打过药=是，除此之外，我还会围绕这个苹果进行操作，比如把它卖给张三，又比如吃掉它，这就是一个**为实际问题的元素建立对象的过程**。像什么苹果的ID、颜色、产地等等都是这个对象的<u>状态（属性）</u>，而被卖掉或者是被吃掉就是这个对象的行为，每个对象是不同的，因此对象还有自己唯一的<u>标识</u>。\n\n> **对象的定义**：一个对象具有自己的状态，行为和标识。这意味着对象有自己的内部数据(提供状态)、方法 (产生行为)，并彼此区分（每个对象在内存中都有唯一的地址）\n\n一个苹果对象很好管理，那如果是成百上千的苹果对象呢？难道要一个个的给它们建立对象吗？这显然不现实，这就要提到`类(class)`的概念。一个地方产的苹果往往有许多特征是一样的，比如产地啊，种类啊，是否打过药啊，那么我们就可以将其**抽象**为一个类，比如`张三果园苹果`，**对象都从这个类生成，进行自己个性化的定制**。\n\n我们使用<u>类</u>来将一个对象的各种内部数据和行为封装在一起，以此来表达实际问题的元素。但有一个问题没有解决：<u>如果我们现在有一批`杰克果园苹果`，是从外国进口的，这个时候再创建一个新类也太麻烦了吧？</u>\n\n比较好的解决办法是什么呢？<u>我们不创建`张三果园苹果类`了，而是创建一个`苹果类`（**注意不是苹果对象**），其属性和行为和``张三果园苹果类`差不多，但是多个`果园名称`属性，然后张三果园和杰克果园产的苹果都<font color=purple>**继承**</font>自这个苹果类。</u>什么是继承呢，也就是**is a**的关系，杰克产的苹果是苹果，张三产的苹果也是苹果，他们都有苹果类的属性和行为，除此之外，还可以定制自己苹果的属性和行为。\n\n以上的概念呢十分基础，但是还是要理理清的。\n\n# 什么是多态\n\n我们常常听到：<u>对象是类的实例化</u>，什么意思呢？打个比方，我们正在为一批刚摘下来的水果设定属性，我们操作的是真真正正的苹果，也就是苹果对象1，苹果对象2，苹果对象3，苹果对象4这样一个个数过来的，但是设定属性时，是根据苹果类一批次设定的，而不管它是苹果对象几。\n\n拓展一下思路，实际上**我们处理对象，不仅不把它看成是其所属的类，还看成其所属的基类**。假如有一个水果类，其下面有苹果子类，香蕉子类，西瓜子类等等，<font color=purple>我们设定一个eat**方法**，我们就不需要知道其是什么水果类型，反正是水果都能吃</font>。这就是**多态**的思想，那么多态有什么好处呢？\n\n我们来举个例子，如果Java不支持多态，水果们应该这些写：\n\n```java\nclass Fruit{\n    int id;\n    String name;\n    String color;\n    String origin;\n   \t\n    void setOrigin(String origin);\n    void setColor(String color);\n    \n}\n\nclass Apple extends fruit{\n    void eatApple();\n}\n\nclass Watermelon extends fruit{\n    void eatWatermelon();\n}\n\nclass Banana extends banana{\n    void eatBanana();\n}\n```\n\n如果我们要吃个水果，每个水果类里都要定义一遍，如果调用这些方法，就会是下面这样：\n\n```java\nviod main(){\n     Apple apple = new Apple();\n    Watermelon watermelon = new Watermelon();\n    //吃苹果\n    apple.eatApple();\n    //吃西瓜\n   Watermelon.eatWatermelon();\n}\n```\n\n如果使用多态的思想，编写的水果类会是下面这样：\n\n```java\nclass Fruit{\n    ...\n    void eatFruit();\n}\n\nclass Apple extends fruit{\n    //不需要定义自己的方法\n}\n\nclass Watermelon extends fruit{\n   \n}\n\nclass Banana extends banana{\n    \n}\n```\n\n现在吃水果的话：\n\n```java\nviod main(){\n    Fruit apple = new Apple();\n    Fruit watermelon = new Watermelon();\n    //吃苹果\n    apple.eatFruit();\n    //吃西瓜\n   Watermelon.eatFruit();\n}\n```\n\n多态这层抽象使得软件系统更加好维护，可扩展性更强，加一个西瓜不需要我们再去加一个吃西瓜的方法，直接使用`eatFruit`方法就可以了。\n\n# 重写(override)和重载(overload)\n\n> - **重写(override)**：**子类对父类**方法的实现过程进行重新编写，但是**方法名，参数的类型和顺序是一样的**，和<u>多态</u>有关。\n> - **重载(overload)**：**在一个类里面**，方法名相同，但是参数不同，比较常用的是构造器重载。\n\n分清重写和重载的区别是很重要的，重写和本篇的主题多态有关，因为其涉及父子类相同的方法。举个例子，如果我们想定义自己吃苹果的方法，在java中就可以这么写：\n\n```java\nclass Fruit{\n    ...\n    void eatFruit();\n}\n\nclass Apple extends fruit{\n    @override\n    void eatFruit(){\n        print(\"这是李四吃苹果的方法\");\n    }\n}\n\nclass Watermelon extends fruit{\n\n}\n\nclass Banana extends banana{\n    \n}\n```\n\n这就是多态中的override，这也引出一个核心问题：<font color=purple>计算机怎么知道我们要调用的是父类还是子类的方法呢？</font>这就要说到<u>绑定</u>的问题了。\n\n# 多态在JAVA的实现\n\n## 静态绑定和动态绑定\n\n> **绑定**：将一个方法的调用和一个方法的主体关联起来，比如将eatFruit()方法和apple关联起来。\n\n绑定分为**静态绑定**和**动态绑定**。\n\n先来说说静态绑定，所谓的静态绑定<font color=purple>就是在**编译期**就进行方法和类的绑定</font>，一般用于<u>访问对象的属性</u>或者是<u>final、static和private修饰的方法</u>，这类方法的特征就是**确定无疑**。\n\n动态绑定，就是<font color=purple>该对象的真实类型只有**运行时**才能确定，所以调用到的方法是运行时对象真实类型的方法</font>，在java中，除了静态绑定中提到的情况，其它都是动态绑定。\n\n重写(override)就是动态绑定，也就是运行时绑定；重载(overload)就是静态绑定，也就是编译时绑定。\n\n## 动态绑定实现多态\n\n首先举一个经典例子,下面调用的是apple的方法还是基类Fruit的方法：\n\n```java\nviod main(){\n    // apple实现了自己的eatFruit方法\n    Fruit apple = new Apple();\n    \n    apple.eatFruit();\n   \t\n}\n```\n\n因为子类apple定义了自己的eatFruit，所以调用的是apple的方法。由此可以看出，<u>当通过子类的实例去调用一系列的实例方法（包括一个方法调用的另一个方法）时，将优先和子类本身包含的实例方法动态绑定，如果子类没有定义这个实例方法，才会和从父类中继承来的实例方法动态绑定</u>。\n\nJVM在准备阶段会生成一个<u>方法表</u>，里面存储着每个类的**每个方法对应的内存地址**，子类方法表中的方法包含父类的所有方法， 且**每个方法和父类方法的索引值（方法在方法表中的位置）相同**。比如父类Fruit的方法eatFruit的索引号是1，Apple子类如果没有重写该方法，那么该索引号1指向的就是父类Fruit的eatFruit；如果其重写了该方法，那么Apple子类方法表中的索引号1就指向自己的eatFruit。\n\n在动态绑定的时，JVM会先根据动态类型获取对应类的方法表，再根据索引获取方法表中对应方法的内存地址。","source":"_posts/java中的多态和多态绑定.md","raw":"---\ntitle: java多态与动态绑定\ndate: 2022-10-16 11:44:09\ntags:\n- java\n- OOP\ncategories:\n- java\nbanner_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.tc1jjbxpfmo.webp\nindex_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.tc1jjbxpfmo.webp\nexcerpt: 介绍多态机制以及java的实现\n---\n\n# 面向对象基础\n\n我们先来聊聊什么是`面向对象（OOP）`。编程语言干的活绝大部分是<u>将实际的问题映射到机器模型之中</u>，而映射问题的思路是五花八门的。<u>面向对象</u>的基本思路就是**用编程语言去表达实际问题的元素，围绕这些元素进行操作**，这些元素在java中就被称为`对象`。\n\n比如说我现在要用OOP的思想去描述一个苹果，那么我会说：这个苹果的ID=xxxxx，颜色=红色，种类=红富士，产地=某地，是否打过药=是，除此之外，我还会围绕这个苹果进行操作，比如把它卖给张三，又比如吃掉它，这就是一个**为实际问题的元素建立对象的过程**。像什么苹果的ID、颜色、产地等等都是这个对象的<u>状态（属性）</u>，而被卖掉或者是被吃掉就是这个对象的行为，每个对象是不同的，因此对象还有自己唯一的<u>标识</u>。\n\n> **对象的定义**：一个对象具有自己的状态，行为和标识。这意味着对象有自己的内部数据(提供状态)、方法 (产生行为)，并彼此区分（每个对象在内存中都有唯一的地址）\n\n一个苹果对象很好管理，那如果是成百上千的苹果对象呢？难道要一个个的给它们建立对象吗？这显然不现实，这就要提到`类(class)`的概念。一个地方产的苹果往往有许多特征是一样的，比如产地啊，种类啊，是否打过药啊，那么我们就可以将其**抽象**为一个类，比如`张三果园苹果`，**对象都从这个类生成，进行自己个性化的定制**。\n\n我们使用<u>类</u>来将一个对象的各种内部数据和行为封装在一起，以此来表达实际问题的元素。但有一个问题没有解决：<u>如果我们现在有一批`杰克果园苹果`，是从外国进口的，这个时候再创建一个新类也太麻烦了吧？</u>\n\n比较好的解决办法是什么呢？<u>我们不创建`张三果园苹果类`了，而是创建一个`苹果类`（**注意不是苹果对象**），其属性和行为和``张三果园苹果类`差不多，但是多个`果园名称`属性，然后张三果园和杰克果园产的苹果都<font color=purple>**继承**</font>自这个苹果类。</u>什么是继承呢，也就是**is a**的关系，杰克产的苹果是苹果，张三产的苹果也是苹果，他们都有苹果类的属性和行为，除此之外，还可以定制自己苹果的属性和行为。\n\n以上的概念呢十分基础，但是还是要理理清的。\n\n# 什么是多态\n\n我们常常听到：<u>对象是类的实例化</u>，什么意思呢？打个比方，我们正在为一批刚摘下来的水果设定属性，我们操作的是真真正正的苹果，也就是苹果对象1，苹果对象2，苹果对象3，苹果对象4这样一个个数过来的，但是设定属性时，是根据苹果类一批次设定的，而不管它是苹果对象几。\n\n拓展一下思路，实际上**我们处理对象，不仅不把它看成是其所属的类，还看成其所属的基类**。假如有一个水果类，其下面有苹果子类，香蕉子类，西瓜子类等等，<font color=purple>我们设定一个eat**方法**，我们就不需要知道其是什么水果类型，反正是水果都能吃</font>。这就是**多态**的思想，那么多态有什么好处呢？\n\n我们来举个例子，如果Java不支持多态，水果们应该这些写：\n\n```java\nclass Fruit{\n    int id;\n    String name;\n    String color;\n    String origin;\n   \t\n    void setOrigin(String origin);\n    void setColor(String color);\n    \n}\n\nclass Apple extends fruit{\n    void eatApple();\n}\n\nclass Watermelon extends fruit{\n    void eatWatermelon();\n}\n\nclass Banana extends banana{\n    void eatBanana();\n}\n```\n\n如果我们要吃个水果，每个水果类里都要定义一遍，如果调用这些方法，就会是下面这样：\n\n```java\nviod main(){\n     Apple apple = new Apple();\n    Watermelon watermelon = new Watermelon();\n    //吃苹果\n    apple.eatApple();\n    //吃西瓜\n   Watermelon.eatWatermelon();\n}\n```\n\n如果使用多态的思想，编写的水果类会是下面这样：\n\n```java\nclass Fruit{\n    ...\n    void eatFruit();\n}\n\nclass Apple extends fruit{\n    //不需要定义自己的方法\n}\n\nclass Watermelon extends fruit{\n   \n}\n\nclass Banana extends banana{\n    \n}\n```\n\n现在吃水果的话：\n\n```java\nviod main(){\n    Fruit apple = new Apple();\n    Fruit watermelon = new Watermelon();\n    //吃苹果\n    apple.eatFruit();\n    //吃西瓜\n   Watermelon.eatFruit();\n}\n```\n\n多态这层抽象使得软件系统更加好维护，可扩展性更强，加一个西瓜不需要我们再去加一个吃西瓜的方法，直接使用`eatFruit`方法就可以了。\n\n# 重写(override)和重载(overload)\n\n> - **重写(override)**：**子类对父类**方法的实现过程进行重新编写，但是**方法名，参数的类型和顺序是一样的**，和<u>多态</u>有关。\n> - **重载(overload)**：**在一个类里面**，方法名相同，但是参数不同，比较常用的是构造器重载。\n\n分清重写和重载的区别是很重要的，重写和本篇的主题多态有关，因为其涉及父子类相同的方法。举个例子，如果我们想定义自己吃苹果的方法，在java中就可以这么写：\n\n```java\nclass Fruit{\n    ...\n    void eatFruit();\n}\n\nclass Apple extends fruit{\n    @override\n    void eatFruit(){\n        print(\"这是李四吃苹果的方法\");\n    }\n}\n\nclass Watermelon extends fruit{\n\n}\n\nclass Banana extends banana{\n    \n}\n```\n\n这就是多态中的override，这也引出一个核心问题：<font color=purple>计算机怎么知道我们要调用的是父类还是子类的方法呢？</font>这就要说到<u>绑定</u>的问题了。\n\n# 多态在JAVA的实现\n\n## 静态绑定和动态绑定\n\n> **绑定**：将一个方法的调用和一个方法的主体关联起来，比如将eatFruit()方法和apple关联起来。\n\n绑定分为**静态绑定**和**动态绑定**。\n\n先来说说静态绑定，所谓的静态绑定<font color=purple>就是在**编译期**就进行方法和类的绑定</font>，一般用于<u>访问对象的属性</u>或者是<u>final、static和private修饰的方法</u>，这类方法的特征就是**确定无疑**。\n\n动态绑定，就是<font color=purple>该对象的真实类型只有**运行时**才能确定，所以调用到的方法是运行时对象真实类型的方法</font>，在java中，除了静态绑定中提到的情况，其它都是动态绑定。\n\n重写(override)就是动态绑定，也就是运行时绑定；重载(overload)就是静态绑定，也就是编译时绑定。\n\n## 动态绑定实现多态\n\n首先举一个经典例子,下面调用的是apple的方法还是基类Fruit的方法：\n\n```java\nviod main(){\n    // apple实现了自己的eatFruit方法\n    Fruit apple = new Apple();\n    \n    apple.eatFruit();\n   \t\n}\n```\n\n因为子类apple定义了自己的eatFruit，所以调用的是apple的方法。由此可以看出，<u>当通过子类的实例去调用一系列的实例方法（包括一个方法调用的另一个方法）时，将优先和子类本身包含的实例方法动态绑定，如果子类没有定义这个实例方法，才会和从父类中继承来的实例方法动态绑定</u>。\n\nJVM在准备阶段会生成一个<u>方法表</u>，里面存储着每个类的**每个方法对应的内存地址**，子类方法表中的方法包含父类的所有方法， 且**每个方法和父类方法的索引值（方法在方法表中的位置）相同**。比如父类Fruit的方法eatFruit的索引号是1，Apple子类如果没有重写该方法，那么该索引号1指向的就是父类Fruit的eatFruit；如果其重写了该方法，那么Apple子类方法表中的索引号1就指向自己的eatFruit。\n\n在动态绑定的时，JVM会先根据动态类型获取对应类的方法表，再根据索引获取方法表中对应方法的内存地址。","slug":"java中的多态和多态绑定","published":1,"updated":"2022-10-21T13:31:17.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ij7evq0000j4ru8z5h6ldz","content":"<h1 id=\"面向对象基础\"><a href=\"#面向对象基础\" class=\"headerlink\" title=\"面向对象基础\"></a>面向对象基础</h1><p>我们先来聊聊什么是<code>面向对象（OOP）</code>。编程语言干的活绝大部分是<u>将实际的问题映射到机器模型之中</u>，而映射问题的思路是五花八门的。<u>面向对象</u>的基本思路就是<strong>用编程语言去表达实际问题的元素，围绕这些元素进行操作</strong>，这些元素在java中就被称为<code>对象</code>。</p>\n<p>比如说我现在要用OOP的思想去描述一个苹果，那么我会说：这个苹果的ID=xxxxx，颜色=红色，种类=红富士，产地=某地，是否打过药=是，除此之外，我还会围绕这个苹果进行操作，比如把它卖给张三，又比如吃掉它，这就是一个<strong>为实际问题的元素建立对象的过程</strong>。像什么苹果的ID、颜色、产地等等都是这个对象的<u>状态（属性）</u>，而被卖掉或者是被吃掉就是这个对象的行为，每个对象是不同的，因此对象还有自己唯一的<u>标识</u>。</p>\n<blockquote>\n<p><strong>对象的定义</strong>：一个对象具有自己的状态，行为和标识。这意味着对象有自己的内部数据(提供状态)、方法 (产生行为)，并彼此区分（每个对象在内存中都有唯一的地址）</p>\n</blockquote>\n<p>一个苹果对象很好管理，那如果是成百上千的苹果对象呢？难道要一个个的给它们建立对象吗？这显然不现实，这就要提到<code>类(class)</code>的概念。一个地方产的苹果往往有许多特征是一样的，比如产地啊，种类啊，是否打过药啊，那么我们就可以将其<strong>抽象</strong>为一个类，比如<code>张三果园苹果</code>，<strong>对象都从这个类生成，进行自己个性化的定制</strong>。</p>\n<p>我们使用<u>类</u>来将一个对象的各种内部数据和行为封装在一起，以此来表达实际问题的元素。但有一个问题没有解决：<u>如果我们现在有一批<code>杰克果园苹果</code>，是从外国进口的，这个时候再创建一个新类也太麻烦了吧？</u></p>\n<p>比较好的解决办法是什么呢？<u>我们不创建<code>张三果园苹果类</code>了，而是创建一个<code>苹果类</code>（<strong>注意不是苹果对象</strong>），其属性和行为和``张三果园苹果类<code>差不多，但是多个</code>果园名称`属性，然后张三果园和杰克果园产的苹果都<font color=purple><strong>继承</strong></font>自这个苹果类。</u>什么是继承呢，也就是<strong>is a</strong>的关系，杰克产的苹果是苹果，张三产的苹果也是苹果，他们都有苹果类的属性和行为，除此之外，还可以定制自己苹果的属性和行为。</p>\n<p>以上的概念呢十分基础，但是还是要理理清的。</p>\n<h1 id=\"什么是多态\"><a href=\"#什么是多态\" class=\"headerlink\" title=\"什么是多态\"></a>什么是多态</h1><p>我们常常听到：<u>对象是类的实例化</u>，什么意思呢？打个比方，我们正在为一批刚摘下来的水果设定属性，我们操作的是真真正正的苹果，也就是苹果对象1，苹果对象2，苹果对象3，苹果对象4这样一个个数过来的，但是设定属性时，是根据苹果类一批次设定的，而不管它是苹果对象几。</p>\n<p>拓展一下思路，实际上<strong>我们处理对象，不仅不把它看成是其所属的类，还看成其所属的基类</strong>。假如有一个水果类，其下面有苹果子类，香蕉子类，西瓜子类等等，<font color=purple>我们设定一个eat<strong>方法</strong>，我们就不需要知道其是什么水果类型，反正是水果都能吃</font>。这就是<strong>多态</strong>的思想，那么多态有什么好处呢？</p>\n<p>我们来举个例子，如果Java不支持多态，水果们应该这些写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Fruit</span>&#123;<br>    <span class=\"hljs-type\">int</span> id;<br>    String name;<br>    String color;<br>    String origin;<br>   \t<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setOrigin</span><span class=\"hljs-params\">(String origin)</span>;<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setColor</span><span class=\"hljs-params\">(String color)</span>;<br>    <br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Apple</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">fruit</span>&#123;<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatApple</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Watermelon</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">fruit</span>&#123;<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatWatermelon</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Banana</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">banana</span>&#123;<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatBanana</span><span class=\"hljs-params\">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果我们要吃个水果，每个水果类里都要定义一遍，如果调用这些方法，就会是下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">viod <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>&#123;<br>     <span class=\"hljs-type\">Apple</span> <span class=\"hljs-variable\">apple</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Apple</span>();<br>    <span class=\"hljs-type\">Watermelon</span> <span class=\"hljs-variable\">watermelon</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Watermelon</span>();<br>    <span class=\"hljs-comment\">//吃苹果</span><br>    apple.eatApple();<br>    <span class=\"hljs-comment\">//吃西瓜</span><br>   Watermelon.eatWatermelon();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果使用多态的思想，编写的水果类会是下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Fruit</span>&#123;<br>    ...<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatFruit</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Apple</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">fruit</span>&#123;<br>    <span class=\"hljs-comment\">//不需要定义自己的方法</span><br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Watermelon</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">fruit</span>&#123;<br>   <br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Banana</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">banana</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>现在吃水果的话：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">viod <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>&#123;<br>    <span class=\"hljs-type\">Fruit</span> <span class=\"hljs-variable\">apple</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Apple</span>();<br>    <span class=\"hljs-type\">Fruit</span> <span class=\"hljs-variable\">watermelon</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Watermelon</span>();<br>    <span class=\"hljs-comment\">//吃苹果</span><br>    apple.eatFruit();<br>    <span class=\"hljs-comment\">//吃西瓜</span><br>   Watermelon.eatFruit();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>多态这层抽象使得软件系统更加好维护，可扩展性更强，加一个西瓜不需要我们再去加一个吃西瓜的方法，直接使用<code>eatFruit</code>方法就可以了。</p>\n<h1 id=\"重写-override-和重载-overload\"><a href=\"#重写-override-和重载-overload\" class=\"headerlink\" title=\"重写(override)和重载(overload)\"></a>重写(override)和重载(overload)</h1><blockquote>\n<ul>\n<li><strong>重写(override)<strong>：</strong>子类对父类</strong>方法的实现过程进行重新编写，但是<strong>方法名，参数的类型和顺序是一样的</strong>，和<u>多态</u>有关。</li>\n<li><strong>重载(overload)<strong>：</strong>在一个类里面</strong>，方法名相同，但是参数不同，比较常用的是构造器重载。</li>\n</ul>\n</blockquote>\n<p>分清重写和重载的区别是很重要的，重写和本篇的主题多态有关，因为其涉及父子类相同的方法。举个例子，如果我们想定义自己吃苹果的方法，在java中就可以这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Fruit</span>&#123;<br>    ...<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatFruit</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Apple</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">fruit</span>&#123;<br>    <span class=\"hljs-meta\">@override</span><br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatFruit</span><span class=\"hljs-params\">()</span>&#123;<br>        print(<span class=\"hljs-string\">&quot;这是李四吃苹果的方法&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Watermelon</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">fruit</span>&#123;<br><br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Banana</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">banana</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这就是多态中的override，这也引出一个核心问题：<font color=purple>计算机怎么知道我们要调用的是父类还是子类的方法呢？</font>这就要说到<u>绑定</u>的问题了。</p>\n<h1 id=\"多态在JAVA的实现\"><a href=\"#多态在JAVA的实现\" class=\"headerlink\" title=\"多态在JAVA的实现\"></a>多态在JAVA的实现</h1><h2 id=\"静态绑定和动态绑定\"><a href=\"#静态绑定和动态绑定\" class=\"headerlink\" title=\"静态绑定和动态绑定\"></a>静态绑定和动态绑定</h2><blockquote>\n<p><strong>绑定</strong>：将一个方法的调用和一个方法的主体关联起来，比如将eatFruit()方法和apple关联起来。</p>\n</blockquote>\n<p>绑定分为<strong>静态绑定</strong>和<strong>动态绑定</strong>。</p>\n<p>先来说说静态绑定，所谓的静态绑定<font color=purple>就是在<strong>编译期</strong>就进行方法和类的绑定</font>，一般用于<u>访问对象的属性</u>或者是<u>final、static和private修饰的方法</u>，这类方法的特征就是<strong>确定无疑</strong>。</p>\n<p>动态绑定，就是<font color=purple>该对象的真实类型只有<strong>运行时</strong>才能确定，所以调用到的方法是运行时对象真实类型的方法</font>，在java中，除了静态绑定中提到的情况，其它都是动态绑定。</p>\n<p>重写(override)就是动态绑定，也就是运行时绑定；重载(overload)就是静态绑定，也就是编译时绑定。</p>\n<h2 id=\"动态绑定实现多态\"><a href=\"#动态绑定实现多态\" class=\"headerlink\" title=\"动态绑定实现多态\"></a>动态绑定实现多态</h2><p>首先举一个经典例子,下面调用的是apple的方法还是基类Fruit的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">viod <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>&#123;<br>    <span class=\"hljs-comment\">// apple实现了自己的eatFruit方法</span><br>    <span class=\"hljs-type\">Fruit</span> <span class=\"hljs-variable\">apple</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Apple</span>();<br>    <br>    apple.eatFruit();<br>   \t<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>因为子类apple定义了自己的eatFruit，所以调用的是apple的方法。由此可以看出，<u>当通过子类的实例去调用一系列的实例方法（包括一个方法调用的另一个方法）时，将优先和子类本身包含的实例方法动态绑定，如果子类没有定义这个实例方法，才会和从父类中继承来的实例方法动态绑定</u>。</p>\n<p>JVM在准备阶段会生成一个<u>方法表</u>，里面存储着每个类的<strong>每个方法对应的内存地址</strong>，子类方法表中的方法包含父类的所有方法， 且<strong>每个方法和父类方法的索引值（方法在方法表中的位置）相同</strong>。比如父类Fruit的方法eatFruit的索引号是1，Apple子类如果没有重写该方法，那么该索引号1指向的就是父类Fruit的eatFruit；如果其重写了该方法，那么Apple子类方法表中的索引号1就指向自己的eatFruit。</p>\n<p>在动态绑定的时，JVM会先根据动态类型获取对应类的方法表，再根据索引获取方法表中对应方法的内存地址。</p>\n","site":{"data":{}},"more":"<h1 id=\"面向对象基础\"><a href=\"#面向对象基础\" class=\"headerlink\" title=\"面向对象基础\"></a>面向对象基础</h1><p>我们先来聊聊什么是<code>面向对象（OOP）</code>。编程语言干的活绝大部分是<u>将实际的问题映射到机器模型之中</u>，而映射问题的思路是五花八门的。<u>面向对象</u>的基本思路就是<strong>用编程语言去表达实际问题的元素，围绕这些元素进行操作</strong>，这些元素在java中就被称为<code>对象</code>。</p>\n<p>比如说我现在要用OOP的思想去描述一个苹果，那么我会说：这个苹果的ID=xxxxx，颜色=红色，种类=红富士，产地=某地，是否打过药=是，除此之外，我还会围绕这个苹果进行操作，比如把它卖给张三，又比如吃掉它，这就是一个<strong>为实际问题的元素建立对象的过程</strong>。像什么苹果的ID、颜色、产地等等都是这个对象的<u>状态（属性）</u>，而被卖掉或者是被吃掉就是这个对象的行为，每个对象是不同的，因此对象还有自己唯一的<u>标识</u>。</p>\n<blockquote>\n<p><strong>对象的定义</strong>：一个对象具有自己的状态，行为和标识。这意味着对象有自己的内部数据(提供状态)、方法 (产生行为)，并彼此区分（每个对象在内存中都有唯一的地址）</p>\n</blockquote>\n<p>一个苹果对象很好管理，那如果是成百上千的苹果对象呢？难道要一个个的给它们建立对象吗？这显然不现实，这就要提到<code>类(class)</code>的概念。一个地方产的苹果往往有许多特征是一样的，比如产地啊，种类啊，是否打过药啊，那么我们就可以将其<strong>抽象</strong>为一个类，比如<code>张三果园苹果</code>，<strong>对象都从这个类生成，进行自己个性化的定制</strong>。</p>\n<p>我们使用<u>类</u>来将一个对象的各种内部数据和行为封装在一起，以此来表达实际问题的元素。但有一个问题没有解决：<u>如果我们现在有一批<code>杰克果园苹果</code>，是从外国进口的，这个时候再创建一个新类也太麻烦了吧？</u></p>\n<p>比较好的解决办法是什么呢？<u>我们不创建<code>张三果园苹果类</code>了，而是创建一个<code>苹果类</code>（<strong>注意不是苹果对象</strong>），其属性和行为和``张三果园苹果类<code>差不多，但是多个</code>果园名称`属性，然后张三果园和杰克果园产的苹果都<font color=purple><strong>继承</strong></font>自这个苹果类。</u>什么是继承呢，也就是<strong>is a</strong>的关系，杰克产的苹果是苹果，张三产的苹果也是苹果，他们都有苹果类的属性和行为，除此之外，还可以定制自己苹果的属性和行为。</p>\n<p>以上的概念呢十分基础，但是还是要理理清的。</p>\n<h1 id=\"什么是多态\"><a href=\"#什么是多态\" class=\"headerlink\" title=\"什么是多态\"></a>什么是多态</h1><p>我们常常听到：<u>对象是类的实例化</u>，什么意思呢？打个比方，我们正在为一批刚摘下来的水果设定属性，我们操作的是真真正正的苹果，也就是苹果对象1，苹果对象2，苹果对象3，苹果对象4这样一个个数过来的，但是设定属性时，是根据苹果类一批次设定的，而不管它是苹果对象几。</p>\n<p>拓展一下思路，实际上<strong>我们处理对象，不仅不把它看成是其所属的类，还看成其所属的基类</strong>。假如有一个水果类，其下面有苹果子类，香蕉子类，西瓜子类等等，<font color=purple>我们设定一个eat<strong>方法</strong>，我们就不需要知道其是什么水果类型，反正是水果都能吃</font>。这就是<strong>多态</strong>的思想，那么多态有什么好处呢？</p>\n<p>我们来举个例子，如果Java不支持多态，水果们应该这些写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Fruit</span>&#123;<br>    <span class=\"hljs-type\">int</span> id;<br>    String name;<br>    String color;<br>    String origin;<br>   \t<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setOrigin</span><span class=\"hljs-params\">(String origin)</span>;<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setColor</span><span class=\"hljs-params\">(String color)</span>;<br>    <br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Apple</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">fruit</span>&#123;<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatApple</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Watermelon</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">fruit</span>&#123;<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatWatermelon</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Banana</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">banana</span>&#123;<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatBanana</span><span class=\"hljs-params\">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果我们要吃个水果，每个水果类里都要定义一遍，如果调用这些方法，就会是下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">viod <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>&#123;<br>     <span class=\"hljs-type\">Apple</span> <span class=\"hljs-variable\">apple</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Apple</span>();<br>    <span class=\"hljs-type\">Watermelon</span> <span class=\"hljs-variable\">watermelon</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Watermelon</span>();<br>    <span class=\"hljs-comment\">//吃苹果</span><br>    apple.eatApple();<br>    <span class=\"hljs-comment\">//吃西瓜</span><br>   Watermelon.eatWatermelon();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果使用多态的思想，编写的水果类会是下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Fruit</span>&#123;<br>    ...<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatFruit</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Apple</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">fruit</span>&#123;<br>    <span class=\"hljs-comment\">//不需要定义自己的方法</span><br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Watermelon</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">fruit</span>&#123;<br>   <br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Banana</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">banana</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>现在吃水果的话：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">viod <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>&#123;<br>    <span class=\"hljs-type\">Fruit</span> <span class=\"hljs-variable\">apple</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Apple</span>();<br>    <span class=\"hljs-type\">Fruit</span> <span class=\"hljs-variable\">watermelon</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Watermelon</span>();<br>    <span class=\"hljs-comment\">//吃苹果</span><br>    apple.eatFruit();<br>    <span class=\"hljs-comment\">//吃西瓜</span><br>   Watermelon.eatFruit();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>多态这层抽象使得软件系统更加好维护，可扩展性更强，加一个西瓜不需要我们再去加一个吃西瓜的方法，直接使用<code>eatFruit</code>方法就可以了。</p>\n<h1 id=\"重写-override-和重载-overload\"><a href=\"#重写-override-和重载-overload\" class=\"headerlink\" title=\"重写(override)和重载(overload)\"></a>重写(override)和重载(overload)</h1><blockquote>\n<ul>\n<li><strong>重写(override)<strong>：</strong>子类对父类</strong>方法的实现过程进行重新编写，但是<strong>方法名，参数的类型和顺序是一样的</strong>，和<u>多态</u>有关。</li>\n<li><strong>重载(overload)<strong>：</strong>在一个类里面</strong>，方法名相同，但是参数不同，比较常用的是构造器重载。</li>\n</ul>\n</blockquote>\n<p>分清重写和重载的区别是很重要的，重写和本篇的主题多态有关，因为其涉及父子类相同的方法。举个例子，如果我们想定义自己吃苹果的方法，在java中就可以这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Fruit</span>&#123;<br>    ...<br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatFruit</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Apple</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">fruit</span>&#123;<br>    <span class=\"hljs-meta\">@override</span><br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eatFruit</span><span class=\"hljs-params\">()</span>&#123;<br>        print(<span class=\"hljs-string\">&quot;这是李四吃苹果的方法&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Watermelon</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">fruit</span>&#123;<br><br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Banana</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">banana</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这就是多态中的override，这也引出一个核心问题：<font color=purple>计算机怎么知道我们要调用的是父类还是子类的方法呢？</font>这就要说到<u>绑定</u>的问题了。</p>\n<h1 id=\"多态在JAVA的实现\"><a href=\"#多态在JAVA的实现\" class=\"headerlink\" title=\"多态在JAVA的实现\"></a>多态在JAVA的实现</h1><h2 id=\"静态绑定和动态绑定\"><a href=\"#静态绑定和动态绑定\" class=\"headerlink\" title=\"静态绑定和动态绑定\"></a>静态绑定和动态绑定</h2><blockquote>\n<p><strong>绑定</strong>：将一个方法的调用和一个方法的主体关联起来，比如将eatFruit()方法和apple关联起来。</p>\n</blockquote>\n<p>绑定分为<strong>静态绑定</strong>和<strong>动态绑定</strong>。</p>\n<p>先来说说静态绑定，所谓的静态绑定<font color=purple>就是在<strong>编译期</strong>就进行方法和类的绑定</font>，一般用于<u>访问对象的属性</u>或者是<u>final、static和private修饰的方法</u>，这类方法的特征就是<strong>确定无疑</strong>。</p>\n<p>动态绑定，就是<font color=purple>该对象的真实类型只有<strong>运行时</strong>才能确定，所以调用到的方法是运行时对象真实类型的方法</font>，在java中，除了静态绑定中提到的情况，其它都是动态绑定。</p>\n<p>重写(override)就是动态绑定，也就是运行时绑定；重载(overload)就是静态绑定，也就是编译时绑定。</p>\n<h2 id=\"动态绑定实现多态\"><a href=\"#动态绑定实现多态\" class=\"headerlink\" title=\"动态绑定实现多态\"></a>动态绑定实现多态</h2><p>首先举一个经典例子,下面调用的是apple的方法还是基类Fruit的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">viod <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>&#123;<br>    <span class=\"hljs-comment\">// apple实现了自己的eatFruit方法</span><br>    <span class=\"hljs-type\">Fruit</span> <span class=\"hljs-variable\">apple</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Apple</span>();<br>    <br>    apple.eatFruit();<br>   \t<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>因为子类apple定义了自己的eatFruit，所以调用的是apple的方法。由此可以看出，<u>当通过子类的实例去调用一系列的实例方法（包括一个方法调用的另一个方法）时，将优先和子类本身包含的实例方法动态绑定，如果子类没有定义这个实例方法，才会和从父类中继承来的实例方法动态绑定</u>。</p>\n<p>JVM在准备阶段会生成一个<u>方法表</u>，里面存储着每个类的<strong>每个方法对应的内存地址</strong>，子类方法表中的方法包含父类的所有方法， 且<strong>每个方法和父类方法的索引值（方法在方法表中的位置）相同</strong>。比如父类Fruit的方法eatFruit的索引号是1，Apple子类如果没有重写该方法，那么该索引号1指向的就是父类Fruit的eatFruit；如果其重写了该方法，那么Apple子类方法表中的索引号1就指向自己的eatFruit。</p>\n<p>在动态绑定的时，JVM会先根据动态类型获取对应类的方法表，再根据索引获取方法表中对应方法的内存地址。</p>\n"},{"title":"Servlet优化","date":"2022-11-10T03:44:09.000Z","banner_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.23k31ke5b9a8.webp","index_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.23k31ke5b9a8.webp","excerpt":"记录优化Servlet的过程","_content":"\n\n\n在学习Javaweb基础的时候，遇到了一个优化Servlet的过程，我觉得有必要记录下优化的过程，这其中体现了一些设计模式和规范。\n\n# 优化前项目的结构和问题\n\n优化前的项目，其基本思路就是<u>服务器接受请求，然后通过路径的映射，找到对应的Servlet来处理请求</u>。比如url路径为`localhost:8080/elibrary/admin?operate=del?id=1`，那么服务器会通过`/admin/del`找到`AdminDelServlet`，然后获取参数`id`，对数据库进行删除操作。大致流程如下图所示：\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1hz7bss0nd34.webp\" alt=\"image\" style=\"zoom: 67%;\" /></div>\n\n这种结构有一个很突出的问题就是**Servlet太多了**，随着项目的开发，管理难度会越来越大，那么怎么解决呢？\n\n# 优化1：合并增删查改\n\n解决办法也很简单，我们把一个实体对应的操作合并为一个Servlet，比如把`AdminDelServlet`、`AdminAddServlet`、`AdminEditServlet`合并为一个`AdminServlet`，合并后的Servlet根据Switch-Case来选择具体的操作，合并后的示意图如下：\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.hn7h791qaog.webp\" alt=\"image\" style=\"zoom:67%;\" /></div>\n\n\n代码示例如下：\n\n```java\n@WebServlet(\"/admin\")\npublic class AdminServlet extends HttpServlet{\n    @override\n    protected void service(HttpservletRequest req,HttpServletResponse resp){\n        operate = req.getParameter(\"operate\");\n        switch(operate){\n            case \"del\": \n                del(...);\n                break;\n            case \"add\":\n                add(...);\n                break;\n            case \"edit\":\n                edit(...);\n                break;\n        }\n        \n    }\n    //原来的AmdinAddServlet替换成下面的add()\n    public void add(...){\n        ...\n    }\n    \n    public void del(...){\n        ...\n    }\n    \n    public void edit(...){\n        ...\n    }\n}\n```\n\n这样写又引出了一个问题：<u>如果一个实体对应的操作很多，那我们的switch-case岂不是得变得特别长</u>？我们能不能优化一下这一部分呢？\n\n我们可以用反射来代替上面的代码，示例代码如下：\n\n```java\n//后去AdminServlet的所有方法\nMethod[] methods = this.getClass.getDeclaredMethods();\nfor(Method m : methods){\n\tString methodName = m.getName();\n\tif(operate.equals(methodName)){\n\t\ttry{\n\t\t\tm.invoke(this,request,response);\n\t\t}\n\t}\n}\n```\n\n通过反射机制，我们大大缩减了代码量，不管我们写多少具体操作，这段选择具体操作的代码都不会增多。这样，我们就完成了第一步的优化。\n\n# 优化2 ：引入DispatcherServlet\n\n上节我们使用反射优化了AdminServlet中选择操作的代码，解决了代码量膨胀的问题。与这种情况类似的是，我们的实体也会有很多，比如实际项目中会有许多个类似AdminServlet的Servlet，这其中必然**存在许多冗余的代码**，比如说上节的反射机制选择操作，每个实体Servlet都会有这么一段代码。我们要优化的一个重要部分就是**代码的冗余**，<font color=purple>**基本解决方法就是将冗余的这部分提取出来到一个通用的处理器里**</font>。\n\n我们引入一个`DispatcherServlet`，然后把`AdminServlet`中的反射选择操作提取出来。\n\n我们首先要想办法选择`AdminServlet`，这该怎么办呢？url路径中的`/admin`对应了`AdminServlet`，这是一个映射，<u>我们只需要在一个文件里保留这层映射关系，就能通过java获取到`AdminServlet`的实例</u>。我们创建一个`applicationContext.xml`：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<beans>\n    <bean id=\"admin\" class=\"...\" />\n</beans>\n```\n\n接下来，只要分析xml，就可以得出映射关系，我们将映射关系存到beanMap里:\n\n```java\nInputStream inputStream = getClass().getClassLoader().getResourceAsStream(\"applicationContext.xml\");\nDocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\nDocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n\nDocument document = documentBuilder.parse(inputStream);\n\nNodeList beanNodeList = document.getElementsByTagName(\"bean\");\n\nfor(int i=0; i<beanNodeList.getLength(); i++){\n    Node beanNode = beanNodeList.item(i);\n    if(beanNode.getNodeType() == Node.ELEMENT_NODE){\n        Element beanElement = (Element) beanNode;\n        String beanId = beanElement.getAttribute(\"id\");\n        String className = beanElement.getAttribute(\"class\");\n        Object beanObj = Class.forName(className).newInstance();\n        /*将映射关系存到一个beanMap里*/\n        beanMap.put(beanId,beanObj);\n    }\n}\n```\n\n得到映射关系后，我们就要想办法从**请求**中得到对应``AdminServlet`的字符串，然后调用AdminServlet方法，这部分思路就很清晰了，直接substring一下url路径就行了:\n\n```java\nString servletPath = req.getServletPath();\t\t //servletPath = \"/admin\"\nservletPath = servletPath.substring(1);\t\t\t\t//servletPath = \"admin\"\nObject controllerBeanObj = beanMap.get(servletPath);\t//controllerBeanObj = AdminServlet\n```\n\n与之相同的道理，我们还可以获取具体操作的字符串，也就是为调用AdminServlet具体的方法做准备：\n\n```java\nString operate = req.getParameter(\"operate\");\nif(StringUtils.isEmpty(operate)){\n\toperate = \"index\";\n}\n```\n\n获取到实例后，我们就要开始提取**反射选择具体方法的代码**了，我们直接从AdminServlet中提取这部分代码，然后转移到DispatcherServlet中，并且修改为：\n\n```java\n/*\nurl = localhost:8080/porjectname/admin?operate=del&id=2\nservletPath = \"admin\"\noperate = \"del\"\n*/\nMethod[] methods = controllerBeanObj.getClass().getDeclaredMethods();\nfor(Method method : methods){\n\tif(operate.equals(method.getName())){\n\t\tmethod.setAccessible(true);\n        method.invoke(controllerBeanObj,req,resp);\n    }\n}\n```\n\n# 优化三：提取视图资源处理和获取参数\n\n优化还没结束，我们还是遵循相同的底层逻辑——**提取冗余的代码**，那么还有哪些冗余的代码呢？\n\n1. 获取参数的部分，每个具体操作都要从req中获取不同的参数。\n2. 资源的跳转：服务器的内部转发、重定向和交给视图模板处理的代码都是冗余的\n\n## 提取获取参数的代码\n\n我们来看一个具体操作del()的示例:\n\n```java\npublic class AdminServlet extends HttpServlet{\n    service(...){\n        /*empty，因为仅存的选择方法的反射代码也被提取到了Dispatchet中*/\n    }\n    \n    public void del(HttpServletRequest req,HttpServletResponse resp){\n\t\t\tString id = req.getParameter(\"id\");\n            ...//业务逻辑\n             resp.sendRedirect(\"index\");\n    }\n}\n```\n\n我们要做的优化，**就是把getParameter和sendRedirect这两步步放到Dispatcher里**，修改后的del应该是这个样子的:\n\n```java\npublic class AdminServlet extends HttpServlet{\n    service(...){\n        /*empty，因为仅存的选择方法的反射代码也被提取到了Dispatchet中*/\n    }\n    \n    public void del(String id){\n            ...//业务逻辑\n             return \"redirect:index\"\n    }\n}\n```\n\n我们先来看看如何提取获取参数的代码，基本思路还是<u>利用反射去获取del方法的所有参数名，取得del方法的参数名后去req里获取请求的参数</u>。method刚才已经取得了，获取其参数的类型以及名称只要一句就够了：\n\n```java\nParameter[] parameters = method.getParameters();\n```\n\n但是这样取出的参数名，我们会发现是“arg0”,”arg1”,”arg2”这样的，显然不符号我们的要求，因此，我们需要**在java compiler选项里加上`-parameters`**，这样获取的参数数组就是带名字的了:\n\n![带parameters选项的获取参数](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5jpd5xrjw480.webp)\n\n获取到参数的名字后，我们就可以使用参数名去获取请求中存储的值了:\n\n```java\nParameter[] parameters = method.getParameters();\n/*用于存取参数对应的值*/\nObject[] parameterValues = new Object[parameters.length];\nfor(int i=0;i< parameters.length;i++){\n    /*处理参数中有特殊的情况*/\n    if(parameters[i].getName().equals(\"req\")){\n        parameterValues[i] = req;\n    }else if(parameters[i].getName().equals(\"resp\")){\n        parameterValues[i] = resp;\n    }else if(parameters[i].getName().equals(\"session\")){\n        parameterValues[i] = req.getSession();\n    }else{\n        String parameterName = parameters[i].getName();\n        parameterValues[i] = req.getParameter(parameterName);\n    }\n}\n```\n\n但是这还没完。如果这个时候我们直接`method.invoke(controllerBeanObject,parameterValues)`的话，很容易出现下列异常：\n\n![IllegalArgumentException](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.4356l2iavo80.webp)\n\n问题就出在，我们提供的参数类型和实际参数的类型对不上，`req.getParameter`得到的可以转成String,但是如果参数是Integer，那么就会报出上面的异常，处理方法就是**通过分析参数的类型信息，进行类型转换**，最后的代码如下：\n\n```java\nString parameterName = parameters[i].getName();\nString parameterValue = req.getParameter(parameterName);\nString typeName = parameters[i].getType().getName();\nObject parameterObject = parameterValue;\nif(parameterObject!=null){\n    if(\"java.lang.Integer\".equals(typeName)){\n        parameterObject = Integer.parseInt(parameterValue);\n    }else if(...){\n        \n    }\n}\nparameterValues[i] = parameterObject;\n```\n\n## 提取资源跳转\n\n这部分就比较简单了，我们只要在Dispatcher中分析del的返回值就好了：\n\n```java\nObject returnObj = method.invoke(this,req,resp);\nString methodReturnStr = (String) returnObj;\n\nif(methodReturnStr.startsWith(\"redirect:\")){\n\tString redirectStr = methodReturnStr.substring(\"redirect:\".length());\n\tresp.sendRedirect(redirectStr);\n}else{\n    /*Thymeleaf模板跳转*/\n\tsuper.processTemplate(methodReturnStr,req,resp);\n}\n```\n\n# 结语\n\n以上的部分对实际开发并没有什么用，因为不可能比框架写得更好，考虑得更周到，但是其思路是值得借鉴和学习的，尤其是如何处理冗余的代码。\n","source":"_posts/Servlet优化.md","raw":"---\ntitle: Servlet优化\ndate: 2022-11-10 11:44:09\ntags:\n- JavaWeb\ncategories:\n- web开发\n- java web\nbanner_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.23k31ke5b9a8.webp\nindex_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.23k31ke5b9a8.webp\nexcerpt: 记录优化Servlet的过程\n---\n\n\n\n在学习Javaweb基础的时候，遇到了一个优化Servlet的过程，我觉得有必要记录下优化的过程，这其中体现了一些设计模式和规范。\n\n# 优化前项目的结构和问题\n\n优化前的项目，其基本思路就是<u>服务器接受请求，然后通过路径的映射，找到对应的Servlet来处理请求</u>。比如url路径为`localhost:8080/elibrary/admin?operate=del?id=1`，那么服务器会通过`/admin/del`找到`AdminDelServlet`，然后获取参数`id`，对数据库进行删除操作。大致流程如下图所示：\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1hz7bss0nd34.webp\" alt=\"image\" style=\"zoom: 67%;\" /></div>\n\n这种结构有一个很突出的问题就是**Servlet太多了**，随着项目的开发，管理难度会越来越大，那么怎么解决呢？\n\n# 优化1：合并增删查改\n\n解决办法也很简单，我们把一个实体对应的操作合并为一个Servlet，比如把`AdminDelServlet`、`AdminAddServlet`、`AdminEditServlet`合并为一个`AdminServlet`，合并后的Servlet根据Switch-Case来选择具体的操作，合并后的示意图如下：\n\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.hn7h791qaog.webp\" alt=\"image\" style=\"zoom:67%;\" /></div>\n\n\n代码示例如下：\n\n```java\n@WebServlet(\"/admin\")\npublic class AdminServlet extends HttpServlet{\n    @override\n    protected void service(HttpservletRequest req,HttpServletResponse resp){\n        operate = req.getParameter(\"operate\");\n        switch(operate){\n            case \"del\": \n                del(...);\n                break;\n            case \"add\":\n                add(...);\n                break;\n            case \"edit\":\n                edit(...);\n                break;\n        }\n        \n    }\n    //原来的AmdinAddServlet替换成下面的add()\n    public void add(...){\n        ...\n    }\n    \n    public void del(...){\n        ...\n    }\n    \n    public void edit(...){\n        ...\n    }\n}\n```\n\n这样写又引出了一个问题：<u>如果一个实体对应的操作很多，那我们的switch-case岂不是得变得特别长</u>？我们能不能优化一下这一部分呢？\n\n我们可以用反射来代替上面的代码，示例代码如下：\n\n```java\n//后去AdminServlet的所有方法\nMethod[] methods = this.getClass.getDeclaredMethods();\nfor(Method m : methods){\n\tString methodName = m.getName();\n\tif(operate.equals(methodName)){\n\t\ttry{\n\t\t\tm.invoke(this,request,response);\n\t\t}\n\t}\n}\n```\n\n通过反射机制，我们大大缩减了代码量，不管我们写多少具体操作，这段选择具体操作的代码都不会增多。这样，我们就完成了第一步的优化。\n\n# 优化2 ：引入DispatcherServlet\n\n上节我们使用反射优化了AdminServlet中选择操作的代码，解决了代码量膨胀的问题。与这种情况类似的是，我们的实体也会有很多，比如实际项目中会有许多个类似AdminServlet的Servlet，这其中必然**存在许多冗余的代码**，比如说上节的反射机制选择操作，每个实体Servlet都会有这么一段代码。我们要优化的一个重要部分就是**代码的冗余**，<font color=purple>**基本解决方法就是将冗余的这部分提取出来到一个通用的处理器里**</font>。\n\n我们引入一个`DispatcherServlet`，然后把`AdminServlet`中的反射选择操作提取出来。\n\n我们首先要想办法选择`AdminServlet`，这该怎么办呢？url路径中的`/admin`对应了`AdminServlet`，这是一个映射，<u>我们只需要在一个文件里保留这层映射关系，就能通过java获取到`AdminServlet`的实例</u>。我们创建一个`applicationContext.xml`：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<beans>\n    <bean id=\"admin\" class=\"...\" />\n</beans>\n```\n\n接下来，只要分析xml，就可以得出映射关系，我们将映射关系存到beanMap里:\n\n```java\nInputStream inputStream = getClass().getClassLoader().getResourceAsStream(\"applicationContext.xml\");\nDocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\nDocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n\nDocument document = documentBuilder.parse(inputStream);\n\nNodeList beanNodeList = document.getElementsByTagName(\"bean\");\n\nfor(int i=0; i<beanNodeList.getLength(); i++){\n    Node beanNode = beanNodeList.item(i);\n    if(beanNode.getNodeType() == Node.ELEMENT_NODE){\n        Element beanElement = (Element) beanNode;\n        String beanId = beanElement.getAttribute(\"id\");\n        String className = beanElement.getAttribute(\"class\");\n        Object beanObj = Class.forName(className).newInstance();\n        /*将映射关系存到一个beanMap里*/\n        beanMap.put(beanId,beanObj);\n    }\n}\n```\n\n得到映射关系后，我们就要想办法从**请求**中得到对应``AdminServlet`的字符串，然后调用AdminServlet方法，这部分思路就很清晰了，直接substring一下url路径就行了:\n\n```java\nString servletPath = req.getServletPath();\t\t //servletPath = \"/admin\"\nservletPath = servletPath.substring(1);\t\t\t\t//servletPath = \"admin\"\nObject controllerBeanObj = beanMap.get(servletPath);\t//controllerBeanObj = AdminServlet\n```\n\n与之相同的道理，我们还可以获取具体操作的字符串，也就是为调用AdminServlet具体的方法做准备：\n\n```java\nString operate = req.getParameter(\"operate\");\nif(StringUtils.isEmpty(operate)){\n\toperate = \"index\";\n}\n```\n\n获取到实例后，我们就要开始提取**反射选择具体方法的代码**了，我们直接从AdminServlet中提取这部分代码，然后转移到DispatcherServlet中，并且修改为：\n\n```java\n/*\nurl = localhost:8080/porjectname/admin?operate=del&id=2\nservletPath = \"admin\"\noperate = \"del\"\n*/\nMethod[] methods = controllerBeanObj.getClass().getDeclaredMethods();\nfor(Method method : methods){\n\tif(operate.equals(method.getName())){\n\t\tmethod.setAccessible(true);\n        method.invoke(controllerBeanObj,req,resp);\n    }\n}\n```\n\n# 优化三：提取视图资源处理和获取参数\n\n优化还没结束，我们还是遵循相同的底层逻辑——**提取冗余的代码**，那么还有哪些冗余的代码呢？\n\n1. 获取参数的部分，每个具体操作都要从req中获取不同的参数。\n2. 资源的跳转：服务器的内部转发、重定向和交给视图模板处理的代码都是冗余的\n\n## 提取获取参数的代码\n\n我们来看一个具体操作del()的示例:\n\n```java\npublic class AdminServlet extends HttpServlet{\n    service(...){\n        /*empty，因为仅存的选择方法的反射代码也被提取到了Dispatchet中*/\n    }\n    \n    public void del(HttpServletRequest req,HttpServletResponse resp){\n\t\t\tString id = req.getParameter(\"id\");\n            ...//业务逻辑\n             resp.sendRedirect(\"index\");\n    }\n}\n```\n\n我们要做的优化，**就是把getParameter和sendRedirect这两步步放到Dispatcher里**，修改后的del应该是这个样子的:\n\n```java\npublic class AdminServlet extends HttpServlet{\n    service(...){\n        /*empty，因为仅存的选择方法的反射代码也被提取到了Dispatchet中*/\n    }\n    \n    public void del(String id){\n            ...//业务逻辑\n             return \"redirect:index\"\n    }\n}\n```\n\n我们先来看看如何提取获取参数的代码，基本思路还是<u>利用反射去获取del方法的所有参数名，取得del方法的参数名后去req里获取请求的参数</u>。method刚才已经取得了，获取其参数的类型以及名称只要一句就够了：\n\n```java\nParameter[] parameters = method.getParameters();\n```\n\n但是这样取出的参数名，我们会发现是“arg0”,”arg1”,”arg2”这样的，显然不符号我们的要求，因此，我们需要**在java compiler选项里加上`-parameters`**，这样获取的参数数组就是带名字的了:\n\n![带parameters选项的获取参数](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5jpd5xrjw480.webp)\n\n获取到参数的名字后，我们就可以使用参数名去获取请求中存储的值了:\n\n```java\nParameter[] parameters = method.getParameters();\n/*用于存取参数对应的值*/\nObject[] parameterValues = new Object[parameters.length];\nfor(int i=0;i< parameters.length;i++){\n    /*处理参数中有特殊的情况*/\n    if(parameters[i].getName().equals(\"req\")){\n        parameterValues[i] = req;\n    }else if(parameters[i].getName().equals(\"resp\")){\n        parameterValues[i] = resp;\n    }else if(parameters[i].getName().equals(\"session\")){\n        parameterValues[i] = req.getSession();\n    }else{\n        String parameterName = parameters[i].getName();\n        parameterValues[i] = req.getParameter(parameterName);\n    }\n}\n```\n\n但是这还没完。如果这个时候我们直接`method.invoke(controllerBeanObject,parameterValues)`的话，很容易出现下列异常：\n\n![IllegalArgumentException](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.4356l2iavo80.webp)\n\n问题就出在，我们提供的参数类型和实际参数的类型对不上，`req.getParameter`得到的可以转成String,但是如果参数是Integer，那么就会报出上面的异常，处理方法就是**通过分析参数的类型信息，进行类型转换**，最后的代码如下：\n\n```java\nString parameterName = parameters[i].getName();\nString parameterValue = req.getParameter(parameterName);\nString typeName = parameters[i].getType().getName();\nObject parameterObject = parameterValue;\nif(parameterObject!=null){\n    if(\"java.lang.Integer\".equals(typeName)){\n        parameterObject = Integer.parseInt(parameterValue);\n    }else if(...){\n        \n    }\n}\nparameterValues[i] = parameterObject;\n```\n\n## 提取资源跳转\n\n这部分就比较简单了，我们只要在Dispatcher中分析del的返回值就好了：\n\n```java\nObject returnObj = method.invoke(this,req,resp);\nString methodReturnStr = (String) returnObj;\n\nif(methodReturnStr.startsWith(\"redirect:\")){\n\tString redirectStr = methodReturnStr.substring(\"redirect:\".length());\n\tresp.sendRedirect(redirectStr);\n}else{\n    /*Thymeleaf模板跳转*/\n\tsuper.processTemplate(methodReturnStr,req,resp);\n}\n```\n\n# 结语\n\n以上的部分对实际开发并没有什么用，因为不可能比框架写得更好，考虑得更周到，但是其思路是值得借鉴和学习的，尤其是如何处理冗余的代码。\n","slug":"Servlet优化","published":1,"updated":"2022-11-20T02:42:47.029Z","_id":"clado7pvv000094ru9e3v61ru","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在学习Javaweb基础的时候，遇到了一个优化Servlet的过程，我觉得有必要记录下优化的过程，这其中体现了一些设计模式和规范。</p>\n<h1 id=\"优化前项目的结构和问题\"><a href=\"#优化前项目的结构和问题\" class=\"headerlink\" title=\"优化前项目的结构和问题\"></a>优化前项目的结构和问题</h1><p>优化前的项目，其基本思路就是<u>服务器接受请求，然后通过路径的映射，找到对应的Servlet来处理请求</u>。比如url路径为<code>localhost:8080/elibrary/admin?operate=del?id=1</code>，那么服务器会通过<code>/admin/del</code>找到<code>AdminDelServlet</code>，然后获取参数<code>id</code>，对数据库进行删除操作。大致流程如下图所示：</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1hz7bss0nd34.webp\" alt=\"image\" style=\"zoom: 67%;\" /></div>\n\n<p>这种结构有一个很突出的问题就是<strong>Servlet太多了</strong>，随着项目的开发，管理难度会越来越大，那么怎么解决呢？</p>\n<h1 id=\"优化1：合并增删查改\"><a href=\"#优化1：合并增删查改\" class=\"headerlink\" title=\"优化1：合并增删查改\"></a>优化1：合并增删查改</h1><p>解决办法也很简单，我们把一个实体对应的操作合并为一个Servlet，比如把<code>AdminDelServlet</code>、<code>AdminAddServlet</code>、<code>AdminEditServlet</code>合并为一个<code>AdminServlet</code>，合并后的Servlet根据Switch-Case来选择具体的操作，合并后的示意图如下：</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.hn7h791qaog.webp\" alt=\"image\" style=\"zoom:67%;\" /></div>\n\n\n<p>代码示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@WebServlet(&quot;/admin&quot;)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AdminServlet</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">HttpServlet</span>&#123;<br>    <span class=\"hljs-meta\">@override</span><br>    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">service</span><span class=\"hljs-params\">(HttpservletRequest req,HttpServletResponse resp)</span>&#123;<br>        operate = req.getParameter(<span class=\"hljs-string\">&quot;operate&quot;</span>);<br>        <span class=\"hljs-keyword\">switch</span>(operate)&#123;<br>            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;del&quot;</span>: <br>                del(...);<br>                <span class=\"hljs-keyword\">break</span>;<br>            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;add&quot;</span>:<br>                add(...);<br>                <span class=\"hljs-keyword\">break</span>;<br>            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;edit&quot;</span>:<br>                edit(...);<br>                <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>        <br>    &#125;<br>    <span class=\"hljs-comment\">//原来的AmdinAddServlet替换成下面的add()</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(...)</span>&#123;<br>        ...<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">del</span><span class=\"hljs-params\">(...)</span>&#123;<br>        ...<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">edit</span><span class=\"hljs-params\">(...)</span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样写又引出了一个问题：<u>如果一个实体对应的操作很多，那我们的switch-case岂不是得变得特别长</u>？我们能不能优化一下这一部分呢？</p>\n<p>我们可以用反射来代替上面的代码，示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//后去AdminServlet的所有方法</span><br>Method[] methods = <span class=\"hljs-built_in\">this</span>.getClass.getDeclaredMethods();<br><span class=\"hljs-keyword\">for</span>(Method m : methods)&#123;<br>\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">methodName</span> <span class=\"hljs-operator\">=</span> m.getName();<br>\t<span class=\"hljs-keyword\">if</span>(operate.equals(methodName))&#123;<br>\t\t<span class=\"hljs-keyword\">try</span>&#123;<br>\t\t\tm.invoke(<span class=\"hljs-built_in\">this</span>,request,response);<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过反射机制，我们大大缩减了代码量，不管我们写多少具体操作，这段选择具体操作的代码都不会增多。这样，我们就完成了第一步的优化。</p>\n<h1 id=\"优化2-：引入DispatcherServlet\"><a href=\"#优化2-：引入DispatcherServlet\" class=\"headerlink\" title=\"优化2 ：引入DispatcherServlet\"></a>优化2 ：引入DispatcherServlet</h1><p>上节我们使用反射优化了AdminServlet中选择操作的代码，解决了代码量膨胀的问题。与这种情况类似的是，我们的实体也会有很多，比如实际项目中会有许多个类似AdminServlet的Servlet，这其中必然<strong>存在许多冗余的代码</strong>，比如说上节的反射机制选择操作，每个实体Servlet都会有这么一段代码。我们要优化的一个重要部分就是<strong>代码的冗余</strong>，<font color=purple><strong>基本解决方法就是将冗余的这部分提取出来到一个通用的处理器里</strong></font>。</p>\n<p>我们引入一个<code>DispatcherServlet</code>，然后把<code>AdminServlet</code>中的反射选择操作提取出来。</p>\n<p>我们首先要想办法选择<code>AdminServlet</code>，这该怎么办呢？url路径中的<code>/admin</code>对应了<code>AdminServlet</code>，这是一个映射，<u>我们只需要在一个文件里保留这层映射关系，就能通过java获取到<code>AdminServlet</code>的实例</u>。我们创建一个<code>applicationContext.xml</code>：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=<span class=\"hljs-string\">&quot;1.0&quot;</span> encoding=<span class=\"hljs-string\">&quot;utf-8&quot;</span> ?&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;admin&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;...&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>接下来，只要分析xml，就可以得出映射关系，我们将映射关系存到beanMap里:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">InputStream</span> <span class=\"hljs-variable\">inputStream</span> <span class=\"hljs-operator\">=</span> getClass().getClassLoader().getResourceAsStream(<span class=\"hljs-string\">&quot;applicationContext.xml&quot;</span>);<br><span class=\"hljs-type\">DocumentBuilderFactory</span> <span class=\"hljs-variable\">documentBuilderFactory</span> <span class=\"hljs-operator\">=</span> DocumentBuilderFactory.newInstance();<br><span class=\"hljs-type\">DocumentBuilder</span> <span class=\"hljs-variable\">documentBuilder</span> <span class=\"hljs-operator\">=</span> documentBuilderFactory.newDocumentBuilder();<br><br><span class=\"hljs-type\">Document</span> <span class=\"hljs-variable\">document</span> <span class=\"hljs-operator\">=</span> documentBuilder.parse(inputStream);<br><br><span class=\"hljs-type\">NodeList</span> <span class=\"hljs-variable\">beanNodeList</span> <span class=\"hljs-operator\">=</span> document.getElementsByTagName(<span class=\"hljs-string\">&quot;bean&quot;</span>);<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;beanNodeList.getLength(); i++)&#123;<br>    <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">beanNode</span> <span class=\"hljs-operator\">=</span> beanNodeList.item(i);<br>    <span class=\"hljs-keyword\">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE)&#123;<br>        <span class=\"hljs-type\">Element</span> <span class=\"hljs-variable\">beanElement</span> <span class=\"hljs-operator\">=</span> (Element) beanNode;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">beanId</span> <span class=\"hljs-operator\">=</span> beanElement.getAttribute(<span class=\"hljs-string\">&quot;id&quot;</span>);<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">className</span> <span class=\"hljs-operator\">=</span> beanElement.getAttribute(<span class=\"hljs-string\">&quot;class&quot;</span>);<br>        <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">beanObj</span> <span class=\"hljs-operator\">=</span> Class.forName(className).newInstance();<br>        <span class=\"hljs-comment\">/*将映射关系存到一个beanMap里*/</span><br>        beanMap.put(beanId,beanObj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>得到映射关系后，我们就要想办法从<strong>请求</strong>中得到对应``AdminServlet`的字符串，然后调用AdminServlet方法，这部分思路就很清晰了，直接substring一下url路径就行了:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">servletPath</span> <span class=\"hljs-operator\">=</span> req.getServletPath();\t\t <span class=\"hljs-comment\">//servletPath = &quot;/admin&quot;</span><br>servletPath = servletPath.substring(<span class=\"hljs-number\">1</span>);\t\t\t\t<span class=\"hljs-comment\">//servletPath = &quot;admin&quot;</span><br><span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">controllerBeanObj</span> <span class=\"hljs-operator\">=</span> beanMap.get(servletPath);\t<span class=\"hljs-comment\">//controllerBeanObj = AdminServlet</span><br></code></pre></td></tr></table></figure>\n\n<p>与之相同的道理，我们还可以获取具体操作的字符串，也就是为调用AdminServlet具体的方法做准备：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">operate</span> <span class=\"hljs-operator\">=</span> req.getParameter(<span class=\"hljs-string\">&quot;operate&quot;</span>);<br><span class=\"hljs-keyword\">if</span>(StringUtils.isEmpty(operate))&#123;<br>\toperate = <span class=\"hljs-string\">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>获取到实例后，我们就要开始提取<strong>反射选择具体方法的代码</strong>了，我们直接从AdminServlet中提取这部分代码，然后转移到DispatcherServlet中，并且修改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">url = localhost:8080/porjectname/admin?operate=del&amp;id=2</span><br><span class=\"hljs-comment\">servletPath = &quot;admin&quot;</span><br><span class=\"hljs-comment\">operate = &quot;del&quot;</span><br><span class=\"hljs-comment\">*/</span><br>Method[] methods = controllerBeanObj.getClass().getDeclaredMethods();<br><span class=\"hljs-keyword\">for</span>(Method method : methods)&#123;<br>\t<span class=\"hljs-keyword\">if</span>(operate.equals(method.getName()))&#123;<br>\t\tmethod.setAccessible(<span class=\"hljs-literal\">true</span>);<br>        method.invoke(controllerBeanObj,req,resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"优化三：提取视图资源处理和获取参数\"><a href=\"#优化三：提取视图资源处理和获取参数\" class=\"headerlink\" title=\"优化三：提取视图资源处理和获取参数\"></a>优化三：提取视图资源处理和获取参数</h1><p>优化还没结束，我们还是遵循相同的底层逻辑——<strong>提取冗余的代码</strong>，那么还有哪些冗余的代码呢？</p>\n<ol>\n<li>获取参数的部分，每个具体操作都要从req中获取不同的参数。</li>\n<li>资源的跳转：服务器的内部转发、重定向和交给视图模板处理的代码都是冗余的</li>\n</ol>\n<h2 id=\"提取获取参数的代码\"><a href=\"#提取获取参数的代码\" class=\"headerlink\" title=\"提取获取参数的代码\"></a>提取获取参数的代码</h2><p>我们来看一个具体操作del()的示例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AdminServlet</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">HttpServlet</span>&#123;<br>    service(...)&#123;<br>        <span class=\"hljs-comment\">/*empty，因为仅存的选择方法的反射代码也被提取到了Dispatchet中*/</span><br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">del</span><span class=\"hljs-params\">(HttpServletRequest req,HttpServletResponse resp)</span>&#123;<br>\t\t\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> req.getParameter(<span class=\"hljs-string\">&quot;id&quot;</span>);<br>            ...<span class=\"hljs-comment\">//业务逻辑</span><br>             resp.sendRedirect(<span class=\"hljs-string\">&quot;index&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们要做的优化，<strong>就是把getParameter和sendRedirect这两步步放到Dispatcher里</strong>，修改后的del应该是这个样子的:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AdminServlet</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">HttpServlet</span>&#123;<br>    service(...)&#123;<br>        <span class=\"hljs-comment\">/*empty，因为仅存的选择方法的反射代码也被提取到了Dispatchet中*/</span><br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">del</span><span class=\"hljs-params\">(String id)</span>&#123;<br>            ...<span class=\"hljs-comment\">//业务逻辑</span><br>             <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;redirect:index&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们先来看看如何提取获取参数的代码，基本思路还是<u>利用反射去获取del方法的所有参数名，取得del方法的参数名后去req里获取请求的参数</u>。method刚才已经取得了，获取其参数的类型以及名称只要一句就够了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Parameter[] parameters = method.getParameters();<br></code></pre></td></tr></table></figure>\n\n<p>但是这样取出的参数名，我们会发现是“arg0”,”arg1”,”arg2”这样的，显然不符号我们的要求，因此，我们需要**在java compiler选项里加上<code>-parameters</code>**，这样获取的参数数组就是带名字的了:</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5jpd5xrjw480.webp\" alt=\"带parameters选项的获取参数\"></p>\n<p>获取到参数的名字后，我们就可以使用参数名去获取请求中存储的值了:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Parameter[] parameters = method.getParameters();<br><span class=\"hljs-comment\">/*用于存取参数对应的值*/</span><br>Object[] parameterValues = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>[parameters.length];<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt; parameters.length;i++)&#123;<br>    <span class=\"hljs-comment\">/*处理参数中有特殊的情况*/</span><br>    <span class=\"hljs-keyword\">if</span>(parameters[i].getName().equals(<span class=\"hljs-string\">&quot;req&quot;</span>))&#123;<br>        parameterValues[i] = req;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(parameters[i].getName().equals(<span class=\"hljs-string\">&quot;resp&quot;</span>))&#123;<br>        parameterValues[i] = resp;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(parameters[i].getName().equals(<span class=\"hljs-string\">&quot;session&quot;</span>))&#123;<br>        parameterValues[i] = req.getSession();<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">parameterName</span> <span class=\"hljs-operator\">=</span> parameters[i].getName();<br>        parameterValues[i] = req.getParameter(parameterName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>但是这还没完。如果这个时候我们直接<code>method.invoke(controllerBeanObject,parameterValues)</code>的话，很容易出现下列异常：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.4356l2iavo80.webp\" alt=\"IllegalArgumentException\"></p>\n<p>问题就出在，我们提供的参数类型和实际参数的类型对不上，<code>req.getParameter</code>得到的可以转成String,但是如果参数是Integer，那么就会报出上面的异常，处理方法就是<strong>通过分析参数的类型信息，进行类型转换</strong>，最后的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">parameterName</span> <span class=\"hljs-operator\">=</span> parameters[i].getName();<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">parameterValue</span> <span class=\"hljs-operator\">=</span> req.getParameter(parameterName);<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">typeName</span> <span class=\"hljs-operator\">=</span> parameters[i].getType().getName();<br><span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">parameterObject</span> <span class=\"hljs-operator\">=</span> parameterValue;<br><span class=\"hljs-keyword\">if</span>(parameterObject!=<span class=\"hljs-literal\">null</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">&quot;java.lang.Integer&quot;</span>.equals(typeName))&#123;<br>        parameterObject = Integer.parseInt(parameterValue);<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(...)&#123;<br>        <br>    &#125;<br>&#125;<br>parameterValues[i] = parameterObject;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"提取资源跳转\"><a href=\"#提取资源跳转\" class=\"headerlink\" title=\"提取资源跳转\"></a>提取资源跳转</h2><p>这部分就比较简单了，我们只要在Dispatcher中分析del的返回值就好了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">returnObj</span> <span class=\"hljs-operator\">=</span> method.invoke(<span class=\"hljs-built_in\">this</span>,req,resp);<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">methodReturnStr</span> <span class=\"hljs-operator\">=</span> (String) returnObj;<br><br><span class=\"hljs-keyword\">if</span>(methodReturnStr.startsWith(<span class=\"hljs-string\">&quot;redirect:&quot;</span>))&#123;<br>\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">redirectStr</span> <span class=\"hljs-operator\">=</span> methodReturnStr.substring(<span class=\"hljs-string\">&quot;redirect:&quot;</span>.length());<br>\tresp.sendRedirect(redirectStr);<br>&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>    <span class=\"hljs-comment\">/*Thymeleaf模板跳转*/</span><br>\t<span class=\"hljs-built_in\">super</span>.processTemplate(methodReturnStr,req,resp);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>以上的部分对实际开发并没有什么用，因为不可能比框架写得更好，考虑得更周到，但是其思路是值得借鉴和学习的，尤其是如何处理冗余的代码。</p>\n","site":{"data":{}},"more":"<p>在学习Javaweb基础的时候，遇到了一个优化Servlet的过程，我觉得有必要记录下优化的过程，这其中体现了一些设计模式和规范。</p>\n<h1 id=\"优化前项目的结构和问题\"><a href=\"#优化前项目的结构和问题\" class=\"headerlink\" title=\"优化前项目的结构和问题\"></a>优化前项目的结构和问题</h1><p>优化前的项目，其基本思路就是<u>服务器接受请求，然后通过路径的映射，找到对应的Servlet来处理请求</u>。比如url路径为<code>localhost:8080/elibrary/admin?operate=del?id=1</code>，那么服务器会通过<code>/admin/del</code>找到<code>AdminDelServlet</code>，然后获取参数<code>id</code>，对数据库进行删除操作。大致流程如下图所示：</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1hz7bss0nd34.webp\" alt=\"image\" style=\"zoom: 67%;\" /></div>\n\n<p>这种结构有一个很突出的问题就是<strong>Servlet太多了</strong>，随着项目的开发，管理难度会越来越大，那么怎么解决呢？</p>\n<h1 id=\"优化1：合并增删查改\"><a href=\"#优化1：合并增删查改\" class=\"headerlink\" title=\"优化1：合并增删查改\"></a>优化1：合并增删查改</h1><p>解决办法也很简单，我们把一个实体对应的操作合并为一个Servlet，比如把<code>AdminDelServlet</code>、<code>AdminAddServlet</code>、<code>AdminEditServlet</code>合并为一个<code>AdminServlet</code>，合并后的Servlet根据Switch-Case来选择具体的操作，合并后的示意图如下：</p>\n<div align=center><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.hn7h791qaog.webp\" alt=\"image\" style=\"zoom:67%;\" /></div>\n\n\n<p>代码示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@WebServlet(&quot;/admin&quot;)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AdminServlet</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">HttpServlet</span>&#123;<br>    <span class=\"hljs-meta\">@override</span><br>    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">service</span><span class=\"hljs-params\">(HttpservletRequest req,HttpServletResponse resp)</span>&#123;<br>        operate = req.getParameter(<span class=\"hljs-string\">&quot;operate&quot;</span>);<br>        <span class=\"hljs-keyword\">switch</span>(operate)&#123;<br>            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;del&quot;</span>: <br>                del(...);<br>                <span class=\"hljs-keyword\">break</span>;<br>            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;add&quot;</span>:<br>                add(...);<br>                <span class=\"hljs-keyword\">break</span>;<br>            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;edit&quot;</span>:<br>                edit(...);<br>                <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>        <br>    &#125;<br>    <span class=\"hljs-comment\">//原来的AmdinAddServlet替换成下面的add()</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(...)</span>&#123;<br>        ...<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">del</span><span class=\"hljs-params\">(...)</span>&#123;<br>        ...<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">edit</span><span class=\"hljs-params\">(...)</span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样写又引出了一个问题：<u>如果一个实体对应的操作很多，那我们的switch-case岂不是得变得特别长</u>？我们能不能优化一下这一部分呢？</p>\n<p>我们可以用反射来代替上面的代码，示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//后去AdminServlet的所有方法</span><br>Method[] methods = <span class=\"hljs-built_in\">this</span>.getClass.getDeclaredMethods();<br><span class=\"hljs-keyword\">for</span>(Method m : methods)&#123;<br>\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">methodName</span> <span class=\"hljs-operator\">=</span> m.getName();<br>\t<span class=\"hljs-keyword\">if</span>(operate.equals(methodName))&#123;<br>\t\t<span class=\"hljs-keyword\">try</span>&#123;<br>\t\t\tm.invoke(<span class=\"hljs-built_in\">this</span>,request,response);<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过反射机制，我们大大缩减了代码量，不管我们写多少具体操作，这段选择具体操作的代码都不会增多。这样，我们就完成了第一步的优化。</p>\n<h1 id=\"优化2-：引入DispatcherServlet\"><a href=\"#优化2-：引入DispatcherServlet\" class=\"headerlink\" title=\"优化2 ：引入DispatcherServlet\"></a>优化2 ：引入DispatcherServlet</h1><p>上节我们使用反射优化了AdminServlet中选择操作的代码，解决了代码量膨胀的问题。与这种情况类似的是，我们的实体也会有很多，比如实际项目中会有许多个类似AdminServlet的Servlet，这其中必然<strong>存在许多冗余的代码</strong>，比如说上节的反射机制选择操作，每个实体Servlet都会有这么一段代码。我们要优化的一个重要部分就是<strong>代码的冗余</strong>，<font color=purple><strong>基本解决方法就是将冗余的这部分提取出来到一个通用的处理器里</strong></font>。</p>\n<p>我们引入一个<code>DispatcherServlet</code>，然后把<code>AdminServlet</code>中的反射选择操作提取出来。</p>\n<p>我们首先要想办法选择<code>AdminServlet</code>，这该怎么办呢？url路径中的<code>/admin</code>对应了<code>AdminServlet</code>，这是一个映射，<u>我们只需要在一个文件里保留这层映射关系，就能通过java获取到<code>AdminServlet</code>的实例</u>。我们创建一个<code>applicationContext.xml</code>：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=<span class=\"hljs-string\">&quot;1.0&quot;</span> encoding=<span class=\"hljs-string\">&quot;utf-8&quot;</span> ?&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;admin&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;...&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>接下来，只要分析xml，就可以得出映射关系，我们将映射关系存到beanMap里:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">InputStream</span> <span class=\"hljs-variable\">inputStream</span> <span class=\"hljs-operator\">=</span> getClass().getClassLoader().getResourceAsStream(<span class=\"hljs-string\">&quot;applicationContext.xml&quot;</span>);<br><span class=\"hljs-type\">DocumentBuilderFactory</span> <span class=\"hljs-variable\">documentBuilderFactory</span> <span class=\"hljs-operator\">=</span> DocumentBuilderFactory.newInstance();<br><span class=\"hljs-type\">DocumentBuilder</span> <span class=\"hljs-variable\">documentBuilder</span> <span class=\"hljs-operator\">=</span> documentBuilderFactory.newDocumentBuilder();<br><br><span class=\"hljs-type\">Document</span> <span class=\"hljs-variable\">document</span> <span class=\"hljs-operator\">=</span> documentBuilder.parse(inputStream);<br><br><span class=\"hljs-type\">NodeList</span> <span class=\"hljs-variable\">beanNodeList</span> <span class=\"hljs-operator\">=</span> document.getElementsByTagName(<span class=\"hljs-string\">&quot;bean&quot;</span>);<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;beanNodeList.getLength(); i++)&#123;<br>    <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">beanNode</span> <span class=\"hljs-operator\">=</span> beanNodeList.item(i);<br>    <span class=\"hljs-keyword\">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE)&#123;<br>        <span class=\"hljs-type\">Element</span> <span class=\"hljs-variable\">beanElement</span> <span class=\"hljs-operator\">=</span> (Element) beanNode;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">beanId</span> <span class=\"hljs-operator\">=</span> beanElement.getAttribute(<span class=\"hljs-string\">&quot;id&quot;</span>);<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">className</span> <span class=\"hljs-operator\">=</span> beanElement.getAttribute(<span class=\"hljs-string\">&quot;class&quot;</span>);<br>        <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">beanObj</span> <span class=\"hljs-operator\">=</span> Class.forName(className).newInstance();<br>        <span class=\"hljs-comment\">/*将映射关系存到一个beanMap里*/</span><br>        beanMap.put(beanId,beanObj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>得到映射关系后，我们就要想办法从<strong>请求</strong>中得到对应``AdminServlet`的字符串，然后调用AdminServlet方法，这部分思路就很清晰了，直接substring一下url路径就行了:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">servletPath</span> <span class=\"hljs-operator\">=</span> req.getServletPath();\t\t <span class=\"hljs-comment\">//servletPath = &quot;/admin&quot;</span><br>servletPath = servletPath.substring(<span class=\"hljs-number\">1</span>);\t\t\t\t<span class=\"hljs-comment\">//servletPath = &quot;admin&quot;</span><br><span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">controllerBeanObj</span> <span class=\"hljs-operator\">=</span> beanMap.get(servletPath);\t<span class=\"hljs-comment\">//controllerBeanObj = AdminServlet</span><br></code></pre></td></tr></table></figure>\n\n<p>与之相同的道理，我们还可以获取具体操作的字符串，也就是为调用AdminServlet具体的方法做准备：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">operate</span> <span class=\"hljs-operator\">=</span> req.getParameter(<span class=\"hljs-string\">&quot;operate&quot;</span>);<br><span class=\"hljs-keyword\">if</span>(StringUtils.isEmpty(operate))&#123;<br>\toperate = <span class=\"hljs-string\">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>获取到实例后，我们就要开始提取<strong>反射选择具体方法的代码</strong>了，我们直接从AdminServlet中提取这部分代码，然后转移到DispatcherServlet中，并且修改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">url = localhost:8080/porjectname/admin?operate=del&amp;id=2</span><br><span class=\"hljs-comment\">servletPath = &quot;admin&quot;</span><br><span class=\"hljs-comment\">operate = &quot;del&quot;</span><br><span class=\"hljs-comment\">*/</span><br>Method[] methods = controllerBeanObj.getClass().getDeclaredMethods();<br><span class=\"hljs-keyword\">for</span>(Method method : methods)&#123;<br>\t<span class=\"hljs-keyword\">if</span>(operate.equals(method.getName()))&#123;<br>\t\tmethod.setAccessible(<span class=\"hljs-literal\">true</span>);<br>        method.invoke(controllerBeanObj,req,resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"优化三：提取视图资源处理和获取参数\"><a href=\"#优化三：提取视图资源处理和获取参数\" class=\"headerlink\" title=\"优化三：提取视图资源处理和获取参数\"></a>优化三：提取视图资源处理和获取参数</h1><p>优化还没结束，我们还是遵循相同的底层逻辑——<strong>提取冗余的代码</strong>，那么还有哪些冗余的代码呢？</p>\n<ol>\n<li>获取参数的部分，每个具体操作都要从req中获取不同的参数。</li>\n<li>资源的跳转：服务器的内部转发、重定向和交给视图模板处理的代码都是冗余的</li>\n</ol>\n<h2 id=\"提取获取参数的代码\"><a href=\"#提取获取参数的代码\" class=\"headerlink\" title=\"提取获取参数的代码\"></a>提取获取参数的代码</h2><p>我们来看一个具体操作del()的示例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AdminServlet</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">HttpServlet</span>&#123;<br>    service(...)&#123;<br>        <span class=\"hljs-comment\">/*empty，因为仅存的选择方法的反射代码也被提取到了Dispatchet中*/</span><br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">del</span><span class=\"hljs-params\">(HttpServletRequest req,HttpServletResponse resp)</span>&#123;<br>\t\t\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> req.getParameter(<span class=\"hljs-string\">&quot;id&quot;</span>);<br>            ...<span class=\"hljs-comment\">//业务逻辑</span><br>             resp.sendRedirect(<span class=\"hljs-string\">&quot;index&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们要做的优化，<strong>就是把getParameter和sendRedirect这两步步放到Dispatcher里</strong>，修改后的del应该是这个样子的:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AdminServlet</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">HttpServlet</span>&#123;<br>    service(...)&#123;<br>        <span class=\"hljs-comment\">/*empty，因为仅存的选择方法的反射代码也被提取到了Dispatchet中*/</span><br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">del</span><span class=\"hljs-params\">(String id)</span>&#123;<br>            ...<span class=\"hljs-comment\">//业务逻辑</span><br>             <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;redirect:index&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们先来看看如何提取获取参数的代码，基本思路还是<u>利用反射去获取del方法的所有参数名，取得del方法的参数名后去req里获取请求的参数</u>。method刚才已经取得了，获取其参数的类型以及名称只要一句就够了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Parameter[] parameters = method.getParameters();<br></code></pre></td></tr></table></figure>\n\n<p>但是这样取出的参数名，我们会发现是“arg0”,”arg1”,”arg2”这样的，显然不符号我们的要求，因此，我们需要**在java compiler选项里加上<code>-parameters</code>**，这样获取的参数数组就是带名字的了:</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5jpd5xrjw480.webp\" alt=\"带parameters选项的获取参数\"></p>\n<p>获取到参数的名字后，我们就可以使用参数名去获取请求中存储的值了:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Parameter[] parameters = method.getParameters();<br><span class=\"hljs-comment\">/*用于存取参数对应的值*/</span><br>Object[] parameterValues = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>[parameters.length];<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt; parameters.length;i++)&#123;<br>    <span class=\"hljs-comment\">/*处理参数中有特殊的情况*/</span><br>    <span class=\"hljs-keyword\">if</span>(parameters[i].getName().equals(<span class=\"hljs-string\">&quot;req&quot;</span>))&#123;<br>        parameterValues[i] = req;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(parameters[i].getName().equals(<span class=\"hljs-string\">&quot;resp&quot;</span>))&#123;<br>        parameterValues[i] = resp;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(parameters[i].getName().equals(<span class=\"hljs-string\">&quot;session&quot;</span>))&#123;<br>        parameterValues[i] = req.getSession();<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">parameterName</span> <span class=\"hljs-operator\">=</span> parameters[i].getName();<br>        parameterValues[i] = req.getParameter(parameterName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>但是这还没完。如果这个时候我们直接<code>method.invoke(controllerBeanObject,parameterValues)</code>的话，很容易出现下列异常：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.4356l2iavo80.webp\" alt=\"IllegalArgumentException\"></p>\n<p>问题就出在，我们提供的参数类型和实际参数的类型对不上，<code>req.getParameter</code>得到的可以转成String,但是如果参数是Integer，那么就会报出上面的异常，处理方法就是<strong>通过分析参数的类型信息，进行类型转换</strong>，最后的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">parameterName</span> <span class=\"hljs-operator\">=</span> parameters[i].getName();<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">parameterValue</span> <span class=\"hljs-operator\">=</span> req.getParameter(parameterName);<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">typeName</span> <span class=\"hljs-operator\">=</span> parameters[i].getType().getName();<br><span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">parameterObject</span> <span class=\"hljs-operator\">=</span> parameterValue;<br><span class=\"hljs-keyword\">if</span>(parameterObject!=<span class=\"hljs-literal\">null</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">&quot;java.lang.Integer&quot;</span>.equals(typeName))&#123;<br>        parameterObject = Integer.parseInt(parameterValue);<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(...)&#123;<br>        <br>    &#125;<br>&#125;<br>parameterValues[i] = parameterObject;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"提取资源跳转\"><a href=\"#提取资源跳转\" class=\"headerlink\" title=\"提取资源跳转\"></a>提取资源跳转</h2><p>这部分就比较简单了，我们只要在Dispatcher中分析del的返回值就好了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">returnObj</span> <span class=\"hljs-operator\">=</span> method.invoke(<span class=\"hljs-built_in\">this</span>,req,resp);<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">methodReturnStr</span> <span class=\"hljs-operator\">=</span> (String) returnObj;<br><br><span class=\"hljs-keyword\">if</span>(methodReturnStr.startsWith(<span class=\"hljs-string\">&quot;redirect:&quot;</span>))&#123;<br>\t<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">redirectStr</span> <span class=\"hljs-operator\">=</span> methodReturnStr.substring(<span class=\"hljs-string\">&quot;redirect:&quot;</span>.length());<br>\tresp.sendRedirect(redirectStr);<br>&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>    <span class=\"hljs-comment\">/*Thymeleaf模板跳转*/</span><br>\t<span class=\"hljs-built_in\">super</span>.processTemplate(methodReturnStr,req,resp);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>以上的部分对实际开发并没有什么用，因为不可能比框架写得更好，考虑得更周到，但是其思路是值得借鉴和学习的，尤其是如何处理冗余的代码。</p>\n"},{"title":"事务管理基础","date":"2022-11-18T03:44:09.000Z","banner_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1etvdeo7ddy8.webp","index_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1etvdeo7ddy8.webp","excerpt":"通过编写简单的事务管理Filter了解事务管理的思想","_content":"\n# Filter基础\n\n在了解事务管理之前，我们得先知道Filter相关的知识。\n\nFilter是Java Web三大组件之一，其主要作用在于**拦截请求**。当客户端请求某个Servlet时，服务器会首先执行负责拦截这个请求的Filter，Filter会先执行一些操作。执行完后，如果Filter放行，那么请求会送到其原来匹配的Servlet；如果不放行，请求是送不到Servlet的。\n\nFilter的工作原理如下：\n\n![Filter](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.651381l7u8k0.webp)\n\n下面来看一个简单的Filter:\n\n```java\n@WebFilter(\"/filter\")\npublic class SampleFilter1 implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"FilterSample1 : Filtering...\");\n        String message = servletRequest.getParameter(\"message\");\n        if(\"monster\".equals(message)){\n            /*放行，之后执行之后的代码*/\n            filterChain.doFilter(servletRequest,servletResponse);\n            System.out.println(\"放行后拦截响应\");\n        }else{\n            servletRequest.getRequestDispatcher(\"/\").forward(servletRequest,servletResponse);\n        }\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n\n```\n\n从上面这个例子，我们可以总结出Filter的三要素：\n\n---\n\n1. **拦截**：就是把对应的请求拦截下来，这样才能做后续的操作，其重点在于**该拦截哪些请求？该怎么匹配？**\n2. **过滤**：就是对拦截到的请求做一些处理。\n3. **放行**：当过滤器完成任务后，就可以放行该请求，让其访问本该访问的资源\n\n---\n\n以上就是Filter的基础内容。\n\n# 引入事务管理\n\n我们先来看一个**没有事务管理**的项目结构：\n\n![项目结构](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.elbl6cia3ls.webp)\n\nLoginController里的业务方法会调用LoginService里的底层业务方法，而LoginService里的方法会调用许多不同的DAO层方法，即与数据库进行交互。那么，现在问题来了：\n\n目前DAO事务管理的基本API如下所示：\n\n```java\n/*DAO层事务管理*/\n1. 获取连接，取消自动提交 conn.setAutoCommit(false);\ntry{\n    2. 执行操作\n    3. 提交事务 conn.commit();\n}catch(Exception e){\n    4. 回滚事务 conn.rollback();\n}\n```\n\n现在LoginService下的方法，会用到DAO1,DAO2,DAO3三个方法，<u>**如果DAO1和DAO2成功了，但是DAO3失败了，那么这次service到底是算失败了还是成功了呢**</u>？\n\n举个例子，现在A转账给B，A那边的钱扣了，后台的转账业务也完成了，但是B那边的钱没有增加，那么这次service是成功还是失败了呢？\n\n答案当然是**失败**了，service的操作应该是一个**整体**，<font color=purple>**不能是部分成功，部分失败。事务管理不能以DAO的单精度方法为单位，而是以业务层的方法为单位**</font>。\n\n我们在`DispatcherServlet`之前，引入一个`OpenSessionInViewFilter`，用于事务管理：\n\n![OpenSessionInViewFilter](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.12mpzqy6kd3k.webp)\n\n# Connection与ThreadLocal\n\n现在我们的目标是要让**DAO1、DAO2与DAO3共成败**，而三者操作的目标都是`Connection`对象。所以，现在的首要解决的问题是，<u>**如何让这三个DAO操作同一个Connection，只有这样才可以让三个操作同属于一个事务**</u>。\n\n我们首先就很容易想到一个方法，那就是<u>传参</u>，每个DAO方法都带一个Connection对象参数，但这很明显不是一个很好的方法，太繁琐了。在这里，我们要引入一个**ThreadLocal**。\n\n## Java ThreadLocal基础\n\n多线程是Java实现多任务的基础，**Thread对象**就代表一个线程，`Thread.currentThread()`可以用于获取当前线程，比如**打印线程的名字**：\n\n```java\npackage thread;\npublic class ThreadSample {\n\tpublic static void main(String[] args) throws Exception {\n\t\tlog(\"main starts...\");\n\t\tnew Thread(() -> {\n\t\t\tlog(\"run task...\");\n\t\t}).start();\n\t\tnew Thread(() -> {\n\t\t\tlog(\"print...\");\n\t\t}).start();\n\t\tlog(\"main ends.\");\n\t}\n\t\n\tstatic void log(String s) {\n\t\tSystem.out.println(Thread.currentThread().getName() + \": \" + s);\n\t}\n}\n```\n\n![运行结果](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5ow1x9u4ye00.webp)\n\n通过Java的线程池，我们就能方便地执行多任务，像Web应用就是典型的多任务应用，我们可以假设一次请求需要创建下面这样一个任务：\n\n```java\npublic void process1(User user){\n    checkPermission();\n    work();\n    saveStatus();\n    sendResponse();\n}\n```\n\n我们可以发现一个问题，就和上面我们需要同一个Connection一样，**这里的user参数怎么传给其调用的各方法呢**？\n\n第一种方法就是我们上面提到的传参：\n\n```java\npublic void process1(User user){\n    checkPermission(user);\n    work(user);\n    saveStatus(user);\n    sendResponse(user);\n}\n```\n\n> 像这种在一个线程中，横跨若干方法调用，需要传递的对象，称为**Context**，其是一种状态，比如用户的身份ID，任务的相关信息等等\n\n给每个方法都加一个Context参数会非常麻烦，如果遇到不可修改源码的第三方库，那就传不过去了，那该怎么办呢？Java提供了一个`ThreadLocal`，其<u>**可以在一个线程中传递同一个对象**</u>，其实例一般以静态属性初始化：\n\n```java\nstatic ThreadLocal<User> threadLocalUser = new ThreadLocal<>();\n```\n\n这样设置后，在移除之前，所有方法都可以随时获取到该User实例：\n\n```java\nvoid process(User user) {\n\ttry{\n        threadLocalUser.set(user);\n        work1();\n        work2();\n    }finally{\n        threadLocalUser.remove();\n    }\n}\n```\n\n```java\nvoid work1(){\n    User u = threadLocalUser.get();\n    print(u);\n}\n\nvoid work1(){\n    User u = threadLocalUser.get();\n    print(u)\n}\n\n```\n\n<u>普通的方法调用一定是在同一个线程执行的，所以这些方法和threadLocalUser里的User实例都是同一个对象</u>。\n\n我们可以把ThreadLocal看作一个全局Map<Thread,object>，每个线程获取ThreadLocal变量时，都是使用自身Thread去作为key取得变量。因此，`ThreadLocal`相当于<u>给每个线程都开辟了一个独立的存储空间</u>，各个线程的`ThreadLocal`关联的实例**互不干扰**。\n\n## 使用ThreadLocal存储Connection\n\n引入ThreadLocal之后，我们就可以着手存储Connection了，在**数据库连接的工具类**中，我们可以这么写：\n\n```java\npublic class JdbcUtils {\n    private static String url;\n    private static String user;\n    private static String password;\n    private static String driver;\n    private static ThreadLocal<Connection>  threadLocal = new ThreadLocal<>();\n\n    public JdbcUtils(){}\n    /*从jdbc.properties文件中读取连接的相关参数，并初始化成员*/\n    static{\n        try {\n            Properties pro = new Properties();\n            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(\"/static/jdbc.properties\");\n            pro.load(in);\n            url = pro.getProperty(\"url\");\n            user = pro.getProperty(\"user\");\n            password = pro.getProperty(\"password\");\n            driver = pro.getProperty(\"driver\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\t/*获取同一个Connection*/\n    public static Connection getConnection() throws SQLException {\n        Connection conn = threadLocal.get();\n        if(conn == null){\t\t\t\t\t\t\t//如果threadLocal里还未设置Connection\n            conn = createConnection();\t   //新建一个Connection\n            threadLocal.set(conn);\n        }\n        return threadLocal.get();\n    }\n\t/*新建一个Connection实例*/\n    public static Connection createConnection() throws SQLException{\n        try{\n            Class.forName(driver);\n            return DriverManager.getConnection(url,user,password);\n\n        }catch(ClassNotFoundException e){\n            e.printStackTrace();\n        }\n        return null;\n    }\n    \n\t/*关闭Connection*/\n    public static void closeConn() throws SQLException {\n        Connection conn = threadLocal.get();\n        if(conn==null){\n            return;\n        }\n        if(!conn.isClosed()){\n            conn.close();\n            threadLocal.set(null);\n        }\n    }\n\n    public static void close(ResultSet rs, Statement st, Connection conn){\n       ...\n    }\n}\n```\n\n# 编写TransActionManager\n\n为了方便事务管理，我们封装一些基础的事务管理代码到一个`TransActionManager类`里，其主要有三个方法：**开启事务beginTrans()**、**提交事务commit()**和**回滚事务rollback()**。\n\n```java\npublic class TransActionManager {\n    /*开启事务*/\n    public static void beginTrans() throws SQLException {\n        JdbcUtils.getConnection().setAutoCommit(false);\n    }\n\n    /*提交事务*/\n    public static void commit() throws SQLException {\n        Connection conn = JdbcUtils.getConnection();\n        conn.commit();\n        JdbcUtils.closeConn();//提交完事务后，关闭connection\n    }\n\n    /*回滚事务*/\n    public static void rollback() throws SQLException {\n        Connection conn = JdbcUtils.getConnection();\n        conn.rollback();\n        JdbcUtils.closeConn();//回滚完事务后，关闭connection\n    }\n}\n```\n\n> 当然，这里只是简单的示例，实际的事务管理要复杂的多。\n\n之后，我们会在负责事务管理的OpenSessionInViewFilter中调用这些事务管理方法\n\n# 编写OpenSessionInViewFilter\n\n事务管理的逻辑如下：\n\n```java\n@WebFilter(\"/login\")\npublic class OpenSessionInViewFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        try{\n            // System.out.println(\"启动事务\");\n            TransActionManager.beginTrans();\t\t\t\t\t\t\t//开启事务\n            filterChain.doFilter(servletRequest,servletResponse);//放行\n            //System.out.println(\"提交事务\");\n            TransActionManager.commit();\t\t\t\t\t\t\t\t\t//提交事务\n        }catch (Exception e){\n            e.printStackTrace();\n            try{\n               // System.out.println(\"回滚事务\");\n                TransActionManager.rollback();\t\t\t\t\t\t\t\t\t//失败了回滚事务\n            }catch(SQLException ex){\n                ex.printStackTrace();\n            }\n        }\n    }\n    @Override\n    public void destroy() {\n\n    }\n}\n```\n\n# 关于异常\n\n如果DAO层失败了，就会抛出异常，如果该异常被OpenSessionInViewFilter下面的模块捕获道理，比如LoginController或者LoginService，那么Filter这一层就捕获不到异常，捕获不到就不会回滚，那么就出问题了。\n\n所以我们要**让下层抛出一个异常让Filter来捕获**，我们可以自定义异常，具体的细节就不多说了。","source":"_posts/事务管理基础.md","raw":"---\ntitle: 事务管理基础\ndate: 2022-11-18 11:44:09\ntags:\n- JavaWeb\ncategories:\n- web开发\n- java web\nbanner_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1etvdeo7ddy8.webp\nindex_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1etvdeo7ddy8.webp\nexcerpt: 通过编写简单的事务管理Filter了解事务管理的思想\n---\n\n# Filter基础\n\n在了解事务管理之前，我们得先知道Filter相关的知识。\n\nFilter是Java Web三大组件之一，其主要作用在于**拦截请求**。当客户端请求某个Servlet时，服务器会首先执行负责拦截这个请求的Filter，Filter会先执行一些操作。执行完后，如果Filter放行，那么请求会送到其原来匹配的Servlet；如果不放行，请求是送不到Servlet的。\n\nFilter的工作原理如下：\n\n![Filter](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.651381l7u8k0.webp)\n\n下面来看一个简单的Filter:\n\n```java\n@WebFilter(\"/filter\")\npublic class SampleFilter1 implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"FilterSample1 : Filtering...\");\n        String message = servletRequest.getParameter(\"message\");\n        if(\"monster\".equals(message)){\n            /*放行，之后执行之后的代码*/\n            filterChain.doFilter(servletRequest,servletResponse);\n            System.out.println(\"放行后拦截响应\");\n        }else{\n            servletRequest.getRequestDispatcher(\"/\").forward(servletRequest,servletResponse);\n        }\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n\n```\n\n从上面这个例子，我们可以总结出Filter的三要素：\n\n---\n\n1. **拦截**：就是把对应的请求拦截下来，这样才能做后续的操作，其重点在于**该拦截哪些请求？该怎么匹配？**\n2. **过滤**：就是对拦截到的请求做一些处理。\n3. **放行**：当过滤器完成任务后，就可以放行该请求，让其访问本该访问的资源\n\n---\n\n以上就是Filter的基础内容。\n\n# 引入事务管理\n\n我们先来看一个**没有事务管理**的项目结构：\n\n![项目结构](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.elbl6cia3ls.webp)\n\nLoginController里的业务方法会调用LoginService里的底层业务方法，而LoginService里的方法会调用许多不同的DAO层方法，即与数据库进行交互。那么，现在问题来了：\n\n目前DAO事务管理的基本API如下所示：\n\n```java\n/*DAO层事务管理*/\n1. 获取连接，取消自动提交 conn.setAutoCommit(false);\ntry{\n    2. 执行操作\n    3. 提交事务 conn.commit();\n}catch(Exception e){\n    4. 回滚事务 conn.rollback();\n}\n```\n\n现在LoginService下的方法，会用到DAO1,DAO2,DAO3三个方法，<u>**如果DAO1和DAO2成功了，但是DAO3失败了，那么这次service到底是算失败了还是成功了呢**</u>？\n\n举个例子，现在A转账给B，A那边的钱扣了，后台的转账业务也完成了，但是B那边的钱没有增加，那么这次service是成功还是失败了呢？\n\n答案当然是**失败**了，service的操作应该是一个**整体**，<font color=purple>**不能是部分成功，部分失败。事务管理不能以DAO的单精度方法为单位，而是以业务层的方法为单位**</font>。\n\n我们在`DispatcherServlet`之前，引入一个`OpenSessionInViewFilter`，用于事务管理：\n\n![OpenSessionInViewFilter](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.12mpzqy6kd3k.webp)\n\n# Connection与ThreadLocal\n\n现在我们的目标是要让**DAO1、DAO2与DAO3共成败**，而三者操作的目标都是`Connection`对象。所以，现在的首要解决的问题是，<u>**如何让这三个DAO操作同一个Connection，只有这样才可以让三个操作同属于一个事务**</u>。\n\n我们首先就很容易想到一个方法，那就是<u>传参</u>，每个DAO方法都带一个Connection对象参数，但这很明显不是一个很好的方法，太繁琐了。在这里，我们要引入一个**ThreadLocal**。\n\n## Java ThreadLocal基础\n\n多线程是Java实现多任务的基础，**Thread对象**就代表一个线程，`Thread.currentThread()`可以用于获取当前线程，比如**打印线程的名字**：\n\n```java\npackage thread;\npublic class ThreadSample {\n\tpublic static void main(String[] args) throws Exception {\n\t\tlog(\"main starts...\");\n\t\tnew Thread(() -> {\n\t\t\tlog(\"run task...\");\n\t\t}).start();\n\t\tnew Thread(() -> {\n\t\t\tlog(\"print...\");\n\t\t}).start();\n\t\tlog(\"main ends.\");\n\t}\n\t\n\tstatic void log(String s) {\n\t\tSystem.out.println(Thread.currentThread().getName() + \": \" + s);\n\t}\n}\n```\n\n![运行结果](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5ow1x9u4ye00.webp)\n\n通过Java的线程池，我们就能方便地执行多任务，像Web应用就是典型的多任务应用，我们可以假设一次请求需要创建下面这样一个任务：\n\n```java\npublic void process1(User user){\n    checkPermission();\n    work();\n    saveStatus();\n    sendResponse();\n}\n```\n\n我们可以发现一个问题，就和上面我们需要同一个Connection一样，**这里的user参数怎么传给其调用的各方法呢**？\n\n第一种方法就是我们上面提到的传参：\n\n```java\npublic void process1(User user){\n    checkPermission(user);\n    work(user);\n    saveStatus(user);\n    sendResponse(user);\n}\n```\n\n> 像这种在一个线程中，横跨若干方法调用，需要传递的对象，称为**Context**，其是一种状态，比如用户的身份ID，任务的相关信息等等\n\n给每个方法都加一个Context参数会非常麻烦，如果遇到不可修改源码的第三方库，那就传不过去了，那该怎么办呢？Java提供了一个`ThreadLocal`，其<u>**可以在一个线程中传递同一个对象**</u>，其实例一般以静态属性初始化：\n\n```java\nstatic ThreadLocal<User> threadLocalUser = new ThreadLocal<>();\n```\n\n这样设置后，在移除之前，所有方法都可以随时获取到该User实例：\n\n```java\nvoid process(User user) {\n\ttry{\n        threadLocalUser.set(user);\n        work1();\n        work2();\n    }finally{\n        threadLocalUser.remove();\n    }\n}\n```\n\n```java\nvoid work1(){\n    User u = threadLocalUser.get();\n    print(u);\n}\n\nvoid work1(){\n    User u = threadLocalUser.get();\n    print(u)\n}\n\n```\n\n<u>普通的方法调用一定是在同一个线程执行的，所以这些方法和threadLocalUser里的User实例都是同一个对象</u>。\n\n我们可以把ThreadLocal看作一个全局Map<Thread,object>，每个线程获取ThreadLocal变量时，都是使用自身Thread去作为key取得变量。因此，`ThreadLocal`相当于<u>给每个线程都开辟了一个独立的存储空间</u>，各个线程的`ThreadLocal`关联的实例**互不干扰**。\n\n## 使用ThreadLocal存储Connection\n\n引入ThreadLocal之后，我们就可以着手存储Connection了，在**数据库连接的工具类**中，我们可以这么写：\n\n```java\npublic class JdbcUtils {\n    private static String url;\n    private static String user;\n    private static String password;\n    private static String driver;\n    private static ThreadLocal<Connection>  threadLocal = new ThreadLocal<>();\n\n    public JdbcUtils(){}\n    /*从jdbc.properties文件中读取连接的相关参数，并初始化成员*/\n    static{\n        try {\n            Properties pro = new Properties();\n            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(\"/static/jdbc.properties\");\n            pro.load(in);\n            url = pro.getProperty(\"url\");\n            user = pro.getProperty(\"user\");\n            password = pro.getProperty(\"password\");\n            driver = pro.getProperty(\"driver\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\t/*获取同一个Connection*/\n    public static Connection getConnection() throws SQLException {\n        Connection conn = threadLocal.get();\n        if(conn == null){\t\t\t\t\t\t\t//如果threadLocal里还未设置Connection\n            conn = createConnection();\t   //新建一个Connection\n            threadLocal.set(conn);\n        }\n        return threadLocal.get();\n    }\n\t/*新建一个Connection实例*/\n    public static Connection createConnection() throws SQLException{\n        try{\n            Class.forName(driver);\n            return DriverManager.getConnection(url,user,password);\n\n        }catch(ClassNotFoundException e){\n            e.printStackTrace();\n        }\n        return null;\n    }\n    \n\t/*关闭Connection*/\n    public static void closeConn() throws SQLException {\n        Connection conn = threadLocal.get();\n        if(conn==null){\n            return;\n        }\n        if(!conn.isClosed()){\n            conn.close();\n            threadLocal.set(null);\n        }\n    }\n\n    public static void close(ResultSet rs, Statement st, Connection conn){\n       ...\n    }\n}\n```\n\n# 编写TransActionManager\n\n为了方便事务管理，我们封装一些基础的事务管理代码到一个`TransActionManager类`里，其主要有三个方法：**开启事务beginTrans()**、**提交事务commit()**和**回滚事务rollback()**。\n\n```java\npublic class TransActionManager {\n    /*开启事务*/\n    public static void beginTrans() throws SQLException {\n        JdbcUtils.getConnection().setAutoCommit(false);\n    }\n\n    /*提交事务*/\n    public static void commit() throws SQLException {\n        Connection conn = JdbcUtils.getConnection();\n        conn.commit();\n        JdbcUtils.closeConn();//提交完事务后，关闭connection\n    }\n\n    /*回滚事务*/\n    public static void rollback() throws SQLException {\n        Connection conn = JdbcUtils.getConnection();\n        conn.rollback();\n        JdbcUtils.closeConn();//回滚完事务后，关闭connection\n    }\n}\n```\n\n> 当然，这里只是简单的示例，实际的事务管理要复杂的多。\n\n之后，我们会在负责事务管理的OpenSessionInViewFilter中调用这些事务管理方法\n\n# 编写OpenSessionInViewFilter\n\n事务管理的逻辑如下：\n\n```java\n@WebFilter(\"/login\")\npublic class OpenSessionInViewFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        try{\n            // System.out.println(\"启动事务\");\n            TransActionManager.beginTrans();\t\t\t\t\t\t\t//开启事务\n            filterChain.doFilter(servletRequest,servletResponse);//放行\n            //System.out.println(\"提交事务\");\n            TransActionManager.commit();\t\t\t\t\t\t\t\t\t//提交事务\n        }catch (Exception e){\n            e.printStackTrace();\n            try{\n               // System.out.println(\"回滚事务\");\n                TransActionManager.rollback();\t\t\t\t\t\t\t\t\t//失败了回滚事务\n            }catch(SQLException ex){\n                ex.printStackTrace();\n            }\n        }\n    }\n    @Override\n    public void destroy() {\n\n    }\n}\n```\n\n# 关于异常\n\n如果DAO层失败了，就会抛出异常，如果该异常被OpenSessionInViewFilter下面的模块捕获道理，比如LoginController或者LoginService，那么Filter这一层就捕获不到异常，捕获不到就不会回滚，那么就出问题了。\n\n所以我们要**让下层抛出一个异常让Filter来捕获**，我们可以自定义异常，具体的细节就不多说了。","slug":"事务管理基础","published":1,"updated":"2022-11-20T07:41:09.085Z","_id":"clap1pte80000u4ru3gz0024k","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Filter基础\"><a href=\"#Filter基础\" class=\"headerlink\" title=\"Filter基础\"></a>Filter基础</h1><p>在了解事务管理之前，我们得先知道Filter相关的知识。</p>\n<p>Filter是Java Web三大组件之一，其主要作用在于<strong>拦截请求</strong>。当客户端请求某个Servlet时，服务器会首先执行负责拦截这个请求的Filter，Filter会先执行一些操作。执行完后，如果Filter放行，那么请求会送到其原来匹配的Servlet；如果不放行，请求是送不到Servlet的。</p>\n<p>Filter的工作原理如下：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.651381l7u8k0.webp\" alt=\"Filter\"></p>\n<p>下面来看一个简单的Filter:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@WebFilter(&quot;/filter&quot;)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SampleFilter1</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Filter</span> &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">init</span><span class=\"hljs-params\">(FilterConfig filterConfig)</span> <span class=\"hljs-keyword\">throws</span> ServletException &#123;<br><br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doFilter</span><span class=\"hljs-params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"hljs-keyword\">throws</span> IOException, ServletException &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;FilterSample1 : Filtering...&quot;</span>);<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">message</span> <span class=\"hljs-operator\">=</span> servletRequest.getParameter(<span class=\"hljs-string\">&quot;message&quot;</span>);<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">&quot;monster&quot;</span>.equals(message))&#123;<br>            <span class=\"hljs-comment\">/*放行，之后执行之后的代码*/</span><br>            filterChain.doFilter(servletRequest,servletResponse);<br>            System.out.println(<span class=\"hljs-string\">&quot;放行后拦截响应&quot;</span>);<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            servletRequest.getRequestDispatcher(<span class=\"hljs-string\">&quot;/&quot;</span>).forward(servletRequest,servletResponse);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">destroy</span><span class=\"hljs-params\">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>从上面这个例子，我们可以总结出Filter的三要素：</p>\n<hr>\n<ol>\n<li><strong>拦截</strong>：就是把对应的请求拦截下来，这样才能做后续的操作，其重点在于<strong>该拦截哪些请求？该怎么匹配？</strong></li>\n<li><strong>过滤</strong>：就是对拦截到的请求做一些处理。</li>\n<li><strong>放行</strong>：当过滤器完成任务后，就可以放行该请求，让其访问本该访问的资源</li>\n</ol>\n<hr>\n<p>以上就是Filter的基础内容。</p>\n<h1 id=\"引入事务管理\"><a href=\"#引入事务管理\" class=\"headerlink\" title=\"引入事务管理\"></a>引入事务管理</h1><p>我们先来看一个<strong>没有事务管理</strong>的项目结构：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.elbl6cia3ls.webp\" alt=\"项目结构\"></p>\n<p>LoginController里的业务方法会调用LoginService里的底层业务方法，而LoginService里的方法会调用许多不同的DAO层方法，即与数据库进行交互。那么，现在问题来了：</p>\n<p>目前DAO事务管理的基本API如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/*DAO层事务管理*/</span><br><span class=\"hljs-number\">1.</span> 获取连接，取消自动提交 conn.setAutoCommit(<span class=\"hljs-literal\">false</span>);<br><span class=\"hljs-keyword\">try</span>&#123;<br>    <span class=\"hljs-number\">2.</span> 执行操作<br>    <span class=\"hljs-number\">3.</span> 提交事务 conn.commit();<br>&#125;<span class=\"hljs-keyword\">catch</span>(Exception e)&#123;<br>    <span class=\"hljs-number\">4.</span> 回滚事务 conn.rollback();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>现在LoginService下的方法，会用到DAO1,DAO2,DAO3三个方法，<u><strong>如果DAO1和DAO2成功了，但是DAO3失败了，那么这次service到底是算失败了还是成功了呢</strong></u>？</p>\n<p>举个例子，现在A转账给B，A那边的钱扣了，后台的转账业务也完成了，但是B那边的钱没有增加，那么这次service是成功还是失败了呢？</p>\n<p>答案当然是<strong>失败</strong>了，service的操作应该是一个<strong>整体</strong>，<font color=purple><strong>不能是部分成功，部分失败。事务管理不能以DAO的单精度方法为单位，而是以业务层的方法为单位</strong></font>。</p>\n<p>我们在<code>DispatcherServlet</code>之前，引入一个<code>OpenSessionInViewFilter</code>，用于事务管理：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.12mpzqy6kd3k.webp\" alt=\"OpenSessionInViewFilter\"></p>\n<h1 id=\"Connection与ThreadLocal\"><a href=\"#Connection与ThreadLocal\" class=\"headerlink\" title=\"Connection与ThreadLocal\"></a>Connection与ThreadLocal</h1><p>现在我们的目标是要让<strong>DAO1、DAO2与DAO3共成败</strong>，而三者操作的目标都是<code>Connection</code>对象。所以，现在的首要解决的问题是，<u><strong>如何让这三个DAO操作同一个Connection，只有这样才可以让三个操作同属于一个事务</strong></u>。</p>\n<p>我们首先就很容易想到一个方法，那就是<u>传参</u>，每个DAO方法都带一个Connection对象参数，但这很明显不是一个很好的方法，太繁琐了。在这里，我们要引入一个<strong>ThreadLocal</strong>。</p>\n<h2 id=\"Java-ThreadLocal基础\"><a href=\"#Java-ThreadLocal基础\" class=\"headerlink\" title=\"Java ThreadLocal基础\"></a>Java ThreadLocal基础</h2><p>多线程是Java实现多任务的基础，<strong>Thread对象</strong>就代表一个线程，<code>Thread.currentThread()</code>可以用于获取当前线程，比如<strong>打印线程的名字</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> thread;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ThreadSample</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>\t\tlog(<span class=\"hljs-string\">&quot;main starts...&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(() -&gt; &#123;<br>\t\t\tlog(<span class=\"hljs-string\">&quot;run task...&quot;</span>);<br>\t\t&#125;).start();<br>\t\t<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(() -&gt; &#123;<br>\t\t\tlog(<span class=\"hljs-string\">&quot;print...&quot;</span>);<br>\t\t&#125;).start();<br>\t\tlog(<span class=\"hljs-string\">&quot;main ends.&quot;</span>);<br>\t&#125;<br>\t<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">log</span><span class=\"hljs-params\">(String s)</span> &#123;<br>\t\tSystem.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">&quot;: &quot;</span> + s);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5ow1x9u4ye00.webp\" alt=\"运行结果\"></p>\n<p>通过Java的线程池，我们就能方便地执行多任务，像Web应用就是典型的多任务应用，我们可以假设一次请求需要创建下面这样一个任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">process1</span><span class=\"hljs-params\">(User user)</span>&#123;<br>    checkPermission();<br>    work();<br>    saveStatus();<br>    sendResponse();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们可以发现一个问题，就和上面我们需要同一个Connection一样，<strong>这里的user参数怎么传给其调用的各方法呢</strong>？</p>\n<p>第一种方法就是我们上面提到的传参：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">process1</span><span class=\"hljs-params\">(User user)</span>&#123;<br>    checkPermission(user);<br>    work(user);<br>    saveStatus(user);<br>    sendResponse(user);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>像这种在一个线程中，横跨若干方法调用，需要传递的对象，称为<strong>Context</strong>，其是一种状态，比如用户的身份ID，任务的相关信息等等</p>\n</blockquote>\n<p>给每个方法都加一个Context参数会非常麻烦，如果遇到不可修改源码的第三方库，那就传不过去了，那该怎么办呢？Java提供了一个<code>ThreadLocal</code>，其<u><strong>可以在一个线程中传递同一个对象</strong></u>，其实例一般以静态属性初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ThreadLocal</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>\n\n<p>这样设置后，在移除之前，所有方法都可以随时获取到该User实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">process</span><span class=\"hljs-params\">(User user)</span> &#123;<br>\t<span class=\"hljs-keyword\">try</span>&#123;<br>        threadLocalUser.set(user);<br>        work1();<br>        work2();<br>    &#125;<span class=\"hljs-keyword\">finally</span>&#123;<br>        threadLocalUser.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">work1</span><span class=\"hljs-params\">()</span>&#123;<br>    <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">u</span> <span class=\"hljs-operator\">=</span> threadLocalUser.get();<br>    print(u);<br>&#125;<br><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">work1</span><span class=\"hljs-params\">()</span>&#123;<br>    <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">u</span> <span class=\"hljs-operator\">=</span> threadLocalUser.get();<br>    print(u)<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p><u>普通的方法调用一定是在同一个线程执行的，所以这些方法和threadLocalUser里的User实例都是同一个对象</u>。</p>\n<p>我们可以把ThreadLocal看作一个全局Map&lt;Thread,object&gt;，每个线程获取ThreadLocal变量时，都是使用自身Thread去作为key取得变量。因此，<code>ThreadLocal</code>相当于<u>给每个线程都开辟了一个独立的存储空间</u>，各个线程的<code>ThreadLocal</code>关联的实例<strong>互不干扰</strong>。</p>\n<h2 id=\"使用ThreadLocal存储Connection\"><a href=\"#使用ThreadLocal存储Connection\" class=\"headerlink\" title=\"使用ThreadLocal存储Connection\"></a>使用ThreadLocal存储Connection</h2><p>引入ThreadLocal之后，我们就可以着手存储Connection了，在<strong>数据库连接的工具类</strong>中，我们可以这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JdbcUtils</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> String url;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> String user;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> String password;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> String driver;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> ThreadLocal&lt;Connection&gt;  threadLocal = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ThreadLocal</span>&lt;&gt;();<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">JdbcUtils</span><span class=\"hljs-params\">()</span>&#123;&#125;<br>    <span class=\"hljs-comment\">/*从jdbc.properties文件中读取连接的相关参数，并初始化成员*/</span><br>    <span class=\"hljs-keyword\">static</span>&#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-type\">Properties</span> <span class=\"hljs-variable\">pro</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Properties</span>();<br>            <span class=\"hljs-type\">InputStream</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> JdbcUtils.class.getClassLoader().getResourceAsStream(<span class=\"hljs-string\">&quot;/static/jdbc.properties&quot;</span>);<br>            pro.load(in);<br>            url = pro.getProperty(<span class=\"hljs-string\">&quot;url&quot;</span>);<br>            user = pro.getProperty(<span class=\"hljs-string\">&quot;user&quot;</span>);<br>            password = pro.getProperty(<span class=\"hljs-string\">&quot;password&quot;</span>);<br>            driver = pro.getProperty(<span class=\"hljs-string\">&quot;driver&quot;</span>);<br>        &#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>\t<span class=\"hljs-comment\">/*获取同一个Connection*/</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Connection <span class=\"hljs-title function_\">getConnection</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException &#123;<br>        <span class=\"hljs-type\">Connection</span> <span class=\"hljs-variable\">conn</span> <span class=\"hljs-operator\">=</span> threadLocal.get();<br>        <span class=\"hljs-keyword\">if</span>(conn == <span class=\"hljs-literal\">null</span>)&#123;\t\t\t\t\t\t\t<span class=\"hljs-comment\">//如果threadLocal里还未设置Connection</span><br>            conn = createConnection();\t   <span class=\"hljs-comment\">//新建一个Connection</span><br>            threadLocal.set(conn);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> threadLocal.get();<br>    &#125;<br>\t<span class=\"hljs-comment\">/*新建一个Connection实例*/</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Connection <span class=\"hljs-title function_\">createConnection</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException&#123;<br>        <span class=\"hljs-keyword\">try</span>&#123;<br>            Class.forName(driver);<br>            <span class=\"hljs-keyword\">return</span> DriverManager.getConnection(url,user,password);<br><br>        &#125;<span class=\"hljs-keyword\">catch</span>(ClassNotFoundException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>    &#125;<br>    <br>\t<span class=\"hljs-comment\">/*关闭Connection*/</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">closeConn</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException &#123;<br>        <span class=\"hljs-type\">Connection</span> <span class=\"hljs-variable\">conn</span> <span class=\"hljs-operator\">=</span> threadLocal.get();<br>        <span class=\"hljs-keyword\">if</span>(conn==<span class=\"hljs-literal\">null</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(!conn.isClosed())&#123;<br>            conn.close();<br>            threadLocal.set(<span class=\"hljs-literal\">null</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">close</span><span class=\"hljs-params\">(ResultSet rs, Statement st, Connection conn)</span>&#123;<br>       ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"编写TransActionManager\"><a href=\"#编写TransActionManager\" class=\"headerlink\" title=\"编写TransActionManager\"></a>编写TransActionManager</h1><p>为了方便事务管理，我们封装一些基础的事务管理代码到一个<code>TransActionManager类</code>里，其主要有三个方法：**开启事务beginTrans()<strong>、</strong>提交事务commit()<strong>和</strong>回滚事务rollback()**。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TransActionManager</span> &#123;<br>    <span class=\"hljs-comment\">/*开启事务*/</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">beginTrans</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException &#123;<br>        JdbcUtils.getConnection().setAutoCommit(<span class=\"hljs-literal\">false</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/*提交事务*/</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">commit</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException &#123;<br>        <span class=\"hljs-type\">Connection</span> <span class=\"hljs-variable\">conn</span> <span class=\"hljs-operator\">=</span> JdbcUtils.getConnection();<br>        conn.commit();<br>        JdbcUtils.closeConn();<span class=\"hljs-comment\">//提交完事务后，关闭connection</span><br>    &#125;<br><br>    <span class=\"hljs-comment\">/*回滚事务*/</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">rollback</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException &#123;<br>        <span class=\"hljs-type\">Connection</span> <span class=\"hljs-variable\">conn</span> <span class=\"hljs-operator\">=</span> JdbcUtils.getConnection();<br>        conn.rollback();<br>        JdbcUtils.closeConn();<span class=\"hljs-comment\">//回滚完事务后，关闭connection</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当然，这里只是简单的示例，实际的事务管理要复杂的多。</p>\n</blockquote>\n<p>之后，我们会在负责事务管理的OpenSessionInViewFilter中调用这些事务管理方法</p>\n<h1 id=\"编写OpenSessionInViewFilter\"><a href=\"#编写OpenSessionInViewFilter\" class=\"headerlink\" title=\"编写OpenSessionInViewFilter\"></a>编写OpenSessionInViewFilter</h1><p>事务管理的逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@WebFilter(&quot;/login&quot;)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OpenSessionInViewFilter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Filter</span> &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">init</span><span class=\"hljs-params\">(FilterConfig filterConfig)</span> <span class=\"hljs-keyword\">throws</span> ServletException &#123;<br><br>    &#125;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doFilter</span><span class=\"hljs-params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"hljs-keyword\">throws</span> IOException, ServletException &#123;<br>        <span class=\"hljs-keyword\">try</span>&#123;<br>            <span class=\"hljs-comment\">// System.out.println(&quot;启动事务&quot;);</span><br>            TransActionManager.beginTrans();\t\t\t\t\t\t\t<span class=\"hljs-comment\">//开启事务</span><br>            filterChain.doFilter(servletRequest,servletResponse);<span class=\"hljs-comment\">//放行</span><br>            <span class=\"hljs-comment\">//System.out.println(&quot;提交事务&quot;);</span><br>            TransActionManager.commit();\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//提交事务</span><br>        &#125;<span class=\"hljs-keyword\">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>            <span class=\"hljs-keyword\">try</span>&#123;<br>               <span class=\"hljs-comment\">// System.out.println(&quot;回滚事务&quot;);</span><br>                TransActionManager.rollback();\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//失败了回滚事务</span><br>            &#125;<span class=\"hljs-keyword\">catch</span>(SQLException ex)&#123;<br>                ex.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">destroy</span><span class=\"hljs-params\">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"关于异常\"><a href=\"#关于异常\" class=\"headerlink\" title=\"关于异常\"></a>关于异常</h1><p>如果DAO层失败了，就会抛出异常，如果该异常被OpenSessionInViewFilter下面的模块捕获道理，比如LoginController或者LoginService，那么Filter这一层就捕获不到异常，捕获不到就不会回滚，那么就出问题了。</p>\n<p>所以我们要<strong>让下层抛出一个异常让Filter来捕获</strong>，我们可以自定义异常，具体的细节就不多说了。</p>\n","site":{"data":{}},"more":"<h1 id=\"Filter基础\"><a href=\"#Filter基础\" class=\"headerlink\" title=\"Filter基础\"></a>Filter基础</h1><p>在了解事务管理之前，我们得先知道Filter相关的知识。</p>\n<p>Filter是Java Web三大组件之一，其主要作用在于<strong>拦截请求</strong>。当客户端请求某个Servlet时，服务器会首先执行负责拦截这个请求的Filter，Filter会先执行一些操作。执行完后，如果Filter放行，那么请求会送到其原来匹配的Servlet；如果不放行，请求是送不到Servlet的。</p>\n<p>Filter的工作原理如下：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.651381l7u8k0.webp\" alt=\"Filter\"></p>\n<p>下面来看一个简单的Filter:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@WebFilter(&quot;/filter&quot;)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SampleFilter1</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Filter</span> &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">init</span><span class=\"hljs-params\">(FilterConfig filterConfig)</span> <span class=\"hljs-keyword\">throws</span> ServletException &#123;<br><br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doFilter</span><span class=\"hljs-params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"hljs-keyword\">throws</span> IOException, ServletException &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;FilterSample1 : Filtering...&quot;</span>);<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">message</span> <span class=\"hljs-operator\">=</span> servletRequest.getParameter(<span class=\"hljs-string\">&quot;message&quot;</span>);<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">&quot;monster&quot;</span>.equals(message))&#123;<br>            <span class=\"hljs-comment\">/*放行，之后执行之后的代码*/</span><br>            filterChain.doFilter(servletRequest,servletResponse);<br>            System.out.println(<span class=\"hljs-string\">&quot;放行后拦截响应&quot;</span>);<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            servletRequest.getRequestDispatcher(<span class=\"hljs-string\">&quot;/&quot;</span>).forward(servletRequest,servletResponse);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">destroy</span><span class=\"hljs-params\">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>从上面这个例子，我们可以总结出Filter的三要素：</p>\n<hr>\n<ol>\n<li><strong>拦截</strong>：就是把对应的请求拦截下来，这样才能做后续的操作，其重点在于<strong>该拦截哪些请求？该怎么匹配？</strong></li>\n<li><strong>过滤</strong>：就是对拦截到的请求做一些处理。</li>\n<li><strong>放行</strong>：当过滤器完成任务后，就可以放行该请求，让其访问本该访问的资源</li>\n</ol>\n<hr>\n<p>以上就是Filter的基础内容。</p>\n<h1 id=\"引入事务管理\"><a href=\"#引入事务管理\" class=\"headerlink\" title=\"引入事务管理\"></a>引入事务管理</h1><p>我们先来看一个<strong>没有事务管理</strong>的项目结构：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.elbl6cia3ls.webp\" alt=\"项目结构\"></p>\n<p>LoginController里的业务方法会调用LoginService里的底层业务方法，而LoginService里的方法会调用许多不同的DAO层方法，即与数据库进行交互。那么，现在问题来了：</p>\n<p>目前DAO事务管理的基本API如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/*DAO层事务管理*/</span><br><span class=\"hljs-number\">1.</span> 获取连接，取消自动提交 conn.setAutoCommit(<span class=\"hljs-literal\">false</span>);<br><span class=\"hljs-keyword\">try</span>&#123;<br>    <span class=\"hljs-number\">2.</span> 执行操作<br>    <span class=\"hljs-number\">3.</span> 提交事务 conn.commit();<br>&#125;<span class=\"hljs-keyword\">catch</span>(Exception e)&#123;<br>    <span class=\"hljs-number\">4.</span> 回滚事务 conn.rollback();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>现在LoginService下的方法，会用到DAO1,DAO2,DAO3三个方法，<u><strong>如果DAO1和DAO2成功了，但是DAO3失败了，那么这次service到底是算失败了还是成功了呢</strong></u>？</p>\n<p>举个例子，现在A转账给B，A那边的钱扣了，后台的转账业务也完成了，但是B那边的钱没有增加，那么这次service是成功还是失败了呢？</p>\n<p>答案当然是<strong>失败</strong>了，service的操作应该是一个<strong>整体</strong>，<font color=purple><strong>不能是部分成功，部分失败。事务管理不能以DAO的单精度方法为单位，而是以业务层的方法为单位</strong></font>。</p>\n<p>我们在<code>DispatcherServlet</code>之前，引入一个<code>OpenSessionInViewFilter</code>，用于事务管理：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.12mpzqy6kd3k.webp\" alt=\"OpenSessionInViewFilter\"></p>\n<h1 id=\"Connection与ThreadLocal\"><a href=\"#Connection与ThreadLocal\" class=\"headerlink\" title=\"Connection与ThreadLocal\"></a>Connection与ThreadLocal</h1><p>现在我们的目标是要让<strong>DAO1、DAO2与DAO3共成败</strong>，而三者操作的目标都是<code>Connection</code>对象。所以，现在的首要解决的问题是，<u><strong>如何让这三个DAO操作同一个Connection，只有这样才可以让三个操作同属于一个事务</strong></u>。</p>\n<p>我们首先就很容易想到一个方法，那就是<u>传参</u>，每个DAO方法都带一个Connection对象参数，但这很明显不是一个很好的方法，太繁琐了。在这里，我们要引入一个<strong>ThreadLocal</strong>。</p>\n<h2 id=\"Java-ThreadLocal基础\"><a href=\"#Java-ThreadLocal基础\" class=\"headerlink\" title=\"Java ThreadLocal基础\"></a>Java ThreadLocal基础</h2><p>多线程是Java实现多任务的基础，<strong>Thread对象</strong>就代表一个线程，<code>Thread.currentThread()</code>可以用于获取当前线程，比如<strong>打印线程的名字</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> thread;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ThreadSample</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>\t\tlog(<span class=\"hljs-string\">&quot;main starts...&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(() -&gt; &#123;<br>\t\t\tlog(<span class=\"hljs-string\">&quot;run task...&quot;</span>);<br>\t\t&#125;).start();<br>\t\t<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(() -&gt; &#123;<br>\t\t\tlog(<span class=\"hljs-string\">&quot;print...&quot;</span>);<br>\t\t&#125;).start();<br>\t\tlog(<span class=\"hljs-string\">&quot;main ends.&quot;</span>);<br>\t&#125;<br>\t<br>\t<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">log</span><span class=\"hljs-params\">(String s)</span> &#123;<br>\t\tSystem.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">&quot;: &quot;</span> + s);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5ow1x9u4ye00.webp\" alt=\"运行结果\"></p>\n<p>通过Java的线程池，我们就能方便地执行多任务，像Web应用就是典型的多任务应用，我们可以假设一次请求需要创建下面这样一个任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">process1</span><span class=\"hljs-params\">(User user)</span>&#123;<br>    checkPermission();<br>    work();<br>    saveStatus();<br>    sendResponse();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们可以发现一个问题，就和上面我们需要同一个Connection一样，<strong>这里的user参数怎么传给其调用的各方法呢</strong>？</p>\n<p>第一种方法就是我们上面提到的传参：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">process1</span><span class=\"hljs-params\">(User user)</span>&#123;<br>    checkPermission(user);<br>    work(user);<br>    saveStatus(user);<br>    sendResponse(user);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>像这种在一个线程中，横跨若干方法调用，需要传递的对象，称为<strong>Context</strong>，其是一种状态，比如用户的身份ID，任务的相关信息等等</p>\n</blockquote>\n<p>给每个方法都加一个Context参数会非常麻烦，如果遇到不可修改源码的第三方库，那就传不过去了，那该怎么办呢？Java提供了一个<code>ThreadLocal</code>，其<u><strong>可以在一个线程中传递同一个对象</strong></u>，其实例一般以静态属性初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ThreadLocal</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>\n\n<p>这样设置后，在移除之前，所有方法都可以随时获取到该User实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">process</span><span class=\"hljs-params\">(User user)</span> &#123;<br>\t<span class=\"hljs-keyword\">try</span>&#123;<br>        threadLocalUser.set(user);<br>        work1();<br>        work2();<br>    &#125;<span class=\"hljs-keyword\">finally</span>&#123;<br>        threadLocalUser.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">work1</span><span class=\"hljs-params\">()</span>&#123;<br>    <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">u</span> <span class=\"hljs-operator\">=</span> threadLocalUser.get();<br>    print(u);<br>&#125;<br><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">work1</span><span class=\"hljs-params\">()</span>&#123;<br>    <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">u</span> <span class=\"hljs-operator\">=</span> threadLocalUser.get();<br>    print(u)<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p><u>普通的方法调用一定是在同一个线程执行的，所以这些方法和threadLocalUser里的User实例都是同一个对象</u>。</p>\n<p>我们可以把ThreadLocal看作一个全局Map&lt;Thread,object&gt;，每个线程获取ThreadLocal变量时，都是使用自身Thread去作为key取得变量。因此，<code>ThreadLocal</code>相当于<u>给每个线程都开辟了一个独立的存储空间</u>，各个线程的<code>ThreadLocal</code>关联的实例<strong>互不干扰</strong>。</p>\n<h2 id=\"使用ThreadLocal存储Connection\"><a href=\"#使用ThreadLocal存储Connection\" class=\"headerlink\" title=\"使用ThreadLocal存储Connection\"></a>使用ThreadLocal存储Connection</h2><p>引入ThreadLocal之后，我们就可以着手存储Connection了，在<strong>数据库连接的工具类</strong>中，我们可以这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JdbcUtils</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> String url;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> String user;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> String password;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> String driver;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> ThreadLocal&lt;Connection&gt;  threadLocal = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ThreadLocal</span>&lt;&gt;();<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">JdbcUtils</span><span class=\"hljs-params\">()</span>&#123;&#125;<br>    <span class=\"hljs-comment\">/*从jdbc.properties文件中读取连接的相关参数，并初始化成员*/</span><br>    <span class=\"hljs-keyword\">static</span>&#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-type\">Properties</span> <span class=\"hljs-variable\">pro</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Properties</span>();<br>            <span class=\"hljs-type\">InputStream</span> <span class=\"hljs-variable\">in</span> <span class=\"hljs-operator\">=</span> JdbcUtils.class.getClassLoader().getResourceAsStream(<span class=\"hljs-string\">&quot;/static/jdbc.properties&quot;</span>);<br>            pro.load(in);<br>            url = pro.getProperty(<span class=\"hljs-string\">&quot;url&quot;</span>);<br>            user = pro.getProperty(<span class=\"hljs-string\">&quot;user&quot;</span>);<br>            password = pro.getProperty(<span class=\"hljs-string\">&quot;password&quot;</span>);<br>            driver = pro.getProperty(<span class=\"hljs-string\">&quot;driver&quot;</span>);<br>        &#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>\t<span class=\"hljs-comment\">/*获取同一个Connection*/</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Connection <span class=\"hljs-title function_\">getConnection</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException &#123;<br>        <span class=\"hljs-type\">Connection</span> <span class=\"hljs-variable\">conn</span> <span class=\"hljs-operator\">=</span> threadLocal.get();<br>        <span class=\"hljs-keyword\">if</span>(conn == <span class=\"hljs-literal\">null</span>)&#123;\t\t\t\t\t\t\t<span class=\"hljs-comment\">//如果threadLocal里还未设置Connection</span><br>            conn = createConnection();\t   <span class=\"hljs-comment\">//新建一个Connection</span><br>            threadLocal.set(conn);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> threadLocal.get();<br>    &#125;<br>\t<span class=\"hljs-comment\">/*新建一个Connection实例*/</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Connection <span class=\"hljs-title function_\">createConnection</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException&#123;<br>        <span class=\"hljs-keyword\">try</span>&#123;<br>            Class.forName(driver);<br>            <span class=\"hljs-keyword\">return</span> DriverManager.getConnection(url,user,password);<br><br>        &#125;<span class=\"hljs-keyword\">catch</span>(ClassNotFoundException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>    &#125;<br>    <br>\t<span class=\"hljs-comment\">/*关闭Connection*/</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">closeConn</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException &#123;<br>        <span class=\"hljs-type\">Connection</span> <span class=\"hljs-variable\">conn</span> <span class=\"hljs-operator\">=</span> threadLocal.get();<br>        <span class=\"hljs-keyword\">if</span>(conn==<span class=\"hljs-literal\">null</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(!conn.isClosed())&#123;<br>            conn.close();<br>            threadLocal.set(<span class=\"hljs-literal\">null</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">close</span><span class=\"hljs-params\">(ResultSet rs, Statement st, Connection conn)</span>&#123;<br>       ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"编写TransActionManager\"><a href=\"#编写TransActionManager\" class=\"headerlink\" title=\"编写TransActionManager\"></a>编写TransActionManager</h1><p>为了方便事务管理，我们封装一些基础的事务管理代码到一个<code>TransActionManager类</code>里，其主要有三个方法：**开启事务beginTrans()<strong>、</strong>提交事务commit()<strong>和</strong>回滚事务rollback()**。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TransActionManager</span> &#123;<br>    <span class=\"hljs-comment\">/*开启事务*/</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">beginTrans</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException &#123;<br>        JdbcUtils.getConnection().setAutoCommit(<span class=\"hljs-literal\">false</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/*提交事务*/</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">commit</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException &#123;<br>        <span class=\"hljs-type\">Connection</span> <span class=\"hljs-variable\">conn</span> <span class=\"hljs-operator\">=</span> JdbcUtils.getConnection();<br>        conn.commit();<br>        JdbcUtils.closeConn();<span class=\"hljs-comment\">//提交完事务后，关闭connection</span><br>    &#125;<br><br>    <span class=\"hljs-comment\">/*回滚事务*/</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">rollback</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException &#123;<br>        <span class=\"hljs-type\">Connection</span> <span class=\"hljs-variable\">conn</span> <span class=\"hljs-operator\">=</span> JdbcUtils.getConnection();<br>        conn.rollback();<br>        JdbcUtils.closeConn();<span class=\"hljs-comment\">//回滚完事务后，关闭connection</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当然，这里只是简单的示例，实际的事务管理要复杂的多。</p>\n</blockquote>\n<p>之后，我们会在负责事务管理的OpenSessionInViewFilter中调用这些事务管理方法</p>\n<h1 id=\"编写OpenSessionInViewFilter\"><a href=\"#编写OpenSessionInViewFilter\" class=\"headerlink\" title=\"编写OpenSessionInViewFilter\"></a>编写OpenSessionInViewFilter</h1><p>事务管理的逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@WebFilter(&quot;/login&quot;)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OpenSessionInViewFilter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Filter</span> &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">init</span><span class=\"hljs-params\">(FilterConfig filterConfig)</span> <span class=\"hljs-keyword\">throws</span> ServletException &#123;<br><br>    &#125;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doFilter</span><span class=\"hljs-params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"hljs-keyword\">throws</span> IOException, ServletException &#123;<br>        <span class=\"hljs-keyword\">try</span>&#123;<br>            <span class=\"hljs-comment\">// System.out.println(&quot;启动事务&quot;);</span><br>            TransActionManager.beginTrans();\t\t\t\t\t\t\t<span class=\"hljs-comment\">//开启事务</span><br>            filterChain.doFilter(servletRequest,servletResponse);<span class=\"hljs-comment\">//放行</span><br>            <span class=\"hljs-comment\">//System.out.println(&quot;提交事务&quot;);</span><br>            TransActionManager.commit();\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//提交事务</span><br>        &#125;<span class=\"hljs-keyword\">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>            <span class=\"hljs-keyword\">try</span>&#123;<br>               <span class=\"hljs-comment\">// System.out.println(&quot;回滚事务&quot;);</span><br>                TransActionManager.rollback();\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//失败了回滚事务</span><br>            &#125;<span class=\"hljs-keyword\">catch</span>(SQLException ex)&#123;<br>                ex.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">destroy</span><span class=\"hljs-params\">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"关于异常\"><a href=\"#关于异常\" class=\"headerlink\" title=\"关于异常\"></a>关于异常</h1><p>如果DAO层失败了，就会抛出异常，如果该异常被OpenSessionInViewFilter下面的模块捕获道理，比如LoginController或者LoginService，那么Filter这一层就捕获不到异常，捕获不到就不会回滚，那么就出问题了。</p>\n<p>所以我们要<strong>让下层抛出一个异常让Filter来捕获</strong>，我们可以自定义异常，具体的细节就不多说了。</p>\n"},{"title":"稀疏矩阵及其运算","date":"2022-11-21T03:44:09.000Z","banner_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.50i8vx9da3o0.webp","index_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.50i8vx9da3o0.webp","excerpt":"复习稀疏矩阵","_content":"\n# 稀疏矩阵（数组）简介\n\n假设我们现在要写一个五子棋程序，其中有<u>保存当前棋盘</u>和<u>恢复上次棋盘</u>的功能，那么显然需要一种方法去保存棋盘。我们很容易想到用一个**二维数组**去保留棋盘：\n\n![五子棋](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6q07k59ehhw0.webp)\n\n我们可以看到棋盘上有许多空白，<u>这些无意义的空白数据都占据着存储空间</u>，我们实际需要保存的只是**棋子的位置和值**，而不是整个棋盘，那么我们怎么去掉这些无意义的数据呢？\n\n首先， 上面这种无意义数据占大多数的二维矩阵被称为**稀疏矩阵**，其判别条件是：\n\n> 假设有$m * n$的矩阵，其有t个非0元素，那么设$δ = \\frac{t}{m * n}$，δ被称为稀疏因子，如果δ<=0.05，那么该矩阵就是稀疏矩阵。\n\n针对于稀疏矩阵，我们可以用三元表来保存其**行列数**、**非0元素的数量**以及**各非0元素的位置**，比如上面的棋盘就可以用下面这样的稀疏矩阵表示：\n\n|      |    row     |    col     |      val       |\n| :--: | :--------: | :--------: | :------------: |\n|  0   | 11（行数） | 11（列数） | 2（非0元素数） |\n|  1   |     1      |     2      |       1        |\n|  2   |     2      |     3      |       2        |\n\n\n\n# 稀疏矩阵与矩阵之间的转换\n\n稀疏矩阵与矩阵之间的转换思路比较简单，下面只作简单的梳理。\n\n<p class=\"note note-primary\">矩阵→稀疏矩阵</p>\n\n1. 遍历矩阵，得到非0元素数`numCount`。\n2. 然后用`numCount`初始化稀疏矩阵`sparseArr[numCount+1][3]`，`numCount+1`是因为`sparseArr[0]`要存储矩阵的行列数，以及非0元素数。\n3. 之后遍历矩阵，存储非0元素数即可。\n\n```java\n/*统计非0元素数*/\nint numCount = 0;\nfor(int[] row : chessArr1){\n\tfor(int num : row){\n\t\tif(num !=0){\n\t\t\tnumCount++;\n\t\t}\n\t}\n}\n\nint sparseArr[][] = new int[numCount+1][3];\n/*第一行存储矩阵的行列数、非0元素数*/\nsparseArr[0][0] = sparseArr[0][1] =11;\nsparseArr[0][2] = numCount;\nint index = 1;\nfor(int i=0;i<chessArr1.length;i++){\n\tfor(int j=0;j<chessArr1.length;j++){\n\t\tif(chessArr1[i][j]!=0){\n\t\t\tsparseArr[index][0] = i;\n\t\t\tsparseArr[index][1] = j;\n\t\t\tsparseArr[index++][2] = chessArr1[i][j];\n\t\t}\n\t}\n}\n```\n\n<p class=\"note note-primary\">稀疏矩阵→矩阵</p>\n\n这就没什么好说的了：\n\n```java\nint[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];\nfor(int i=1;i<sparseArr.length;i++){\n\tchessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];\n}\n```\n\n# 稀疏矩阵的快速转置\n\n<div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2ioamg882ww0.webp\" alt=\"image\" style=\"zoom:50%;\" /></div>\n\n稀疏矩阵的快速转置是稀疏矩阵的重点，其基本思想就是**空间换时间**，下面我们来看看。\n\n设我们现在有这样一个三元表a(**省略掉a[0]**)用于存储稀疏矩阵M：\n\n| row  | col  | val  |\n| :--: | :--: | :--: |\n|  1   |  2   |  12  |\n|  1   |  3   |  9   |\n|  3   |  1   |  -3  |\n|  3   |  6   |  14  |\n|  4   |  3   |  24  |\n|  5   |  2   |  15  |\n|  6   |  1   |  18  |\n|  6   |  4   |  7   |\n\n矩阵转置就是将<u>元素的行列调换</u>，我们这里也很简单，就直接调换行列就好了，但是三元表是**按顺序存储**的，所以调换完后，我们还要按行排序，正确的转置后三元表b应该如下所示：\n\n| row  | col  | val  |\n| :--: | :--: | :--: |\n|  1   |  3   |  -3  |\n|  1   |  6   |  18  |\n|  2   |  1   |  12  |\n|  2   |  5   |  15  |\n|  3   |  1   |  9   |\n|  3   |  4   |  24  |\n|  4   |  6   |  -7  |\n|  6   |  3   |  14  |\n\n根据上述思路，我们可以看出重点就在于这个<font color=purple>**次序的问题**</font>上，根据对次序的不同处理方式，我们就有了两种转置的方法。\n\n## 扫描转置法\n\n这个方法很简单，就是**扫描三元表a的第二列来转置**，a的第二列也就是列序，a的列序就是b的行序。其算法复杂度很明显是$O（n^2）$，时间复杂度太高了，这种方法就不多加赘述了。\n\n## 快速转置法\n\n如果我们**知道三元表a中的每一项在转置后的新三元表b中的位置**，然后直接放上去，那不就不需要$O(n^2)$的时间复杂度了？快速转置正是基于这种思路实现的。\n\n那么我们怎么知道各项在新三元表中的位置的呢？\n\n> 下面的`a:col=2`表示a中某项的`col列`值为2的情况。\n\n注意三元表a的col就是新三元表b的row，**我们开始读a的col列**。a的第一项的col是2，因为a：col=2就是b：row=2，所以在b中占据第3、4行，那么就从第3位开始放，接下来如果又读到一个a：col=2，那么就放在第4位，因为a：col=2只有两项，所以b的第五位不会被b : row=2占据，b的第5、6位是留给b : row = 3的。通过这种思想，我们就能在三元表中找到相应的位置，这就是稀疏矩阵的原理。\n\n下面我们来实现这个算法。\n\n<p class=\"note note-primary\">空间换时间：求num[]和cpot[]</p>\n\n首先，我们需要两个变量：\n\n---\n\n- num[col]：用于记录原三元表a: col = col的项的数目。\n- cpot[col]：用于记录原三元表a中列数为col的项在新三元表中的首位置，例如col=2，则cpot[col]=3。\n\n---\n\n那么三元表a的num[]和cpot[]值为：\n\n|    col    |  1   |  2   |  3   |  4   |  5   |  6   |  7   |\n| :-------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n| num[col]  |  2   |  2   |  2   |  1   |  0   |  1   |  0   |\n| cpot[col] |  1   |  3   |  5   |  7   |  8   |  8   |  9   |\n\n求这两数组的代码如下：\n\n```java\nint[][] M = ...;\t\t\t\t //转置前的稀疏矩阵M\nint[][] sparseArrA = ...;  //转置前的三元表A\nint[][] sparseArrB = ...;  //转置后的三元表B\nint[] num = new int[M[0].length+1];\nint[] cpot = new int[num.length];\n\nfor(int col=1;col<=num.length;col++){\n    num[col] = 0;\n}\n/*初始化num[]，统计每列各有多少个非0元素*/\nfor(int t=1;t<sparseArrA.length;t++){\n\t/*num[三元表Acol列]++*/\n    num[sparseArrA[t][1]]++\n}\n\n/*根据num[]初始化cpot[col]，统计a每一列的元素在b中的位置*/\ncpot[1] = 1\nfor(int p=2;p<cpot.length;p++){\n    cpot[p] = cpot[p-1]+num[p-1];\n}\n```\n\n<p class=\"note note-primary\">快速转置</p>\n\n下面，我们就可以进行快速转置了，具体步骤如下：\n\n1. 我们遍历三元表A的col列，得到每项的col\n2. 根据col，得到cpot[col]，这就是三元表A中该项在三元表B的位置。\n3. 将该项转置后填入三元表B，然后cpot[col]++。\n\n```java\nfor(int p=1;p<=sparseArrA.length;p++){\n    col = sparseArrA[p][1];\n    q = cpot[col];\n    sparseArrB[q][0] = sparseArrA[p][1];  \n    sparseArrB[q][1] = sparseArrA[p][0];  \n    sparseArrB[q][2] = sparseArrA[p][2];\n    ++cpot[col];\n}\n```\n\n","source":"_posts/稀疏矩阵及其运算.md","raw":"---\ntitle: 稀疏矩阵及其运算\ndate: 2022-11-21 11:44:09\ntags:\n- 矩阵\ncategories:\n- 数据结构和算法\nbanner_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.50i8vx9da3o0.webp\nindex_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.50i8vx9da3o0.webp\nexcerpt: 复习稀疏矩阵\n---\n\n# 稀疏矩阵（数组）简介\n\n假设我们现在要写一个五子棋程序，其中有<u>保存当前棋盘</u>和<u>恢复上次棋盘</u>的功能，那么显然需要一种方法去保存棋盘。我们很容易想到用一个**二维数组**去保留棋盘：\n\n![五子棋](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6q07k59ehhw0.webp)\n\n我们可以看到棋盘上有许多空白，<u>这些无意义的空白数据都占据着存储空间</u>，我们实际需要保存的只是**棋子的位置和值**，而不是整个棋盘，那么我们怎么去掉这些无意义的数据呢？\n\n首先， 上面这种无意义数据占大多数的二维矩阵被称为**稀疏矩阵**，其判别条件是：\n\n> 假设有$m * n$的矩阵，其有t个非0元素，那么设$δ = \\frac{t}{m * n}$，δ被称为稀疏因子，如果δ<=0.05，那么该矩阵就是稀疏矩阵。\n\n针对于稀疏矩阵，我们可以用三元表来保存其**行列数**、**非0元素的数量**以及**各非0元素的位置**，比如上面的棋盘就可以用下面这样的稀疏矩阵表示：\n\n|      |    row     |    col     |      val       |\n| :--: | :--------: | :--------: | :------------: |\n|  0   | 11（行数） | 11（列数） | 2（非0元素数） |\n|  1   |     1      |     2      |       1        |\n|  2   |     2      |     3      |       2        |\n\n\n\n# 稀疏矩阵与矩阵之间的转换\n\n稀疏矩阵与矩阵之间的转换思路比较简单，下面只作简单的梳理。\n\n<p class=\"note note-primary\">矩阵→稀疏矩阵</p>\n\n1. 遍历矩阵，得到非0元素数`numCount`。\n2. 然后用`numCount`初始化稀疏矩阵`sparseArr[numCount+1][3]`，`numCount+1`是因为`sparseArr[0]`要存储矩阵的行列数，以及非0元素数。\n3. 之后遍历矩阵，存储非0元素数即可。\n\n```java\n/*统计非0元素数*/\nint numCount = 0;\nfor(int[] row : chessArr1){\n\tfor(int num : row){\n\t\tif(num !=0){\n\t\t\tnumCount++;\n\t\t}\n\t}\n}\n\nint sparseArr[][] = new int[numCount+1][3];\n/*第一行存储矩阵的行列数、非0元素数*/\nsparseArr[0][0] = sparseArr[0][1] =11;\nsparseArr[0][2] = numCount;\nint index = 1;\nfor(int i=0;i<chessArr1.length;i++){\n\tfor(int j=0;j<chessArr1.length;j++){\n\t\tif(chessArr1[i][j]!=0){\n\t\t\tsparseArr[index][0] = i;\n\t\t\tsparseArr[index][1] = j;\n\t\t\tsparseArr[index++][2] = chessArr1[i][j];\n\t\t}\n\t}\n}\n```\n\n<p class=\"note note-primary\">稀疏矩阵→矩阵</p>\n\n这就没什么好说的了：\n\n```java\nint[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];\nfor(int i=1;i<sparseArr.length;i++){\n\tchessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];\n}\n```\n\n# 稀疏矩阵的快速转置\n\n<div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2ioamg882ww0.webp\" alt=\"image\" style=\"zoom:50%;\" /></div>\n\n稀疏矩阵的快速转置是稀疏矩阵的重点，其基本思想就是**空间换时间**，下面我们来看看。\n\n设我们现在有这样一个三元表a(**省略掉a[0]**)用于存储稀疏矩阵M：\n\n| row  | col  | val  |\n| :--: | :--: | :--: |\n|  1   |  2   |  12  |\n|  1   |  3   |  9   |\n|  3   |  1   |  -3  |\n|  3   |  6   |  14  |\n|  4   |  3   |  24  |\n|  5   |  2   |  15  |\n|  6   |  1   |  18  |\n|  6   |  4   |  7   |\n\n矩阵转置就是将<u>元素的行列调换</u>，我们这里也很简单，就直接调换行列就好了，但是三元表是**按顺序存储**的，所以调换完后，我们还要按行排序，正确的转置后三元表b应该如下所示：\n\n| row  | col  | val  |\n| :--: | :--: | :--: |\n|  1   |  3   |  -3  |\n|  1   |  6   |  18  |\n|  2   |  1   |  12  |\n|  2   |  5   |  15  |\n|  3   |  1   |  9   |\n|  3   |  4   |  24  |\n|  4   |  6   |  -7  |\n|  6   |  3   |  14  |\n\n根据上述思路，我们可以看出重点就在于这个<font color=purple>**次序的问题**</font>上，根据对次序的不同处理方式，我们就有了两种转置的方法。\n\n## 扫描转置法\n\n这个方法很简单，就是**扫描三元表a的第二列来转置**，a的第二列也就是列序，a的列序就是b的行序。其算法复杂度很明显是$O（n^2）$，时间复杂度太高了，这种方法就不多加赘述了。\n\n## 快速转置法\n\n如果我们**知道三元表a中的每一项在转置后的新三元表b中的位置**，然后直接放上去，那不就不需要$O(n^2)$的时间复杂度了？快速转置正是基于这种思路实现的。\n\n那么我们怎么知道各项在新三元表中的位置的呢？\n\n> 下面的`a:col=2`表示a中某项的`col列`值为2的情况。\n\n注意三元表a的col就是新三元表b的row，**我们开始读a的col列**。a的第一项的col是2，因为a：col=2就是b：row=2，所以在b中占据第3、4行，那么就从第3位开始放，接下来如果又读到一个a：col=2，那么就放在第4位，因为a：col=2只有两项，所以b的第五位不会被b : row=2占据，b的第5、6位是留给b : row = 3的。通过这种思想，我们就能在三元表中找到相应的位置，这就是稀疏矩阵的原理。\n\n下面我们来实现这个算法。\n\n<p class=\"note note-primary\">空间换时间：求num[]和cpot[]</p>\n\n首先，我们需要两个变量：\n\n---\n\n- num[col]：用于记录原三元表a: col = col的项的数目。\n- cpot[col]：用于记录原三元表a中列数为col的项在新三元表中的首位置，例如col=2，则cpot[col]=3。\n\n---\n\n那么三元表a的num[]和cpot[]值为：\n\n|    col    |  1   |  2   |  3   |  4   |  5   |  6   |  7   |\n| :-------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n| num[col]  |  2   |  2   |  2   |  1   |  0   |  1   |  0   |\n| cpot[col] |  1   |  3   |  5   |  7   |  8   |  8   |  9   |\n\n求这两数组的代码如下：\n\n```java\nint[][] M = ...;\t\t\t\t //转置前的稀疏矩阵M\nint[][] sparseArrA = ...;  //转置前的三元表A\nint[][] sparseArrB = ...;  //转置后的三元表B\nint[] num = new int[M[0].length+1];\nint[] cpot = new int[num.length];\n\nfor(int col=1;col<=num.length;col++){\n    num[col] = 0;\n}\n/*初始化num[]，统计每列各有多少个非0元素*/\nfor(int t=1;t<sparseArrA.length;t++){\n\t/*num[三元表Acol列]++*/\n    num[sparseArrA[t][1]]++\n}\n\n/*根据num[]初始化cpot[col]，统计a每一列的元素在b中的位置*/\ncpot[1] = 1\nfor(int p=2;p<cpot.length;p++){\n    cpot[p] = cpot[p-1]+num[p-1];\n}\n```\n\n<p class=\"note note-primary\">快速转置</p>\n\n下面，我们就可以进行快速转置了，具体步骤如下：\n\n1. 我们遍历三元表A的col列，得到每项的col\n2. 根据col，得到cpot[col]，这就是三元表A中该项在三元表B的位置。\n3. 将该项转置后填入三元表B，然后cpot[col]++。\n\n```java\nfor(int p=1;p<=sparseArrA.length;p++){\n    col = sparseArrA[p][1];\n    q = cpot[col];\n    sparseArrB[q][0] = sparseArrA[p][1];  \n    sparseArrB[q][1] = sparseArrA[p][0];  \n    sparseArrB[q][2] = sparseArrA[p][2];\n    ++cpot[col];\n}\n```\n\n","slug":"稀疏矩阵及其运算","published":1,"updated":"2022-11-21T04:55:06.396Z","_id":"claqb7e9n0000dsrubw9q2reu","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"稀疏矩阵（数组）简介\"><a href=\"#稀疏矩阵（数组）简介\" class=\"headerlink\" title=\"稀疏矩阵（数组）简介\"></a>稀疏矩阵（数组）简介</h1><p>假设我们现在要写一个五子棋程序，其中有<u>保存当前棋盘</u>和<u>恢复上次棋盘</u>的功能，那么显然需要一种方法去保存棋盘。我们很容易想到用一个<strong>二维数组</strong>去保留棋盘：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6q07k59ehhw0.webp\" alt=\"五子棋\"></p>\n<p>我们可以看到棋盘上有许多空白，<u>这些无意义的空白数据都占据着存储空间</u>，我们实际需要保存的只是<strong>棋子的位置和值</strong>，而不是整个棋盘，那么我们怎么去掉这些无意义的数据呢？</p>\n<p>首先， 上面这种无意义数据占大多数的二维矩阵被称为<strong>稀疏矩阵</strong>，其判别条件是：</p>\n<blockquote>\n<p>假设有$m * n$的矩阵，其有t个非0元素，那么设$δ = \\frac{t}{m * n}$，δ被称为稀疏因子，如果δ&lt;=0.05，那么该矩阵就是稀疏矩阵。</p>\n</blockquote>\n<p>针对于稀疏矩阵，我们可以用三元表来保存其<strong>行列数</strong>、<strong>非0元素的数量</strong>以及<strong>各非0元素的位置</strong>，比如上面的棋盘就可以用下面这样的稀疏矩阵表示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">row</th>\n<th align=\"center\">col</th>\n<th align=\"center\">val</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">11（行数）</td>\n<td align=\"center\">11（列数）</td>\n<td align=\"center\">2（非0元素数）</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">2</td>\n</tr>\n</tbody></table>\n<h1 id=\"稀疏矩阵与矩阵之间的转换\"><a href=\"#稀疏矩阵与矩阵之间的转换\" class=\"headerlink\" title=\"稀疏矩阵与矩阵之间的转换\"></a>稀疏矩阵与矩阵之间的转换</h1><p>稀疏矩阵与矩阵之间的转换思路比较简单，下面只作简单的梳理。</p>\n<p class=\"note note-primary\">矩阵→稀疏矩阵</p>\n\n<ol>\n<li>遍历矩阵，得到非0元素数<code>numCount</code>。</li>\n<li>然后用<code>numCount</code>初始化稀疏矩阵<code>sparseArr[numCount+1][3]</code>，<code>numCount+1</code>是因为<code>sparseArr[0]</code>要存储矩阵的行列数，以及非0元素数。</li>\n<li>之后遍历矩阵，存储非0元素数即可。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/*统计非0元素数*/</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">numCount</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span>[] row : chessArr1)&#123;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> num : row)&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(num !=<span class=\"hljs-number\">0</span>)&#123;<br>\t\t\tnumCount++;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-type\">int</span> sparseArr[][] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[numCount+<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-comment\">/*第一行存储矩阵的行列数、非0元素数*/</span><br>sparseArr[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = sparseArr[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>] =<span class=\"hljs-number\">11</span>;<br>sparseArr[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">2</span>] = numCount;<br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">index</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;chessArr1.length;i++)&#123;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;chessArr1.length;j++)&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(chessArr1[i][j]!=<span class=\"hljs-number\">0</span>)&#123;<br>\t\t\tsparseArr[index][<span class=\"hljs-number\">0</span>] = i;<br>\t\t\tsparseArr[index][<span class=\"hljs-number\">1</span>] = j;<br>\t\t\tsparseArr[index++][<span class=\"hljs-number\">2</span>] = chessArr1[i][j];<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p class=\"note note-primary\">稀疏矩阵→矩阵</p>\n\n<p>这就没什么好说的了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span>[][] chessArr2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[sparseArr[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]][sparseArr[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>]];<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;sparseArr.length;i++)&#123;<br>\tchessArr2[sparseArr[i][<span class=\"hljs-number\">0</span>]][sparseArr[i][<span class=\"hljs-number\">1</span>]] = sparseArr[i][<span class=\"hljs-number\">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"稀疏矩阵的快速转置\"><a href=\"#稀疏矩阵的快速转置\" class=\"headerlink\" title=\"稀疏矩阵的快速转置\"></a>稀疏矩阵的快速转置</h1><div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2ioamg882ww0.webp\" alt=\"image\" style=\"zoom:50%;\" /></div>\n\n<p>稀疏矩阵的快速转置是稀疏矩阵的重点，其基本思想就是<strong>空间换时间</strong>，下面我们来看看。</p>\n<p>设我们现在有这样一个三元表a(<strong>省略掉a[0]</strong>)用于存储稀疏矩阵M：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">row</th>\n<th align=\"center\">col</th>\n<th align=\"center\">val</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">1</td>\n<td align=\"center\">-3</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">6</td>\n<td align=\"center\">14</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">3</td>\n<td align=\"center\">24</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\">2</td>\n<td align=\"center\">15</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">1</td>\n<td align=\"center\">18</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">4</td>\n<td align=\"center\">7</td>\n</tr>\n</tbody></table>\n<p>矩阵转置就是将<u>元素的行列调换</u>，我们这里也很简单，就直接调换行列就好了，但是三元表是<strong>按顺序存储</strong>的，所以调换完后，我们还要按行排序，正确的转置后三元表b应该如下所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">row</th>\n<th align=\"center\">col</th>\n<th align=\"center\">val</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">-3</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">6</td>\n<td align=\"center\">18</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">5</td>\n<td align=\"center\">15</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">1</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">24</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">6</td>\n<td align=\"center\">-7</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">3</td>\n<td align=\"center\">14</td>\n</tr>\n</tbody></table>\n<p>根据上述思路，我们可以看出重点就在于这个<font color=purple><strong>次序的问题</strong></font>上，根据对次序的不同处理方式，我们就有了两种转置的方法。</p>\n<h2 id=\"扫描转置法\"><a href=\"#扫描转置法\" class=\"headerlink\" title=\"扫描转置法\"></a>扫描转置法</h2><p>这个方法很简单，就是<strong>扫描三元表a的第二列来转置</strong>，a的第二列也就是列序，a的列序就是b的行序。其算法复杂度很明显是$O（n^2）$，时间复杂度太高了，这种方法就不多加赘述了。</p>\n<h2 id=\"快速转置法\"><a href=\"#快速转置法\" class=\"headerlink\" title=\"快速转置法\"></a>快速转置法</h2><p>如果我们<strong>知道三元表a中的每一项在转置后的新三元表b中的位置</strong>，然后直接放上去，那不就不需要$O(n^2)$的时间复杂度了？快速转置正是基于这种思路实现的。</p>\n<p>那么我们怎么知道各项在新三元表中的位置的呢？</p>\n<blockquote>\n<p>下面的<code>a:col=2</code>表示a中某项的<code>col列</code>值为2的情况。</p>\n</blockquote>\n<p>注意三元表a的col就是新三元表b的row，<strong>我们开始读a的col列</strong>。a的第一项的col是2，因为a：col=2就是b：row=2，所以在b中占据第3、4行，那么就从第3位开始放，接下来如果又读到一个a：col=2，那么就放在第4位，因为a：col=2只有两项，所以b的第五位不会被b : row=2占据，b的第5、6位是留给b : row = 3的。通过这种思想，我们就能在三元表中找到相应的位置，这就是稀疏矩阵的原理。</p>\n<p>下面我们来实现这个算法。</p>\n<p class=\"note note-primary\">空间换时间：求num[]和cpot[]</p>\n\n<p>首先，我们需要两个变量：</p>\n<hr>\n<ul>\n<li>num[col]：用于记录原三元表a: col = col的项的数目。</li>\n<li>cpot[col]：用于记录原三元表a中列数为col的项在新三元表中的首位置，例如col=2，则cpot[col]=3。</li>\n</ul>\n<hr>\n<p>那么三元表a的num[]和cpot[]值为：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">col</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">num[col]</td>\n<td align=\"center\">2</td>\n<td align=\"center\">2</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">cpot[col]</td>\n<td align=\"center\">1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">7</td>\n<td align=\"center\">8</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n</tbody></table>\n<p>求这两数组的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span>[][] M = ...;\t\t\t\t <span class=\"hljs-comment\">//转置前的稀疏矩阵M</span><br><span class=\"hljs-type\">int</span>[][] sparseArrA = ...;  <span class=\"hljs-comment\">//转置前的三元表A</span><br><span class=\"hljs-type\">int</span>[][] sparseArrB = ...;  <span class=\"hljs-comment\">//转置后的三元表B</span><br><span class=\"hljs-type\">int</span>[] num = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[M[<span class=\"hljs-number\">0</span>].length+<span class=\"hljs-number\">1</span>];<br><span class=\"hljs-type\">int</span>[] cpot = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[num.length];<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> col=<span class=\"hljs-number\">1</span>;col&lt;=num.length;col++)&#123;<br>    num[col] = <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">/*初始化num[]，统计每列各有多少个非0元素*/</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> t=<span class=\"hljs-number\">1</span>;t&lt;sparseArrA.length;t++)&#123;<br>\t<span class=\"hljs-comment\">/*num[三元表Acol列]++*/</span><br>    num[sparseArrA[t][<span class=\"hljs-number\">1</span>]]++<br>&#125;<br><br><span class=\"hljs-comment\">/*根据num[]初始化cpot[col]，统计a每一列的元素在b中的位置*/</span><br>cpot[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> p=<span class=\"hljs-number\">2</span>;p&lt;cpot.length;p++)&#123;<br>    cpot[p] = cpot[p-<span class=\"hljs-number\">1</span>]+num[p-<span class=\"hljs-number\">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p class=\"note note-primary\">快速转置</p>\n\n<p>下面，我们就可以进行快速转置了，具体步骤如下：</p>\n<ol>\n<li>我们遍历三元表A的col列，得到每项的col</li>\n<li>根据col，得到cpot[col]，这就是三元表A中该项在三元表B的位置。</li>\n<li>将该项转置后填入三元表B，然后cpot[col]++。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> p=<span class=\"hljs-number\">1</span>;p&lt;=sparseArrA.length;p++)&#123;<br>    col = sparseArrA[p][<span class=\"hljs-number\">1</span>];<br>    q = cpot[col];<br>    sparseArrB[q][<span class=\"hljs-number\">0</span>] = sparseArrA[p][<span class=\"hljs-number\">1</span>];  <br>    sparseArrB[q][<span class=\"hljs-number\">1</span>] = sparseArrA[p][<span class=\"hljs-number\">0</span>];  <br>    sparseArrB[q][<span class=\"hljs-number\">2</span>] = sparseArrA[p][<span class=\"hljs-number\">2</span>];<br>    ++cpot[col];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"more":"<h1 id=\"稀疏矩阵（数组）简介\"><a href=\"#稀疏矩阵（数组）简介\" class=\"headerlink\" title=\"稀疏矩阵（数组）简介\"></a>稀疏矩阵（数组）简介</h1><p>假设我们现在要写一个五子棋程序，其中有<u>保存当前棋盘</u>和<u>恢复上次棋盘</u>的功能，那么显然需要一种方法去保存棋盘。我们很容易想到用一个<strong>二维数组</strong>去保留棋盘：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6q07k59ehhw0.webp\" alt=\"五子棋\"></p>\n<p>我们可以看到棋盘上有许多空白，<u>这些无意义的空白数据都占据着存储空间</u>，我们实际需要保存的只是<strong>棋子的位置和值</strong>，而不是整个棋盘，那么我们怎么去掉这些无意义的数据呢？</p>\n<p>首先， 上面这种无意义数据占大多数的二维矩阵被称为<strong>稀疏矩阵</strong>，其判别条件是：</p>\n<blockquote>\n<p>假设有$m * n$的矩阵，其有t个非0元素，那么设$δ = \\frac{t}{m * n}$，δ被称为稀疏因子，如果δ&lt;=0.05，那么该矩阵就是稀疏矩阵。</p>\n</blockquote>\n<p>针对于稀疏矩阵，我们可以用三元表来保存其<strong>行列数</strong>、<strong>非0元素的数量</strong>以及<strong>各非0元素的位置</strong>，比如上面的棋盘就可以用下面这样的稀疏矩阵表示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">row</th>\n<th align=\"center\">col</th>\n<th align=\"center\">val</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">11（行数）</td>\n<td align=\"center\">11（列数）</td>\n<td align=\"center\">2（非0元素数）</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">2</td>\n</tr>\n</tbody></table>\n<h1 id=\"稀疏矩阵与矩阵之间的转换\"><a href=\"#稀疏矩阵与矩阵之间的转换\" class=\"headerlink\" title=\"稀疏矩阵与矩阵之间的转换\"></a>稀疏矩阵与矩阵之间的转换</h1><p>稀疏矩阵与矩阵之间的转换思路比较简单，下面只作简单的梳理。</p>\n<p class=\"note note-primary\">矩阵→稀疏矩阵</p>\n\n<ol>\n<li>遍历矩阵，得到非0元素数<code>numCount</code>。</li>\n<li>然后用<code>numCount</code>初始化稀疏矩阵<code>sparseArr[numCount+1][3]</code>，<code>numCount+1</code>是因为<code>sparseArr[0]</code>要存储矩阵的行列数，以及非0元素数。</li>\n<li>之后遍历矩阵，存储非0元素数即可。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/*统计非0元素数*/</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">numCount</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span>[] row : chessArr1)&#123;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> num : row)&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(num !=<span class=\"hljs-number\">0</span>)&#123;<br>\t\t\tnumCount++;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-type\">int</span> sparseArr[][] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[numCount+<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-comment\">/*第一行存储矩阵的行列数、非0元素数*/</span><br>sparseArr[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = sparseArr[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>] =<span class=\"hljs-number\">11</span>;<br>sparseArr[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">2</span>] = numCount;<br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">index</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;chessArr1.length;i++)&#123;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;chessArr1.length;j++)&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(chessArr1[i][j]!=<span class=\"hljs-number\">0</span>)&#123;<br>\t\t\tsparseArr[index][<span class=\"hljs-number\">0</span>] = i;<br>\t\t\tsparseArr[index][<span class=\"hljs-number\">1</span>] = j;<br>\t\t\tsparseArr[index++][<span class=\"hljs-number\">2</span>] = chessArr1[i][j];<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p class=\"note note-primary\">稀疏矩阵→矩阵</p>\n\n<p>这就没什么好说的了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span>[][] chessArr2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[sparseArr[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]][sparseArr[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>]];<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;sparseArr.length;i++)&#123;<br>\tchessArr2[sparseArr[i][<span class=\"hljs-number\">0</span>]][sparseArr[i][<span class=\"hljs-number\">1</span>]] = sparseArr[i][<span class=\"hljs-number\">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"稀疏矩阵的快速转置\"><a href=\"#稀疏矩阵的快速转置\" class=\"headerlink\" title=\"稀疏矩阵的快速转置\"></a>稀疏矩阵的快速转置</h1><div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2ioamg882ww0.webp\" alt=\"image\" style=\"zoom:50%;\" /></div>\n\n<p>稀疏矩阵的快速转置是稀疏矩阵的重点，其基本思想就是<strong>空间换时间</strong>，下面我们来看看。</p>\n<p>设我们现在有这样一个三元表a(<strong>省略掉a[0]</strong>)用于存储稀疏矩阵M：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">row</th>\n<th align=\"center\">col</th>\n<th align=\"center\">val</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">1</td>\n<td align=\"center\">-3</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">6</td>\n<td align=\"center\">14</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">3</td>\n<td align=\"center\">24</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\">2</td>\n<td align=\"center\">15</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">1</td>\n<td align=\"center\">18</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">4</td>\n<td align=\"center\">7</td>\n</tr>\n</tbody></table>\n<p>矩阵转置就是将<u>元素的行列调换</u>，我们这里也很简单，就直接调换行列就好了，但是三元表是<strong>按顺序存储</strong>的，所以调换完后，我们还要按行排序，正确的转置后三元表b应该如下所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">row</th>\n<th align=\"center\">col</th>\n<th align=\"center\">val</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">-3</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">6</td>\n<td align=\"center\">18</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">5</td>\n<td align=\"center\">15</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">1</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">24</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">6</td>\n<td align=\"center\">-7</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">3</td>\n<td align=\"center\">14</td>\n</tr>\n</tbody></table>\n<p>根据上述思路，我们可以看出重点就在于这个<font color=purple><strong>次序的问题</strong></font>上，根据对次序的不同处理方式，我们就有了两种转置的方法。</p>\n<h2 id=\"扫描转置法\"><a href=\"#扫描转置法\" class=\"headerlink\" title=\"扫描转置法\"></a>扫描转置法</h2><p>这个方法很简单，就是<strong>扫描三元表a的第二列来转置</strong>，a的第二列也就是列序，a的列序就是b的行序。其算法复杂度很明显是$O（n^2）$，时间复杂度太高了，这种方法就不多加赘述了。</p>\n<h2 id=\"快速转置法\"><a href=\"#快速转置法\" class=\"headerlink\" title=\"快速转置法\"></a>快速转置法</h2><p>如果我们<strong>知道三元表a中的每一项在转置后的新三元表b中的位置</strong>，然后直接放上去，那不就不需要$O(n^2)$的时间复杂度了？快速转置正是基于这种思路实现的。</p>\n<p>那么我们怎么知道各项在新三元表中的位置的呢？</p>\n<blockquote>\n<p>下面的<code>a:col=2</code>表示a中某项的<code>col列</code>值为2的情况。</p>\n</blockquote>\n<p>注意三元表a的col就是新三元表b的row，<strong>我们开始读a的col列</strong>。a的第一项的col是2，因为a：col=2就是b：row=2，所以在b中占据第3、4行，那么就从第3位开始放，接下来如果又读到一个a：col=2，那么就放在第4位，因为a：col=2只有两项，所以b的第五位不会被b : row=2占据，b的第5、6位是留给b : row = 3的。通过这种思想，我们就能在三元表中找到相应的位置，这就是稀疏矩阵的原理。</p>\n<p>下面我们来实现这个算法。</p>\n<p class=\"note note-primary\">空间换时间：求num[]和cpot[]</p>\n\n<p>首先，我们需要两个变量：</p>\n<hr>\n<ul>\n<li>num[col]：用于记录原三元表a: col = col的项的数目。</li>\n<li>cpot[col]：用于记录原三元表a中列数为col的项在新三元表中的首位置，例如col=2，则cpot[col]=3。</li>\n</ul>\n<hr>\n<p>那么三元表a的num[]和cpot[]值为：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">col</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">num[col]</td>\n<td align=\"center\">2</td>\n<td align=\"center\">2</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">cpot[col]</td>\n<td align=\"center\">1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">7</td>\n<td align=\"center\">8</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n</tbody></table>\n<p>求这两数组的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span>[][] M = ...;\t\t\t\t <span class=\"hljs-comment\">//转置前的稀疏矩阵M</span><br><span class=\"hljs-type\">int</span>[][] sparseArrA = ...;  <span class=\"hljs-comment\">//转置前的三元表A</span><br><span class=\"hljs-type\">int</span>[][] sparseArrB = ...;  <span class=\"hljs-comment\">//转置后的三元表B</span><br><span class=\"hljs-type\">int</span>[] num = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[M[<span class=\"hljs-number\">0</span>].length+<span class=\"hljs-number\">1</span>];<br><span class=\"hljs-type\">int</span>[] cpot = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[num.length];<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> col=<span class=\"hljs-number\">1</span>;col&lt;=num.length;col++)&#123;<br>    num[col] = <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">/*初始化num[]，统计每列各有多少个非0元素*/</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> t=<span class=\"hljs-number\">1</span>;t&lt;sparseArrA.length;t++)&#123;<br>\t<span class=\"hljs-comment\">/*num[三元表Acol列]++*/</span><br>    num[sparseArrA[t][<span class=\"hljs-number\">1</span>]]++<br>&#125;<br><br><span class=\"hljs-comment\">/*根据num[]初始化cpot[col]，统计a每一列的元素在b中的位置*/</span><br>cpot[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> p=<span class=\"hljs-number\">2</span>;p&lt;cpot.length;p++)&#123;<br>    cpot[p] = cpot[p-<span class=\"hljs-number\">1</span>]+num[p-<span class=\"hljs-number\">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p class=\"note note-primary\">快速转置</p>\n\n<p>下面，我们就可以进行快速转置了，具体步骤如下：</p>\n<ol>\n<li>我们遍历三元表A的col列，得到每项的col</li>\n<li>根据col，得到cpot[col]，这就是三元表A中该项在三元表B的位置。</li>\n<li>将该项转置后填入三元表B，然后cpot[col]++。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> p=<span class=\"hljs-number\">1</span>;p&lt;=sparseArrA.length;p++)&#123;<br>    col = sparseArrA[p][<span class=\"hljs-number\">1</span>];<br>    q = cpot[col];<br>    sparseArrB[q][<span class=\"hljs-number\">0</span>] = sparseArrA[p][<span class=\"hljs-number\">1</span>];  <br>    sparseArrB[q][<span class=\"hljs-number\">1</span>] = sparseArrA[p][<span class=\"hljs-number\">0</span>];  <br>    sparseArrB[q][<span class=\"hljs-number\">2</span>] = sparseArrA[p][<span class=\"hljs-number\">2</span>];<br>    ++cpot[col];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"FTP协议实验","date":"2022-11-21T08:09:08.000Z","banner_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1eor1rfpy2e8.webp","index_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1eor1rfpy2e8.webp","excerpt":"FTP协议的小实验，主要是使用pyftpdlib package创建一个FTP Server玩玩","_content":"\n> 在阅读下文前，可以先掌握这些内容：[FTP理论知识](https://www.yuque.com/topsail/ta49di/rm4ervmy548ugg7m?#)\n\n# 一个简单的FTP Server\n\n在这节里，我们用python的pyftpdlib package实现一个简单的FTP Server和FTP Client，然后进行一些操作，观察其变化。\n\n用python实现的一个简单FTP Server框架如下所示：\n\n```python\nimport os\nfrom pyftpdlib.authorizers import DummyAuthorizer\nfrom pyftpdlib.handlers import FTPHandler\nfrom pyftpdlib.servers import FTPServer\n\ndef main():\n    # 实例化一个虚拟用户\n\tauthorizer = DummyAuthorizer()\n    # 添加用户，参数为（用户名,密码,用户目录,权限perm）\n\tauthorizer.add_user('yang','123456',r'E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\yang_ftp',perm='elradfmwMT')\n\tauthorizer.add_user('li','123456',r'E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\li_ftp',perm='elradfmwMT')\n    # 添加匿名用户，only need path\n    authorizer.add_anonymous(os.getcwd())\n\t\n    # 初始化FTP句柄\n\thandler = FTPHandler\n\thandler.authorizer = authorizer\n    \n\t# 指定高位随机端口范围\n    handler.passive_ports = range(20000,20033)\n\t# string returned when client connects\n    # handler.banner = \"pyftdlib base ftpd ready\"\n\t\n    # 初始化FTP Server ，使其监听0.0.0.0:21\n\taddress = ('0.0.0.0',21)\n\tserver = FTPServer(address,handler)\n\n    # 对连接进行限制\n\tserver.max_cons = 256\n\tserver.max_cons_per_ip = 5\n\n\tserver.serve_forever()\n\nif __name__ == '__main__':\n\tmain()\n```\n\n运行服务器程序后：\n\n![运行FTP Server](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5ws0umz6agw0.webp)\n\n我们打开cmd，首先使用`ipconfig`查看本机的IPV4地址(假设本机的IPV4地址为`10.135.8.1`)，然后使用`ftp 10.135.8.1`打开windows的ftp客户端，之后进行登录:\n\n![使用ftp客户端](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.55741yi6cx80.webp)\n\n之后就可以使用windows上的一些ftp命令去访问ftp服务器，执行一些操作，比如查看文件，下载文件:\n\n![操作ftp命令](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.7ja920kjnqs.webp)\n\n以上就是简单的一个FTP Server的创建及其与FTP客户端的交互，下面分模块进行一下探究。\n\n## Logging management:  登录管理\n\n登录模块是需要我们在创建FTP Server之前（`serve_forever`）去配置的，我们主要配置`authorizer`，其中authorizer.add_user中有一个比较重要的参数是perm，其指定了用户权限，具体的配置参数见[文档](https://pyftpdlib.readthedocs.io/en/latest/api.html#users)。\n\n## Throttle bandwidth：节制带宽\n\n百度网盘，迅雷这些软件下载的时候都会限速，如果不限速，那么就会出问题，如果有人上传/下载大文件，那么直接把带宽给占了，别人还怎么用。所以，我们的FTP Server需要节制一下带宽，通俗点来说就是限流。\n\npyftpdlib中主要使用`ThrottleDTPHandler`来节制带宽，其使用方法也是十分简单：\n\n```python\ndtp_handler = ThrottledDTPHandler\ndtp_handler.read_limit = 30720 \t# 30 Kb/sec, 即30 * 1024\ndtp_handler.write_limit = 30720  \n\nftp_handler = FTPHandler\nftp_handler.dtp_handler = dtp_handler\n```\n\n我们来验证一下是否真的会节制带宽，假设现在用户yang的目录如下：\n\n![image](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.32xbm2oc0h40.webp)\n\n现在FTP客户端要从FTP服务器下载`YAPA2.exe`文件,首先我们用没有限流的FTP服务器，FTP客户端的下载情况如下所示：\n\n![image](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6jdqaavhous0.webp)\n\n可以看到大约13.5MB的文件，只用了0.04s，速度为374Mbps，下面我们对FTP Server进行限速，限速到**30Kbps**：\n\n![image](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5744w41sjc40.webp)\n\n可以看到两者速度的差距之大，由此可证明节制带宽是有效的。那么这是怎么做到的呢？\n\n在pyftpdlib的文档中有这么一段话:\n\n> The basic idea behind `ThrottledDTPHandler` is to wrap sending and receiving in a data counter and temporary “sleep” the data channel so that you burst to no more than x Kb/sec average. When it realizes that more than x Kb in a second are being transmitted it temporary blocks the transfer for a certain number of seconds.\n\n其基本思想在于：<u>将上传/下载的数据封装到一个计数器里，然后让数据流间断性地sleep，即间断地阻塞数据流，以达到不多于 xkbps的速度</u>。\n\n# 异常处理\n\n如果给虚拟用户指定的目录在FTP Server主机上不存在，会发生什么呢？\n\n```python\nauthorizer.add_user('li','123456',r'E:\\\\not_exist_dir',perm='elradfmwMT')\n```\n\n![ValueError](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.587wyafhuk00.webp)\n\n我们在这里加个异常处理，没这个目录我就创建一个目录：\n\n```python\ndirectory = \"E:\\\\not_exist_dir\"\nif not os.path.exists(directory):\n    os.mkdir(directory)\nauthorizer.add_user('li','123456',directory,perm='elradfmwMT')\n```\n\n还有个地方容易出错的就是端口占用问题，如果我们用的端口已经有其它进程在用了，那肯定得出错，所以也要加个异常处理:\n\n```python\ntry:\n    authorizer = DummyAuthorizer()\n    # 添加用户，参数为（用户名,密码,用户目录,权限perm）\n\tauthorizer.add_user('yang','123456',r'E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\yang_ftp',perm='elradfmwMT')\n\tauthorizer.add_user('li','123456',r'E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\li_ftp',perm='elradfmwMT')\nexcept OSError as e : \n    if \"Address already in use\" in e :\n        print(\"port is using...\")\n```\n\n\n\n# FTP Client\n\n我们可以用`ftplib`做一个简单的FTP客户端，这是python自带的一个package。来看一个示例代码：\n\n```python\nfrom ftplib import FTP\nimport time,tarfile,os\n\ndef ftpconnect(host,port,username,password):\n\tftp = FTP()\n\tftp.connect(host,port)\t\t\t\t\t\t# 连接ftp server，指定ip和Port\n\tftp.login(username,password)\t\t# 登录\n\treturn ftp\n\ndef downloadfile(ftp,remotepath,localpath):\n    ftp.cmd('xxx/xxx')\t\t#进入远程目录\n\tbufsize = 1024\n\tfp = open(localpath,'wb')\n\tftp.retrbinary('RETR '+remotepath,fp.write,bufsize) # 接受服务器上文并写入本地文件\n\tftp.set_debuglevel(0)\t\t\t\t\t\t\t# 关闭调试模式\n\tfp.close()\t\t\t\t\t\t\t\t\t\t\t\t# 调用close，单方面关闭连接\n\ndef uploadfile(ftp,remotepath,localpath):\n\tbufsize = 1024\n\tfp = open(localpath,'rb')\n\tftp.storbinary(\"STOR \"+remotepath,fp,bufsize)\t# 上传文件\n\tftp.set_debuglevel(0)\n\tfp.close()\n\nif __name__ == '__main__':\n\tftp = ftpconnect(host=\"IP地址\",port=21,username=\"yang\",password=\"123456\")\n\tdownloadfile(ftp,\"/text.txt\",r\"E:\\\\Download\\\\text.txt\")\n\tftp.close()\n```\n\n上面是一个简单的示例，详细的细节可查阅文档。\n\n\n\n# 参考资料\n\n1. [pyftpdlib documentation](https://pyftpdlib.readthedocs.io/en/latest/index.html)\n2. [ftplib —Python 3.11.0 documentation](https://docs.python.org/3/library/ftplib.html)","source":"_posts/FTP协议.md","raw":"---\ntitle: FTP协议实验\ndate: 2022-11-21 16:09:08\ntags:\n- 文件共享协议\ncategories:\n- 计算机网络\n- 应用层协议\nbanner_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1eor1rfpy2e8.webp\nindex_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.1eor1rfpy2e8.webp\nexcerpt: FTP协议的小实验，主要是使用pyftpdlib package创建一个FTP Server玩玩\n---\n\n> 在阅读下文前，可以先掌握这些内容：[FTP理论知识](https://www.yuque.com/topsail/ta49di/rm4ervmy548ugg7m?#)\n\n# 一个简单的FTP Server\n\n在这节里，我们用python的pyftpdlib package实现一个简单的FTP Server和FTP Client，然后进行一些操作，观察其变化。\n\n用python实现的一个简单FTP Server框架如下所示：\n\n```python\nimport os\nfrom pyftpdlib.authorizers import DummyAuthorizer\nfrom pyftpdlib.handlers import FTPHandler\nfrom pyftpdlib.servers import FTPServer\n\ndef main():\n    # 实例化一个虚拟用户\n\tauthorizer = DummyAuthorizer()\n    # 添加用户，参数为（用户名,密码,用户目录,权限perm）\n\tauthorizer.add_user('yang','123456',r'E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\yang_ftp',perm='elradfmwMT')\n\tauthorizer.add_user('li','123456',r'E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\li_ftp',perm='elradfmwMT')\n    # 添加匿名用户，only need path\n    authorizer.add_anonymous(os.getcwd())\n\t\n    # 初始化FTP句柄\n\thandler = FTPHandler\n\thandler.authorizer = authorizer\n    \n\t# 指定高位随机端口范围\n    handler.passive_ports = range(20000,20033)\n\t# string returned when client connects\n    # handler.banner = \"pyftdlib base ftpd ready\"\n\t\n    # 初始化FTP Server ，使其监听0.0.0.0:21\n\taddress = ('0.0.0.0',21)\n\tserver = FTPServer(address,handler)\n\n    # 对连接进行限制\n\tserver.max_cons = 256\n\tserver.max_cons_per_ip = 5\n\n\tserver.serve_forever()\n\nif __name__ == '__main__':\n\tmain()\n```\n\n运行服务器程序后：\n\n![运行FTP Server](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5ws0umz6agw0.webp)\n\n我们打开cmd，首先使用`ipconfig`查看本机的IPV4地址(假设本机的IPV4地址为`10.135.8.1`)，然后使用`ftp 10.135.8.1`打开windows的ftp客户端，之后进行登录:\n\n![使用ftp客户端](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.55741yi6cx80.webp)\n\n之后就可以使用windows上的一些ftp命令去访问ftp服务器，执行一些操作，比如查看文件，下载文件:\n\n![操作ftp命令](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.7ja920kjnqs.webp)\n\n以上就是简单的一个FTP Server的创建及其与FTP客户端的交互，下面分模块进行一下探究。\n\n## Logging management:  登录管理\n\n登录模块是需要我们在创建FTP Server之前（`serve_forever`）去配置的，我们主要配置`authorizer`，其中authorizer.add_user中有一个比较重要的参数是perm，其指定了用户权限，具体的配置参数见[文档](https://pyftpdlib.readthedocs.io/en/latest/api.html#users)。\n\n## Throttle bandwidth：节制带宽\n\n百度网盘，迅雷这些软件下载的时候都会限速，如果不限速，那么就会出问题，如果有人上传/下载大文件，那么直接把带宽给占了，别人还怎么用。所以，我们的FTP Server需要节制一下带宽，通俗点来说就是限流。\n\npyftpdlib中主要使用`ThrottleDTPHandler`来节制带宽，其使用方法也是十分简单：\n\n```python\ndtp_handler = ThrottledDTPHandler\ndtp_handler.read_limit = 30720 \t# 30 Kb/sec, 即30 * 1024\ndtp_handler.write_limit = 30720  \n\nftp_handler = FTPHandler\nftp_handler.dtp_handler = dtp_handler\n```\n\n我们来验证一下是否真的会节制带宽，假设现在用户yang的目录如下：\n\n![image](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.32xbm2oc0h40.webp)\n\n现在FTP客户端要从FTP服务器下载`YAPA2.exe`文件,首先我们用没有限流的FTP服务器，FTP客户端的下载情况如下所示：\n\n![image](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6jdqaavhous0.webp)\n\n可以看到大约13.5MB的文件，只用了0.04s，速度为374Mbps，下面我们对FTP Server进行限速，限速到**30Kbps**：\n\n![image](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5744w41sjc40.webp)\n\n可以看到两者速度的差距之大，由此可证明节制带宽是有效的。那么这是怎么做到的呢？\n\n在pyftpdlib的文档中有这么一段话:\n\n> The basic idea behind `ThrottledDTPHandler` is to wrap sending and receiving in a data counter and temporary “sleep” the data channel so that you burst to no more than x Kb/sec average. When it realizes that more than x Kb in a second are being transmitted it temporary blocks the transfer for a certain number of seconds.\n\n其基本思想在于：<u>将上传/下载的数据封装到一个计数器里，然后让数据流间断性地sleep，即间断地阻塞数据流，以达到不多于 xkbps的速度</u>。\n\n# 异常处理\n\n如果给虚拟用户指定的目录在FTP Server主机上不存在，会发生什么呢？\n\n```python\nauthorizer.add_user('li','123456',r'E:\\\\not_exist_dir',perm='elradfmwMT')\n```\n\n![ValueError](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.587wyafhuk00.webp)\n\n我们在这里加个异常处理，没这个目录我就创建一个目录：\n\n```python\ndirectory = \"E:\\\\not_exist_dir\"\nif not os.path.exists(directory):\n    os.mkdir(directory)\nauthorizer.add_user('li','123456',directory,perm='elradfmwMT')\n```\n\n还有个地方容易出错的就是端口占用问题，如果我们用的端口已经有其它进程在用了，那肯定得出错，所以也要加个异常处理:\n\n```python\ntry:\n    authorizer = DummyAuthorizer()\n    # 添加用户，参数为（用户名,密码,用户目录,权限perm）\n\tauthorizer.add_user('yang','123456',r'E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\yang_ftp',perm='elradfmwMT')\n\tauthorizer.add_user('li','123456',r'E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\li_ftp',perm='elradfmwMT')\nexcept OSError as e : \n    if \"Address already in use\" in e :\n        print(\"port is using...\")\n```\n\n\n\n# FTP Client\n\n我们可以用`ftplib`做一个简单的FTP客户端，这是python自带的一个package。来看一个示例代码：\n\n```python\nfrom ftplib import FTP\nimport time,tarfile,os\n\ndef ftpconnect(host,port,username,password):\n\tftp = FTP()\n\tftp.connect(host,port)\t\t\t\t\t\t# 连接ftp server，指定ip和Port\n\tftp.login(username,password)\t\t# 登录\n\treturn ftp\n\ndef downloadfile(ftp,remotepath,localpath):\n    ftp.cmd('xxx/xxx')\t\t#进入远程目录\n\tbufsize = 1024\n\tfp = open(localpath,'wb')\n\tftp.retrbinary('RETR '+remotepath,fp.write,bufsize) # 接受服务器上文并写入本地文件\n\tftp.set_debuglevel(0)\t\t\t\t\t\t\t# 关闭调试模式\n\tfp.close()\t\t\t\t\t\t\t\t\t\t\t\t# 调用close，单方面关闭连接\n\ndef uploadfile(ftp,remotepath,localpath):\n\tbufsize = 1024\n\tfp = open(localpath,'rb')\n\tftp.storbinary(\"STOR \"+remotepath,fp,bufsize)\t# 上传文件\n\tftp.set_debuglevel(0)\n\tfp.close()\n\nif __name__ == '__main__':\n\tftp = ftpconnect(host=\"IP地址\",port=21,username=\"yang\",password=\"123456\")\n\tdownloadfile(ftp,\"/text.txt\",r\"E:\\\\Download\\\\text.txt\")\n\tftp.close()\n```\n\n上面是一个简单的示例，详细的细节可查阅文档。\n\n\n\n# 参考资料\n\n1. [pyftpdlib documentation](https://pyftpdlib.readthedocs.io/en/latest/index.html)\n2. [ftplib —Python 3.11.0 documentation](https://docs.python.org/3/library/ftplib.html)","slug":"FTP协议","published":1,"updated":"2022-11-21T12:04:09.912Z","_id":"claqq0vo300009crueq0jgaox","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>在阅读下文前，可以先掌握这些内容：<a href=\"https://www.yuque.com/topsail/ta49di/rm4ervmy548ugg7m#\">FTP理论知识</a></p>\n</blockquote>\n<h1 id=\"一个简单的FTP-Server\"><a href=\"#一个简单的FTP-Server\" class=\"headerlink\" title=\"一个简单的FTP Server\"></a>一个简单的FTP Server</h1><p>在这节里，我们用python的pyftpdlib package实现一个简单的FTP Server和FTP Client，然后进行一些操作，观察其变化。</p>\n<p>用python实现的一个简单FTP Server框架如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br><span class=\"hljs-keyword\">from</span> pyftpdlib.authorizers <span class=\"hljs-keyword\">import</span> DummyAuthorizer<br><span class=\"hljs-keyword\">from</span> pyftpdlib.handlers <span class=\"hljs-keyword\">import</span> FTPHandler<br><span class=\"hljs-keyword\">from</span> pyftpdlib.servers <span class=\"hljs-keyword\">import</span> FTPServer<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>():<br>    <span class=\"hljs-comment\"># 实例化一个虚拟用户</span><br>\tauthorizer = DummyAuthorizer()<br>    <span class=\"hljs-comment\"># 添加用户，参数为（用户名,密码,用户目录,权限perm）</span><br>\tauthorizer.add_user(<span class=\"hljs-string\">&#x27;yang&#x27;</span>,<span class=\"hljs-string\">&#x27;123456&#x27;</span>,<span class=\"hljs-string\">r&#x27;E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\yang_ftp&#x27;</span>,perm=<span class=\"hljs-string\">&#x27;elradfmwMT&#x27;</span>)<br>\tauthorizer.add_user(<span class=\"hljs-string\">&#x27;li&#x27;</span>,<span class=\"hljs-string\">&#x27;123456&#x27;</span>,<span class=\"hljs-string\">r&#x27;E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\li_ftp&#x27;</span>,perm=<span class=\"hljs-string\">&#x27;elradfmwMT&#x27;</span>)<br>    <span class=\"hljs-comment\"># 添加匿名用户，only need path</span><br>    authorizer.add_anonymous(os.getcwd())<br>\t<br>    <span class=\"hljs-comment\"># 初始化FTP句柄</span><br>\thandler = FTPHandler<br>\thandler.authorizer = authorizer<br>    <br>\t<span class=\"hljs-comment\"># 指定高位随机端口范围</span><br>    handler.passive_ports = <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">20000</span>,<span class=\"hljs-number\">20033</span>)<br>\t<span class=\"hljs-comment\"># string returned when client connects</span><br>    <span class=\"hljs-comment\"># handler.banner = &quot;pyftdlib base ftpd ready&quot;</span><br>\t<br>    <span class=\"hljs-comment\"># 初始化FTP Server ，使其监听0.0.0.0:21</span><br>\taddress = (<span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>,<span class=\"hljs-number\">21</span>)<br>\tserver = FTPServer(address,handler)<br><br>    <span class=\"hljs-comment\"># 对连接进行限制</span><br>\tserver.max_cons = <span class=\"hljs-number\">256</span><br>\tserver.max_cons_per_ip = <span class=\"hljs-number\">5</span><br><br>\tserver.serve_forever()<br><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>\tmain()<br></code></pre></td></tr></table></figure>\n\n<p>运行服务器程序后：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5ws0umz6agw0.webp\" alt=\"运行FTP Server\"></p>\n<p>我们打开cmd，首先使用<code>ipconfig</code>查看本机的IPV4地址(假设本机的IPV4地址为<code>10.135.8.1</code>)，然后使用<code>ftp 10.135.8.1</code>打开windows的ftp客户端，之后进行登录:</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.55741yi6cx80.webp\" alt=\"使用ftp客户端\"></p>\n<p>之后就可以使用windows上的一些ftp命令去访问ftp服务器，执行一些操作，比如查看文件，下载文件:</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.7ja920kjnqs.webp\" alt=\"操作ftp命令\"></p>\n<p>以上就是简单的一个FTP Server的创建及其与FTP客户端的交互，下面分模块进行一下探究。</p>\n<h2 id=\"Logging-management-登录管理\"><a href=\"#Logging-management-登录管理\" class=\"headerlink\" title=\"Logging management:  登录管理\"></a>Logging management:  登录管理</h2><p>登录模块是需要我们在创建FTP Server之前（<code>serve_forever</code>）去配置的，我们主要配置<code>authorizer</code>，其中authorizer.add_user中有一个比较重要的参数是perm，其指定了用户权限，具体的配置参数见<a href=\"https://pyftpdlib.readthedocs.io/en/latest/api.html#users\">文档</a>。</p>\n<h2 id=\"Throttle-bandwidth：节制带宽\"><a href=\"#Throttle-bandwidth：节制带宽\" class=\"headerlink\" title=\"Throttle bandwidth：节制带宽\"></a>Throttle bandwidth：节制带宽</h2><p>百度网盘，迅雷这些软件下载的时候都会限速，如果不限速，那么就会出问题，如果有人上传/下载大文件，那么直接把带宽给占了，别人还怎么用。所以，我们的FTP Server需要节制一下带宽，通俗点来说就是限流。</p>\n<p>pyftpdlib中主要使用<code>ThrottleDTPHandler</code>来节制带宽，其使用方法也是十分简单：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">dtp_handler = ThrottledDTPHandler<br>dtp_handler.read_limit = <span class=\"hljs-number\">30720</span> \t<span class=\"hljs-comment\"># 30 Kb/sec, 即30 * 1024</span><br>dtp_handler.write_limit = <span class=\"hljs-number\">30720</span>  <br><br>ftp_handler = FTPHandler<br>ftp_handler.dtp_handler = dtp_handler<br></code></pre></td></tr></table></figure>\n\n<p>我们来验证一下是否真的会节制带宽，假设现在用户yang的目录如下：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.32xbm2oc0h40.webp\" alt=\"image\"></p>\n<p>现在FTP客户端要从FTP服务器下载<code>YAPA2.exe</code>文件,首先我们用没有限流的FTP服务器，FTP客户端的下载情况如下所示：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6jdqaavhous0.webp\" alt=\"image\"></p>\n<p>可以看到大约13.5MB的文件，只用了0.04s，速度为374Mbps，下面我们对FTP Server进行限速，限速到<strong>30Kbps</strong>：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5744w41sjc40.webp\" alt=\"image\"></p>\n<p>可以看到两者速度的差距之大，由此可证明节制带宽是有效的。那么这是怎么做到的呢？</p>\n<p>在pyftpdlib的文档中有这么一段话:</p>\n<blockquote>\n<p>The basic idea behind <code>ThrottledDTPHandler</code> is to wrap sending and receiving in a data counter and temporary “sleep” the data channel so that you burst to no more than x Kb/sec average. When it realizes that more than x Kb in a second are being transmitted it temporary blocks the transfer for a certain number of seconds.</p>\n</blockquote>\n<p>其基本思想在于：<u>将上传/下载的数据封装到一个计数器里，然后让数据流间断性地sleep，即间断地阻塞数据流，以达到不多于 xkbps的速度</u>。</p>\n<h1 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h1><p>如果给虚拟用户指定的目录在FTP Server主机上不存在，会发生什么呢？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">authorizer.add_user(<span class=\"hljs-string\">&#x27;li&#x27;</span>,<span class=\"hljs-string\">&#x27;123456&#x27;</span>,<span class=\"hljs-string\">r&#x27;E:\\\\not_exist_dir&#x27;</span>,perm=<span class=\"hljs-string\">&#x27;elradfmwMT&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.587wyafhuk00.webp\" alt=\"ValueError\"></p>\n<p>我们在这里加个异常处理，没这个目录我就创建一个目录：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">directory = <span class=\"hljs-string\">&quot;E:\\\\not_exist_dir&quot;</span><br><span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> os.path.exists(directory):<br>    os.mkdir(directory)<br>authorizer.add_user(<span class=\"hljs-string\">&#x27;li&#x27;</span>,<span class=\"hljs-string\">&#x27;123456&#x27;</span>,directory,perm=<span class=\"hljs-string\">&#x27;elradfmwMT&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>还有个地方容易出错的就是端口占用问题，如果我们用的端口已经有其它进程在用了，那肯定得出错，所以也要加个异常处理:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">try</span>:<br>    authorizer = DummyAuthorizer()<br>    <span class=\"hljs-comment\"># 添加用户，参数为（用户名,密码,用户目录,权限perm）</span><br>\tauthorizer.add_user(<span class=\"hljs-string\">&#x27;yang&#x27;</span>,<span class=\"hljs-string\">&#x27;123456&#x27;</span>,<span class=\"hljs-string\">r&#x27;E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\yang_ftp&#x27;</span>,perm=<span class=\"hljs-string\">&#x27;elradfmwMT&#x27;</span>)<br>\tauthorizer.add_user(<span class=\"hljs-string\">&#x27;li&#x27;</span>,<span class=\"hljs-string\">&#x27;123456&#x27;</span>,<span class=\"hljs-string\">r&#x27;E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\li_ftp&#x27;</span>,perm=<span class=\"hljs-string\">&#x27;elradfmwMT&#x27;</span>)<br><span class=\"hljs-keyword\">except</span> OSError <span class=\"hljs-keyword\">as</span> e : <br>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&quot;Address already in use&quot;</span> <span class=\"hljs-keyword\">in</span> e :<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;port is using...&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"FTP-Client\"><a href=\"#FTP-Client\" class=\"headerlink\" title=\"FTP Client\"></a>FTP Client</h1><p>我们可以用<code>ftplib</code>做一个简单的FTP客户端，这是python自带的一个package。来看一个示例代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> ftplib <span class=\"hljs-keyword\">import</span> FTP<br><span class=\"hljs-keyword\">import</span> time,tarfile,os<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">ftpconnect</span>(<span class=\"hljs-params\">host,port,username,password</span>):<br>\tftp = FTP()<br>\tftp.connect(host,port)\t\t\t\t\t\t<span class=\"hljs-comment\"># 连接ftp server，指定ip和Port</span><br>\tftp.login(username,password)\t\t<span class=\"hljs-comment\"># 登录</span><br>\t<span class=\"hljs-keyword\">return</span> ftp<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">downloadfile</span>(<span class=\"hljs-params\">ftp,remotepath,localpath</span>):<br>    ftp.cmd(<span class=\"hljs-string\">&#x27;xxx/xxx&#x27;</span>)\t\t<span class=\"hljs-comment\">#进入远程目录</span><br>\tbufsize = <span class=\"hljs-number\">1024</span><br>\tfp = <span class=\"hljs-built_in\">open</span>(localpath,<span class=\"hljs-string\">&#x27;wb&#x27;</span>)<br>\tftp.retrbinary(<span class=\"hljs-string\">&#x27;RETR &#x27;</span>+remotepath,fp.write,bufsize) <span class=\"hljs-comment\"># 接受服务器上文并写入本地文件</span><br>\tftp.set_debuglevel(<span class=\"hljs-number\">0</span>)\t\t\t\t\t\t\t<span class=\"hljs-comment\"># 关闭调试模式</span><br>\tfp.close()\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\"># 调用close，单方面关闭连接</span><br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">uploadfile</span>(<span class=\"hljs-params\">ftp,remotepath,localpath</span>):<br>\tbufsize = <span class=\"hljs-number\">1024</span><br>\tfp = <span class=\"hljs-built_in\">open</span>(localpath,<span class=\"hljs-string\">&#x27;rb&#x27;</span>)<br>\tftp.storbinary(<span class=\"hljs-string\">&quot;STOR &quot;</span>+remotepath,fp,bufsize)\t<span class=\"hljs-comment\"># 上传文件</span><br>\tftp.set_debuglevel(<span class=\"hljs-number\">0</span>)<br>\tfp.close()<br><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>\tftp = ftpconnect(host=<span class=\"hljs-string\">&quot;IP地址&quot;</span>,port=<span class=\"hljs-number\">21</span>,username=<span class=\"hljs-string\">&quot;yang&quot;</span>,password=<span class=\"hljs-string\">&quot;123456&quot;</span>)<br>\tdownloadfile(ftp,<span class=\"hljs-string\">&quot;/text.txt&quot;</span>,<span class=\"hljs-string\">r&quot;E:\\\\Download\\\\text.txt&quot;</span>)<br>\tftp.close()<br></code></pre></td></tr></table></figure>\n\n<p>上面是一个简单的示例，详细的细节可查阅文档。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ol>\n<li><a href=\"https://pyftpdlib.readthedocs.io/en/latest/index.html\">pyftpdlib documentation</a></li>\n<li><a href=\"https://docs.python.org/3/library/ftplib.html\">ftplib —Python 3.11.0 documentation</a></li>\n</ol>\n","site":{"data":{}},"more":"<blockquote>\n<p>在阅读下文前，可以先掌握这些内容：<a href=\"https://www.yuque.com/topsail/ta49di/rm4ervmy548ugg7m#\">FTP理论知识</a></p>\n</blockquote>\n<h1 id=\"一个简单的FTP-Server\"><a href=\"#一个简单的FTP-Server\" class=\"headerlink\" title=\"一个简单的FTP Server\"></a>一个简单的FTP Server</h1><p>在这节里，我们用python的pyftpdlib package实现一个简单的FTP Server和FTP Client，然后进行一些操作，观察其变化。</p>\n<p>用python实现的一个简单FTP Server框架如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br><span class=\"hljs-keyword\">from</span> pyftpdlib.authorizers <span class=\"hljs-keyword\">import</span> DummyAuthorizer<br><span class=\"hljs-keyword\">from</span> pyftpdlib.handlers <span class=\"hljs-keyword\">import</span> FTPHandler<br><span class=\"hljs-keyword\">from</span> pyftpdlib.servers <span class=\"hljs-keyword\">import</span> FTPServer<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>():<br>    <span class=\"hljs-comment\"># 实例化一个虚拟用户</span><br>\tauthorizer = DummyAuthorizer()<br>    <span class=\"hljs-comment\"># 添加用户，参数为（用户名,密码,用户目录,权限perm）</span><br>\tauthorizer.add_user(<span class=\"hljs-string\">&#x27;yang&#x27;</span>,<span class=\"hljs-string\">&#x27;123456&#x27;</span>,<span class=\"hljs-string\">r&#x27;E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\yang_ftp&#x27;</span>,perm=<span class=\"hljs-string\">&#x27;elradfmwMT&#x27;</span>)<br>\tauthorizer.add_user(<span class=\"hljs-string\">&#x27;li&#x27;</span>,<span class=\"hljs-string\">&#x27;123456&#x27;</span>,<span class=\"hljs-string\">r&#x27;E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\li_ftp&#x27;</span>,perm=<span class=\"hljs-string\">&#x27;elradfmwMT&#x27;</span>)<br>    <span class=\"hljs-comment\"># 添加匿名用户，only need path</span><br>    authorizer.add_anonymous(os.getcwd())<br>\t<br>    <span class=\"hljs-comment\"># 初始化FTP句柄</span><br>\thandler = FTPHandler<br>\thandler.authorizer = authorizer<br>    <br>\t<span class=\"hljs-comment\"># 指定高位随机端口范围</span><br>    handler.passive_ports = <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">20000</span>,<span class=\"hljs-number\">20033</span>)<br>\t<span class=\"hljs-comment\"># string returned when client connects</span><br>    <span class=\"hljs-comment\"># handler.banner = &quot;pyftdlib base ftpd ready&quot;</span><br>\t<br>    <span class=\"hljs-comment\"># 初始化FTP Server ，使其监听0.0.0.0:21</span><br>\taddress = (<span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>,<span class=\"hljs-number\">21</span>)<br>\tserver = FTPServer(address,handler)<br><br>    <span class=\"hljs-comment\"># 对连接进行限制</span><br>\tserver.max_cons = <span class=\"hljs-number\">256</span><br>\tserver.max_cons_per_ip = <span class=\"hljs-number\">5</span><br><br>\tserver.serve_forever()<br><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>\tmain()<br></code></pre></td></tr></table></figure>\n\n<p>运行服务器程序后：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5ws0umz6agw0.webp\" alt=\"运行FTP Server\"></p>\n<p>我们打开cmd，首先使用<code>ipconfig</code>查看本机的IPV4地址(假设本机的IPV4地址为<code>10.135.8.1</code>)，然后使用<code>ftp 10.135.8.1</code>打开windows的ftp客户端，之后进行登录:</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.55741yi6cx80.webp\" alt=\"使用ftp客户端\"></p>\n<p>之后就可以使用windows上的一些ftp命令去访问ftp服务器，执行一些操作，比如查看文件，下载文件:</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.7ja920kjnqs.webp\" alt=\"操作ftp命令\"></p>\n<p>以上就是简单的一个FTP Server的创建及其与FTP客户端的交互，下面分模块进行一下探究。</p>\n<h2 id=\"Logging-management-登录管理\"><a href=\"#Logging-management-登录管理\" class=\"headerlink\" title=\"Logging management:  登录管理\"></a>Logging management:  登录管理</h2><p>登录模块是需要我们在创建FTP Server之前（<code>serve_forever</code>）去配置的，我们主要配置<code>authorizer</code>，其中authorizer.add_user中有一个比较重要的参数是perm，其指定了用户权限，具体的配置参数见<a href=\"https://pyftpdlib.readthedocs.io/en/latest/api.html#users\">文档</a>。</p>\n<h2 id=\"Throttle-bandwidth：节制带宽\"><a href=\"#Throttle-bandwidth：节制带宽\" class=\"headerlink\" title=\"Throttle bandwidth：节制带宽\"></a>Throttle bandwidth：节制带宽</h2><p>百度网盘，迅雷这些软件下载的时候都会限速，如果不限速，那么就会出问题，如果有人上传/下载大文件，那么直接把带宽给占了，别人还怎么用。所以，我们的FTP Server需要节制一下带宽，通俗点来说就是限流。</p>\n<p>pyftpdlib中主要使用<code>ThrottleDTPHandler</code>来节制带宽，其使用方法也是十分简单：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">dtp_handler = ThrottledDTPHandler<br>dtp_handler.read_limit = <span class=\"hljs-number\">30720</span> \t<span class=\"hljs-comment\"># 30 Kb/sec, 即30 * 1024</span><br>dtp_handler.write_limit = <span class=\"hljs-number\">30720</span>  <br><br>ftp_handler = FTPHandler<br>ftp_handler.dtp_handler = dtp_handler<br></code></pre></td></tr></table></figure>\n\n<p>我们来验证一下是否真的会节制带宽，假设现在用户yang的目录如下：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.32xbm2oc0h40.webp\" alt=\"image\"></p>\n<p>现在FTP客户端要从FTP服务器下载<code>YAPA2.exe</code>文件,首先我们用没有限流的FTP服务器，FTP客户端的下载情况如下所示：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6jdqaavhous0.webp\" alt=\"image\"></p>\n<p>可以看到大约13.5MB的文件，只用了0.04s，速度为374Mbps，下面我们对FTP Server进行限速，限速到<strong>30Kbps</strong>：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.5744w41sjc40.webp\" alt=\"image\"></p>\n<p>可以看到两者速度的差距之大，由此可证明节制带宽是有效的。那么这是怎么做到的呢？</p>\n<p>在pyftpdlib的文档中有这么一段话:</p>\n<blockquote>\n<p>The basic idea behind <code>ThrottledDTPHandler</code> is to wrap sending and receiving in a data counter and temporary “sleep” the data channel so that you burst to no more than x Kb/sec average. When it realizes that more than x Kb in a second are being transmitted it temporary blocks the transfer for a certain number of seconds.</p>\n</blockquote>\n<p>其基本思想在于：<u>将上传/下载的数据封装到一个计数器里，然后让数据流间断性地sleep，即间断地阻塞数据流，以达到不多于 xkbps的速度</u>。</p>\n<h1 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h1><p>如果给虚拟用户指定的目录在FTP Server主机上不存在，会发生什么呢？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">authorizer.add_user(<span class=\"hljs-string\">&#x27;li&#x27;</span>,<span class=\"hljs-string\">&#x27;123456&#x27;</span>,<span class=\"hljs-string\">r&#x27;E:\\\\not_exist_dir&#x27;</span>,perm=<span class=\"hljs-string\">&#x27;elradfmwMT&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.587wyafhuk00.webp\" alt=\"ValueError\"></p>\n<p>我们在这里加个异常处理，没这个目录我就创建一个目录：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">directory = <span class=\"hljs-string\">&quot;E:\\\\not_exist_dir&quot;</span><br><span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> os.path.exists(directory):<br>    os.mkdir(directory)<br>authorizer.add_user(<span class=\"hljs-string\">&#x27;li&#x27;</span>,<span class=\"hljs-string\">&#x27;123456&#x27;</span>,directory,perm=<span class=\"hljs-string\">&#x27;elradfmwMT&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>还有个地方容易出错的就是端口占用问题，如果我们用的端口已经有其它进程在用了，那肯定得出错，所以也要加个异常处理:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">try</span>:<br>    authorizer = DummyAuthorizer()<br>    <span class=\"hljs-comment\"># 添加用户，参数为（用户名,密码,用户目录,权限perm）</span><br>\tauthorizer.add_user(<span class=\"hljs-string\">&#x27;yang&#x27;</span>,<span class=\"hljs-string\">&#x27;123456&#x27;</span>,<span class=\"hljs-string\">r&#x27;E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\yang_ftp&#x27;</span>,perm=<span class=\"hljs-string\">&#x27;elradfmwMT&#x27;</span>)<br>\tauthorizer.add_user(<span class=\"hljs-string\">&#x27;li&#x27;</span>,<span class=\"hljs-string\">&#x27;123456&#x27;</span>,<span class=\"hljs-string\">r&#x27;E:\\\\onedrive\\\\WorkSpace\\\\Python\\\\Source\\\\li_ftp&#x27;</span>,perm=<span class=\"hljs-string\">&#x27;elradfmwMT&#x27;</span>)<br><span class=\"hljs-keyword\">except</span> OSError <span class=\"hljs-keyword\">as</span> e : <br>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&quot;Address already in use&quot;</span> <span class=\"hljs-keyword\">in</span> e :<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;port is using...&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"FTP-Client\"><a href=\"#FTP-Client\" class=\"headerlink\" title=\"FTP Client\"></a>FTP Client</h1><p>我们可以用<code>ftplib</code>做一个简单的FTP客户端，这是python自带的一个package。来看一个示例代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> ftplib <span class=\"hljs-keyword\">import</span> FTP<br><span class=\"hljs-keyword\">import</span> time,tarfile,os<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">ftpconnect</span>(<span class=\"hljs-params\">host,port,username,password</span>):<br>\tftp = FTP()<br>\tftp.connect(host,port)\t\t\t\t\t\t<span class=\"hljs-comment\"># 连接ftp server，指定ip和Port</span><br>\tftp.login(username,password)\t\t<span class=\"hljs-comment\"># 登录</span><br>\t<span class=\"hljs-keyword\">return</span> ftp<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">downloadfile</span>(<span class=\"hljs-params\">ftp,remotepath,localpath</span>):<br>    ftp.cmd(<span class=\"hljs-string\">&#x27;xxx/xxx&#x27;</span>)\t\t<span class=\"hljs-comment\">#进入远程目录</span><br>\tbufsize = <span class=\"hljs-number\">1024</span><br>\tfp = <span class=\"hljs-built_in\">open</span>(localpath,<span class=\"hljs-string\">&#x27;wb&#x27;</span>)<br>\tftp.retrbinary(<span class=\"hljs-string\">&#x27;RETR &#x27;</span>+remotepath,fp.write,bufsize) <span class=\"hljs-comment\"># 接受服务器上文并写入本地文件</span><br>\tftp.set_debuglevel(<span class=\"hljs-number\">0</span>)\t\t\t\t\t\t\t<span class=\"hljs-comment\"># 关闭调试模式</span><br>\tfp.close()\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\"># 调用close，单方面关闭连接</span><br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">uploadfile</span>(<span class=\"hljs-params\">ftp,remotepath,localpath</span>):<br>\tbufsize = <span class=\"hljs-number\">1024</span><br>\tfp = <span class=\"hljs-built_in\">open</span>(localpath,<span class=\"hljs-string\">&#x27;rb&#x27;</span>)<br>\tftp.storbinary(<span class=\"hljs-string\">&quot;STOR &quot;</span>+remotepath,fp,bufsize)\t<span class=\"hljs-comment\"># 上传文件</span><br>\tftp.set_debuglevel(<span class=\"hljs-number\">0</span>)<br>\tfp.close()<br><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>\tftp = ftpconnect(host=<span class=\"hljs-string\">&quot;IP地址&quot;</span>,port=<span class=\"hljs-number\">21</span>,username=<span class=\"hljs-string\">&quot;yang&quot;</span>,password=<span class=\"hljs-string\">&quot;123456&quot;</span>)<br>\tdownloadfile(ftp,<span class=\"hljs-string\">&quot;/text.txt&quot;</span>,<span class=\"hljs-string\">r&quot;E:\\\\Download\\\\text.txt&quot;</span>)<br>\tftp.close()<br></code></pre></td></tr></table></figure>\n\n<p>上面是一个简单的示例，详细的细节可查阅文档。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ol>\n<li><a href=\"https://pyftpdlib.readthedocs.io/en/latest/index.html\">pyftpdlib documentation</a></li>\n<li><a href=\"https://docs.python.org/3/library/ftplib.html\">ftplib —Python 3.11.0 documentation</a></li>\n</ol>\n"},{"title":"TCP Wireshark实验","date":"2022-12-17T09:09:08.000Z","banner_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.272t2u67u9es.webp","index_img":"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.272t2u67u9es.webp","excerpt":"TCP的wireshark实验，对TCP的格式和机制进行研究","_content":"\n 这是《计算机网络自顶向下》（第七版）的配套实验，实验文档在[这里](https://gaia.cs.umass.edu/kurose_ross/wireshark.php)。\n\n# 实验目的\n\n1. 了解TCP的**序列号（SEQ）**和**确认号(ACK)**的作用。\n2. 了解TCP连接的**建立**和销毁。\n3. 了解TCP的拥塞控制算法\n4. 了解TCP的流量控制\n5. TCP连接性能的计算方法\n6. 了解TCP的报文段结构\n\n# 抓包及相关设置\n\n我们只要按照实验文档的指示，在把[这份txt文件](http://gaia.cs.umass.edu/wireshark-labs/alice.txt)送到[服务器](http://gaia.cs.umass.edu/wireshark-labs/TCP-wireshark-file1.html)之前打开wireshark并开始抓包，然后发送该文件，就可以抓到传输过程中涉及的包。\n\n在抓包的过程中有两点需要注意：\n\n1. 包的序列号在Wireshark中默认是相对序列号，可能会和抓的包中的序号对不起来，因此**推荐改成绝对序列号**。修改方法为`Edit→Preferences→Protocols→TCP→Relative sequence numbers disabled`：\n\n   ![修改默认序列号](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.22fwszo4hnz4.webp)\n\n2. 还有就是wireshark过滤表达式的写法，我们过滤的条件是主机和服务器之间传输的TCP包，所以**过滤表达式**可以这么写：`tcp and ((ip.dst==128.119.245.12 and ip.src==主机IP地址) || (ip.dst==ip.src==主机IP地址 and ip.src==128.119.245.12))`\n\n不自己抓包也行，作者给的wireshark抓包结果[在这里]( http://gaia.cs.umass.edu/wireshark-\nlabs/wireshark-traces.zip)（其中的`tcp-ethereal-trace-1`），可以照着这个进行分析。\n\n# TCP基础\n\n1. 启动TCP连接的包的TCP SYN区段的序列号是多少？这个SYN有什么用？\n\n   &emsp;&emsp;当客户端请求建立TCP连接时，SYN字段就会<u>**置1以表示请求建立连接**</u>，序列号是232129012，这是一个随机值。\n\n   ---\n\n   \n\n2. `gaia.cs.umass.edu`发给主机来回复SYN的SYNACK区段的序列号是多少？Acknowledgment的值是多少？`gaia.cs.umass.edu`是如何确定Acknowledgment的值的？这个区段在建立连接中有什么用？\n\n   &emsp;&emsp;SYNACK区段的序列号SEQ = 客户端发来的SEQ+1=232129013，Acknowledgment的值为1，表示<u>**服务器接受到了建立连接的请求并且发送了SYN-ACK的确认包**</u>。\n\n   ---\n\n   \n\n3. 包含“HTTP POST”命令的包的序列号是多少？\n\n      &emsp;&emsp;SEQ = 232129013，`PSH`表示**有数据传输**。\n\n   ---\n\n      \n\n4. 将包含POST命令的TCP包作为第一个包，那马前6个包的的TCP 序列号是多少？发送的时间和接到ACK的时间是什么时候？由此算出的RTT是多少？收到每个ACK后，EstimateRTT是多少？假设第一个EstimateRTT = 第一个包的测量RTT，然后计算后续所有相关值。\n\n   - 第一个是带POST的包：SEQ = 232129013，ACK-SEQ=883061786，LEN=565，RTT=0.023265000 s\n   - 第二个：SEQ = 232129578，ACK-SEQ=883061786，LEN=1460\n   - 第三个：SEQ = 232136878，ACK-SEQ=883061786，LEN=1147\n   - 第四个：SEQ = 232145325，ACK-SEQ=883061786，LEN=892\n   - 第五个：SEQ = 232153517，ACK-SEQ=883061786，LEN=892\n   - 第六个：SEQ = 232161709，ACK-SEQ=883061786，LEN=892\n\n   &emsp;&emsp;关于RTT就不多写了，根据公式算就行。\n\n   ---\n\n      \n\n5. 前六个TCP包的长度是多少？\n\n      &emsp;&emsp;略，上一个问题中有\n\n   ---\n\n      \n\n6. 所有包中，收到的最小的可用缓冲区空间量是多少？？确实接收器缓冲区空间是否会限制发送方发送TCP包的速率？\n\n      &emsp;&emsp;找window最小值就行，这和流量控制有关。\n\n   ---\n\n      \n\n7. 是否有重传包？检查什么以分辨呢？\n\n      &emsp;&emsp;没有重传，因为**序号在增加**：\n\n   <div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.jz740k1fjz4.webp\" alt=\"序号流图\" style=\"zoom:50%;\" /></div>\n\n   ---\n\n      \n\n8. TCP连接的吞吐量怎么算？\n\n   <div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.3g6yz22ane20.webp\" alt=\"吞吐量\" style=\"zoom: 67%;\" /><div>\n\n      &emsp;&emsp;$吞吐量=\\frac{数据传输大小}{所用时间}=\\frac{164090B}{5.297341000s}$\n\n   ---\n\n      ","source":"_posts/TCP Wireshark实验.md","raw":"---\ntitle: TCP Wireshark实验\ndate: 2022-12-17 17:09:08\ntags:\n- TCP\ncategories:\n- 计算机网络\n- 运输层协议\nbanner_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.272t2u67u9es.webp\nindex_img: https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.272t2u67u9es.webp\nexcerpt: TCP的wireshark实验，对TCP的格式和机制进行研究\n---\n\n 这是《计算机网络自顶向下》（第七版）的配套实验，实验文档在[这里](https://gaia.cs.umass.edu/kurose_ross/wireshark.php)。\n\n# 实验目的\n\n1. 了解TCP的**序列号（SEQ）**和**确认号(ACK)**的作用。\n2. 了解TCP连接的**建立**和销毁。\n3. 了解TCP的拥塞控制算法\n4. 了解TCP的流量控制\n5. TCP连接性能的计算方法\n6. 了解TCP的报文段结构\n\n# 抓包及相关设置\n\n我们只要按照实验文档的指示，在把[这份txt文件](http://gaia.cs.umass.edu/wireshark-labs/alice.txt)送到[服务器](http://gaia.cs.umass.edu/wireshark-labs/TCP-wireshark-file1.html)之前打开wireshark并开始抓包，然后发送该文件，就可以抓到传输过程中涉及的包。\n\n在抓包的过程中有两点需要注意：\n\n1. 包的序列号在Wireshark中默认是相对序列号，可能会和抓的包中的序号对不起来，因此**推荐改成绝对序列号**。修改方法为`Edit→Preferences→Protocols→TCP→Relative sequence numbers disabled`：\n\n   ![修改默认序列号](https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.22fwszo4hnz4.webp)\n\n2. 还有就是wireshark过滤表达式的写法，我们过滤的条件是主机和服务器之间传输的TCP包，所以**过滤表达式**可以这么写：`tcp and ((ip.dst==128.119.245.12 and ip.src==主机IP地址) || (ip.dst==ip.src==主机IP地址 and ip.src==128.119.245.12))`\n\n不自己抓包也行，作者给的wireshark抓包结果[在这里]( http://gaia.cs.umass.edu/wireshark-\nlabs/wireshark-traces.zip)（其中的`tcp-ethereal-trace-1`），可以照着这个进行分析。\n\n# TCP基础\n\n1. 启动TCP连接的包的TCP SYN区段的序列号是多少？这个SYN有什么用？\n\n   &emsp;&emsp;当客户端请求建立TCP连接时，SYN字段就会<u>**置1以表示请求建立连接**</u>，序列号是232129012，这是一个随机值。\n\n   ---\n\n   \n\n2. `gaia.cs.umass.edu`发给主机来回复SYN的SYNACK区段的序列号是多少？Acknowledgment的值是多少？`gaia.cs.umass.edu`是如何确定Acknowledgment的值的？这个区段在建立连接中有什么用？\n\n   &emsp;&emsp;SYNACK区段的序列号SEQ = 客户端发来的SEQ+1=232129013，Acknowledgment的值为1，表示<u>**服务器接受到了建立连接的请求并且发送了SYN-ACK的确认包**</u>。\n\n   ---\n\n   \n\n3. 包含“HTTP POST”命令的包的序列号是多少？\n\n      &emsp;&emsp;SEQ = 232129013，`PSH`表示**有数据传输**。\n\n   ---\n\n      \n\n4. 将包含POST命令的TCP包作为第一个包，那马前6个包的的TCP 序列号是多少？发送的时间和接到ACK的时间是什么时候？由此算出的RTT是多少？收到每个ACK后，EstimateRTT是多少？假设第一个EstimateRTT = 第一个包的测量RTT，然后计算后续所有相关值。\n\n   - 第一个是带POST的包：SEQ = 232129013，ACK-SEQ=883061786，LEN=565，RTT=0.023265000 s\n   - 第二个：SEQ = 232129578，ACK-SEQ=883061786，LEN=1460\n   - 第三个：SEQ = 232136878，ACK-SEQ=883061786，LEN=1147\n   - 第四个：SEQ = 232145325，ACK-SEQ=883061786，LEN=892\n   - 第五个：SEQ = 232153517，ACK-SEQ=883061786，LEN=892\n   - 第六个：SEQ = 232161709，ACK-SEQ=883061786，LEN=892\n\n   &emsp;&emsp;关于RTT就不多写了，根据公式算就行。\n\n   ---\n\n      \n\n5. 前六个TCP包的长度是多少？\n\n      &emsp;&emsp;略，上一个问题中有\n\n   ---\n\n      \n\n6. 所有包中，收到的最小的可用缓冲区空间量是多少？？确实接收器缓冲区空间是否会限制发送方发送TCP包的速率？\n\n      &emsp;&emsp;找window最小值就行，这和流量控制有关。\n\n   ---\n\n      \n\n7. 是否有重传包？检查什么以分辨呢？\n\n      &emsp;&emsp;没有重传，因为**序号在增加**：\n\n   <div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.jz740k1fjz4.webp\" alt=\"序号流图\" style=\"zoom:50%;\" /></div>\n\n   ---\n\n      \n\n8. TCP连接的吞吐量怎么算？\n\n   <div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.3g6yz22ane20.webp\" alt=\"吞吐量\" style=\"zoom: 67%;\" /><div>\n\n      &emsp;&emsp;$吞吐量=\\frac{数据传输大小}{所用时间}=\\frac{164090B}{5.297341000s}$\n\n   ---\n\n      ","slug":"TCP Wireshark实验","published":1,"updated":"2022-12-17T13:21:08.204Z","_id":"clbrysqlo0000gsru89trfiym","comments":1,"layout":"post","photos":[],"link":"","content":"<p> 这是《计算机网络自顶向下》（第七版）的配套实验，实验文档在<a href=\"https://gaia.cs.umass.edu/kurose_ross/wireshark.php\">这里</a>。</p>\n<h1 id=\"实验目的\"><a href=\"#实验目的\" class=\"headerlink\" title=\"实验目的\"></a>实验目的</h1><ol>\n<li>了解TCP的<strong>序列号（SEQ）</strong>和**确认号(ACK)**的作用。</li>\n<li>了解TCP连接的<strong>建立</strong>和销毁。</li>\n<li>了解TCP的拥塞控制算法</li>\n<li>了解TCP的流量控制</li>\n<li>TCP连接性能的计算方法</li>\n<li>了解TCP的报文段结构</li>\n</ol>\n<h1 id=\"抓包及相关设置\"><a href=\"#抓包及相关设置\" class=\"headerlink\" title=\"抓包及相关设置\"></a>抓包及相关设置</h1><p>我们只要按照实验文档的指示，在把<a href=\"http://gaia.cs.umass.edu/wireshark-labs/alice.txt\">这份txt文件</a>送到<a href=\"http://gaia.cs.umass.edu/wireshark-labs/TCP-wireshark-file1.html\">服务器</a>之前打开wireshark并开始抓包，然后发送该文件，就可以抓到传输过程中涉及的包。</p>\n<p>在抓包的过程中有两点需要注意：</p>\n<ol>\n<li><p>包的序列号在Wireshark中默认是相对序列号，可能会和抓的包中的序号对不起来，因此<strong>推荐改成绝对序列号</strong>。修改方法为<code>Edit→Preferences→Protocols→TCP→Relative sequence numbers disabled</code>：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.22fwszo4hnz4.webp\" alt=\"修改默认序列号\"></p>\n</li>\n<li><p>还有就是wireshark过滤表达式的写法，我们过滤的条件是主机和服务器之间传输的TCP包，所以<strong>过滤表达式</strong>可以这么写：<code>tcp and ((ip.dst==128.119.245.12 and ip.src==主机IP地址) || (ip.dst==ip.src==主机IP地址 and ip.src==128.119.245.12))</code></p>\n</li>\n</ol>\n<p>不自己抓包也行，作者给的wireshark抓包结果[在这里]( <a href=\"http://gaia.cs.umass.edu/wireshark-\">http://gaia.cs.umass.edu/wireshark-</a><br>labs/wireshark-traces.zip)（其中的<code>tcp-ethereal-trace-1</code>），可以照着这个进行分析。</p>\n<h1 id=\"TCP基础\"><a href=\"#TCP基础\" class=\"headerlink\" title=\"TCP基础\"></a>TCP基础</h1><ol>\n<li><p>启动TCP连接的包的TCP SYN区段的序列号是多少？这个SYN有什么用？</p>\n<p>&emsp;&emsp;当客户端请求建立TCP连接时，SYN字段就会<u><strong>置1以表示请求建立连接</strong></u>，序列号是232129012，这是一个随机值。</p>\n<hr>\n</li>\n<li><p><code>gaia.cs.umass.edu</code>发给主机来回复SYN的SYNACK区段的序列号是多少？Acknowledgment的值是多少？<code>gaia.cs.umass.edu</code>是如何确定Acknowledgment的值的？这个区段在建立连接中有什么用？</p>\n<p>&emsp;&emsp;SYNACK区段的序列号SEQ = 客户端发来的SEQ+1=232129013，Acknowledgment的值为1，表示<u><strong>服务器接受到了建立连接的请求并且发送了SYN-ACK的确认包</strong></u>。</p>\n<hr>\n</li>\n<li><p>包含“HTTP POST”命令的包的序列号是多少？</p>\n<p>   &emsp;&emsp;SEQ = 232129013，<code>PSH</code>表示<strong>有数据传输</strong>。</p>\n<hr>\n</li>\n<li><p>将包含POST命令的TCP包作为第一个包，那马前6个包的的TCP 序列号是多少？发送的时间和接到ACK的时间是什么时候？由此算出的RTT是多少？收到每个ACK后，EstimateRTT是多少？假设第一个EstimateRTT = 第一个包的测量RTT，然后计算后续所有相关值。</p>\n<ul>\n<li>第一个是带POST的包：SEQ = 232129013，ACK-SEQ=883061786，LEN=565，RTT=0.023265000 s</li>\n<li>第二个：SEQ = 232129578，ACK-SEQ=883061786，LEN=1460</li>\n<li>第三个：SEQ = 232136878，ACK-SEQ=883061786，LEN=1147</li>\n<li>第四个：SEQ = 232145325，ACK-SEQ=883061786，LEN=892</li>\n<li>第五个：SEQ = 232153517，ACK-SEQ=883061786，LEN=892</li>\n<li>第六个：SEQ = 232161709，ACK-SEQ=883061786，LEN=892</li>\n</ul>\n<p>&emsp;&emsp;关于RTT就不多写了，根据公式算就行。</p>\n<hr>\n</li>\n<li><p>前六个TCP包的长度是多少？</p>\n<p>   &emsp;&emsp;略，上一个问题中有</p>\n<hr>\n</li>\n<li><p>所有包中，收到的最小的可用缓冲区空间量是多少？？确实接收器缓冲区空间是否会限制发送方发送TCP包的速率？</p>\n<p>   &emsp;&emsp;找window最小值就行，这和流量控制有关。</p>\n<hr>\n</li>\n<li><p>是否有重传包？检查什么以分辨呢？</p>\n<p>   &emsp;&emsp;没有重传，因为<strong>序号在增加</strong>：</p>\n<div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.jz740k1fjz4.webp\" alt=\"序号流图\" style=\"zoom:50%;\" /></div>\n\n<hr>\n</li>\n<li><p>TCP连接的吞吐量怎么算？</p>\n<div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.3g6yz22ane20.webp\" alt=\"吞吐量\" style=\"zoom: 67%;\" /><div>\n\n<p>   &emsp;&emsp;$吞吐量=\\frac{数据传输大小}{所用时间}=\\frac{164090B}{5.297341000s}$</p>\n<hr>\n</li>\n</ol>\n","site":{"data":{}},"more":"<p> 这是《计算机网络自顶向下》（第七版）的配套实验，实验文档在<a href=\"https://gaia.cs.umass.edu/kurose_ross/wireshark.php\">这里</a>。</p>\n<h1 id=\"实验目的\"><a href=\"#实验目的\" class=\"headerlink\" title=\"实验目的\"></a>实验目的</h1><ol>\n<li>了解TCP的<strong>序列号（SEQ）</strong>和**确认号(ACK)**的作用。</li>\n<li>了解TCP连接的<strong>建立</strong>和销毁。</li>\n<li>了解TCP的拥塞控制算法</li>\n<li>了解TCP的流量控制</li>\n<li>TCP连接性能的计算方法</li>\n<li>了解TCP的报文段结构</li>\n</ol>\n<h1 id=\"抓包及相关设置\"><a href=\"#抓包及相关设置\" class=\"headerlink\" title=\"抓包及相关设置\"></a>抓包及相关设置</h1><p>我们只要按照实验文档的指示，在把<a href=\"http://gaia.cs.umass.edu/wireshark-labs/alice.txt\">这份txt文件</a>送到<a href=\"http://gaia.cs.umass.edu/wireshark-labs/TCP-wireshark-file1.html\">服务器</a>之前打开wireshark并开始抓包，然后发送该文件，就可以抓到传输过程中涉及的包。</p>\n<p>在抓包的过程中有两点需要注意：</p>\n<ol>\n<li><p>包的序列号在Wireshark中默认是相对序列号，可能会和抓的包中的序号对不起来，因此<strong>推荐改成绝对序列号</strong>。修改方法为<code>Edit→Preferences→Protocols→TCP→Relative sequence numbers disabled</code>：</p>\n<p><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.22fwszo4hnz4.webp\" alt=\"修改默认序列号\"></p>\n</li>\n<li><p>还有就是wireshark过滤表达式的写法，我们过滤的条件是主机和服务器之间传输的TCP包，所以<strong>过滤表达式</strong>可以这么写：<code>tcp and ((ip.dst==128.119.245.12 and ip.src==主机IP地址) || (ip.dst==ip.src==主机IP地址 and ip.src==128.119.245.12))</code></p>\n</li>\n</ol>\n<p>不自己抓包也行，作者给的wireshark抓包结果[在这里]( <a href=\"http://gaia.cs.umass.edu/wireshark-\">http://gaia.cs.umass.edu/wireshark-</a><br>labs/wireshark-traces.zip)（其中的<code>tcp-ethereal-trace-1</code>），可以照着这个进行分析。</p>\n<h1 id=\"TCP基础\"><a href=\"#TCP基础\" class=\"headerlink\" title=\"TCP基础\"></a>TCP基础</h1><ol>\n<li><p>启动TCP连接的包的TCP SYN区段的序列号是多少？这个SYN有什么用？</p>\n<p>&emsp;&emsp;当客户端请求建立TCP连接时，SYN字段就会<u><strong>置1以表示请求建立连接</strong></u>，序列号是232129012，这是一个随机值。</p>\n<hr>\n</li>\n<li><p><code>gaia.cs.umass.edu</code>发给主机来回复SYN的SYNACK区段的序列号是多少？Acknowledgment的值是多少？<code>gaia.cs.umass.edu</code>是如何确定Acknowledgment的值的？这个区段在建立连接中有什么用？</p>\n<p>&emsp;&emsp;SYNACK区段的序列号SEQ = 客户端发来的SEQ+1=232129013，Acknowledgment的值为1，表示<u><strong>服务器接受到了建立连接的请求并且发送了SYN-ACK的确认包</strong></u>。</p>\n<hr>\n</li>\n<li><p>包含“HTTP POST”命令的包的序列号是多少？</p>\n<p>   &emsp;&emsp;SEQ = 232129013，<code>PSH</code>表示<strong>有数据传输</strong>。</p>\n<hr>\n</li>\n<li><p>将包含POST命令的TCP包作为第一个包，那马前6个包的的TCP 序列号是多少？发送的时间和接到ACK的时间是什么时候？由此算出的RTT是多少？收到每个ACK后，EstimateRTT是多少？假设第一个EstimateRTT = 第一个包的测量RTT，然后计算后续所有相关值。</p>\n<ul>\n<li>第一个是带POST的包：SEQ = 232129013，ACK-SEQ=883061786，LEN=565，RTT=0.023265000 s</li>\n<li>第二个：SEQ = 232129578，ACK-SEQ=883061786，LEN=1460</li>\n<li>第三个：SEQ = 232136878，ACK-SEQ=883061786，LEN=1147</li>\n<li>第四个：SEQ = 232145325，ACK-SEQ=883061786，LEN=892</li>\n<li>第五个：SEQ = 232153517，ACK-SEQ=883061786，LEN=892</li>\n<li>第六个：SEQ = 232161709，ACK-SEQ=883061786，LEN=892</li>\n</ul>\n<p>&emsp;&emsp;关于RTT就不多写了，根据公式算就行。</p>\n<hr>\n</li>\n<li><p>前六个TCP包的长度是多少？</p>\n<p>   &emsp;&emsp;略，上一个问题中有</p>\n<hr>\n</li>\n<li><p>所有包中，收到的最小的可用缓冲区空间量是多少？？确实接收器缓冲区空间是否会限制发送方发送TCP包的速率？</p>\n<p>   &emsp;&emsp;找window最小值就行，这和流量控制有关。</p>\n<hr>\n</li>\n<li><p>是否有重传包？检查什么以分辨呢？</p>\n<p>   &emsp;&emsp;没有重传，因为<strong>序号在增加</strong>：</p>\n<div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.jz740k1fjz4.webp\" alt=\"序号流图\" style=\"zoom:50%;\" /></div>\n\n<hr>\n</li>\n<li><p>TCP连接的吞吐量怎么算？</p>\n<div align=\"center\"><img src=\"https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.3g6yz22ane20.webp\" alt=\"吞吐量\" style=\"zoom: 67%;\" /><div>\n\n<p>   &emsp;&emsp;$吞吐量=\\frac{数据传输大小}{所用时间}=\\frac{164090B}{5.297341000s}$</p>\n<hr>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl8fcvhaq000304ruhtu74tux","category_id":"cl8fcvhay000404ru89b4f3et","_id":"cl8fcvhb4000704ru30z276ww"},{"post_id":"cl8p9um2a0000pcru8uvlbvxu","category_id":"cl8p9um2q0001pcrub6kralm5","_id":"cl8p9um300004pcrucgowf18s"},{"post_id":"cl8qxsjgw0000bkru2ebtf3xh","category_id":"cl8qxsjhb0001bkrugm3rcwgb","_id":"cl8qxsjhl0004bkru0318en0a"},{"post_id":"cl8vrh3du0000gsru5bzcb2tg","category_id":"cl8p9um2q0001pcrub6kralm5","_id":"cl8vrh3eh0004gsrubjnue284"},{"post_id":"cl8vrh3du0000gsru5bzcb2tg","category_id":"cl8vrh3ea0002gsrucddue00z","_id":"cl8vrh3eh0005gsru2oocguju"},{"post_id":"cl8p9um2a0000pcru8uvlbvxu","category_id":"cl8vrh3ea0002gsrucddue00z","_id":"cl8vrh3eh0006gsruezyahap8"},{"post_id":"cl99pv6r10000tkru6lo72m0h","category_id":"cl99pv6rk0002tkrugecjc3fo","_id":"cl99pv6ry0006tkruaxnsc7bu"},{"post_id":"cl99pv6r10000tkru6lo72m0h","category_id":"cl99pv6rv0005tkru9v8rco1i","_id":"cl99pv6ry0007tkru9ot7hxaq"},{"post_id":"cl99q176300001oru70qv4tex","category_id":"cl99q176l00011oru8u0w8oo4","_id":"cl99q177100071oruhf3javze"},{"post_id":"cl99q176300001oru70qv4tex","category_id":"cl99q176x00041oru3u829a76","_id":"cl99q177100081oru8g36470p"},{"post_id":"cl9ij7evq0000j4ru8z5h6ldz","category_id":"cl9ij7ew50001j4ru1lizesi2","_id":"cl9ij7ewi0005j4rud8fpf3vy"},{"post_id":"clado7pvv000094ru9e3v61ru","category_id":"cl99q176l00011oru8u0w8oo4","_id":"clado7pwk000594rueukgdijh"},{"post_id":"clado7pvv000094ru9e3v61ru","category_id":"cl99q176x00041oru3u829a76","_id":"cladorwve0000a0ru71b1f2ab"},{"post_id":"clap1pte80000u4ru3gz0024k","category_id":"cl99q176l00011oru8u0w8oo4","_id":"clap1ptey0003u4ru9fow5kqy"},{"post_id":"clap1pte80000u4ru3gz0024k","category_id":"cl99q176x00041oru3u829a76","_id":"clap1ptf30005u4rueqt87utk"},{"post_id":"claqb7e9n0000dsrubw9q2reu","category_id":"claqb7ea60001dsru3jcs08zl","_id":"claqb7eas0004dsrug1lf9lnw"},{"post_id":"claqq0vo300009crueq0jgaox","category_id":"cl99pv6rk0002tkrugecjc3fo","_id":"claqq0vp200049crue4dy6vyn"},{"post_id":"claqq0vo300009crueq0jgaox","category_id":"claqq0voy00029cru5k6w9eig","_id":"claqq0vp200059crug5pu6dxf"},{"post_id":"clbrysqlo0000gsru89trfiym","category_id":"cl99pv6rk0002tkrugecjc3fo","_id":"clbrysqm00004gsrucbw70dzy"},{"post_id":"clbrysqlo0000gsru89trfiym","category_id":"clbrysqly0002gsrudqtr4xmh","_id":"clbrysqm00005gsruap5xek3z"}],"PostTag":[{"post_id":"cl8fcvhaq000304ruhtu74tux","tag_id":"cl8fcvhb1000504ruboheam2v","_id":"cl8fcvhb3000604ru92m4d8ft"},{"post_id":"cl8p9um2a0000pcru8uvlbvxu","tag_id":"cl8p9um2x0002pcru5czsbd3r","_id":"cl8p9um2z0003pcru8v962ja2"},{"post_id":"cl8qxsjgw0000bkru2ebtf3xh","tag_id":"cl8qxsjhh0002bkru6pkwc20q","_id":"cl8qxsjhp0007bkrugkxehih1"},{"post_id":"cl8qxsjgw0000bkru2ebtf3xh","tag_id":"cl8qxsjhj0003bkru4e7b1ari","_id":"cl8qxsjhp0008bkrue1c1ddk5"},{"post_id":"cl8qxsjgw0000bkru2ebtf3xh","tag_id":"cl8qxsjhl0005bkru8n1ydk8z","_id":"cl8qxsjhp0009bkru2915618l"},{"post_id":"cl8qxsjgw0000bkru2ebtf3xh","tag_id":"cl8qxsjhn0006bkrubr9l78s9","_id":"cl8qxsjhp000abkrucch0htjn"},{"post_id":"cl8vrh3du0000gsru5bzcb2tg","tag_id":"cl8p9um2x0002pcru5czsbd3r","_id":"cl8vrh3e90001gsru0gvi0k1o"},{"post_id":"cl99pv6r10000tkru6lo72m0h","tag_id":"cl99pv6rs0003tkru1twzfon9","_id":"cl99pv6rv0004tkru63qd9kym"},{"post_id":"cl9ij7evq0000j4ru8z5h6ldz","tag_id":"cl99q176u00031oru1uoj7ihz","_id":"cl9ij7ewh0003j4ru0qg7behm"},{"post_id":"cl9ij7evq0000j4ru8z5h6ldz","tag_id":"cl9ij7ewe0002j4rucjro3x6l","_id":"cl9ij7ewi0004j4ru71kc4xmt"},{"post_id":"clado7pvv000094ru9e3v61ru","tag_id":"clap1ptej0001u4ru0ts4dre4","_id":"clap1ptf30004u4ru1uf2058u"},{"post_id":"clap1pte80000u4ru3gz0024k","tag_id":"clap1ptej0001u4ru0ts4dre4","_id":"clap1ptf80007u4rucsdj91gn"},{"post_id":"cl99q176300001oru70qv4tex","tag_id":"clap1ptej0001u4ru0ts4dre4","_id":"clap1ptf80008u4ru2ggpc5zz"},{"post_id":"claqb7e9n0000dsrubw9q2reu","tag_id":"claqb7eak0002dsru05w1e635","_id":"claqb7ear0003dsru45a0b58f"},{"post_id":"claqq0vo300009crueq0jgaox","tag_id":"claqq0vok00019cru4vp5cw9c","_id":"claqq0vp100039crugm2h7whx"},{"post_id":"clbrysqlo0000gsru89trfiym","tag_id":"clbrysqlu0001gsru1rf6gkop","_id":"clbrysqlz0003gsrudjw4406s"}],"Tag":[{"name":"Test","_id":"cl8fcvhb1000504ruboheam2v"},{"name":"文化","_id":"cl8o126ey0002o4ru7r7501fn"},{"name":"中国经济","_id":"cl8p9um2x0002pcru5czsbd3r"},{"name":"勇气心理学","_id":"cl8pgmend0001z0ru1tqp1467"},{"name":"操作系统","_id":"cl8qxsjhh0002bkru6pkwc20q"},{"name":"Linux","_id":"cl8qxsjhj0003bkru4e7b1ari"},{"name":"软硬件交互","_id":"cl8qxsjhl0005bkru8n1ydk8z"},{"name":"BIOS","_id":"cl8qxsjhn0006bkrubr9l78s9"},{"name":"P2P","_id":"cl99pv6rs0003tkru1twzfon9"},{"name":"web","_id":"cl99q176s00021oru7cxw3ah5"},{"name":"java","_id":"cl99q176u00031oru1uoj7ihz"},{"name":"OOP","_id":"cl9ij7ewe0002j4rucjro3x6l"},{"name":"servlet","_id":"clado7pw9000194ruec03etqt"},{"name":"JavaWeb","_id":"clap1ptej0001u4ru0ts4dre4"},{"name":"矩阵","_id":"claqb7eak0002dsru05w1e635"},{"name":"文件共享协议","_id":"claqq0vok00019cru4vp5cw9c"},{"name":"TCP","_id":"clbrysqlu0001gsru1rf6gkop"}]}}