<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>稀疏矩阵及其运算</title>
    <link href="/2022/11/21/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/"/>
    <url>/2022/11/21/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="稀疏矩阵（数组）简介"><a href="#稀疏矩阵（数组）简介" class="headerlink" title="稀疏矩阵（数组）简介"></a>稀疏矩阵（数组）简介</h1><p>假设我们现在要写一个五子棋程序，其中有<u>保存当前棋盘</u>和<u>恢复上次棋盘</u>的功能，那么显然需要一种方法去保存棋盘。我们很容易想到用一个<strong>二维数组</strong>去保留棋盘：</p><p><img src="https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.6q07k59ehhw0.webp" alt="五子棋"></p><p>我们可以看到棋盘上有许多空白，<u>这些无意义的空白数据都占据着存储空间</u>，我们实际需要保存的只是<strong>棋子的位置和值</strong>，而不是整个棋盘，那么我们怎么去掉这些无意义的数据呢？</p><p>首先， 上面这种无意义数据占大多数的二维矩阵被称为<strong>稀疏矩阵</strong>，其判别条件是：</p><blockquote><p>假设有$m * n$的矩阵，其有t个非0元素，那么设$δ = \frac{t}{m * n}$，δ被称为稀疏因子，如果δ&lt;=0.05，那么该矩阵就是稀疏矩阵。</p></blockquote><p>针对于稀疏矩阵，我们可以用三元表来保存其<strong>行列数</strong>、<strong>非0元素的数量</strong>以及<strong>各非0元素的位置</strong>，比如上面的棋盘就可以用下面这样的稀疏矩阵表示：</p><table><thead><tr><th align="center"></th><th align="center">row</th><th align="center">col</th><th align="center">val</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">11（行数）</td><td align="center">11（列数）</td><td align="center">2（非0元素数）</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">3</td><td align="center">2</td></tr></tbody></table><h1 id="稀疏矩阵与矩阵之间的转换"><a href="#稀疏矩阵与矩阵之间的转换" class="headerlink" title="稀疏矩阵与矩阵之间的转换"></a>稀疏矩阵与矩阵之间的转换</h1><p>稀疏矩阵与矩阵之间的转换思路比较简单，下面只作简单的梳理。</p><p class="note note-primary">矩阵→稀疏矩阵</p><ol><li>遍历矩阵，得到非0元素数<code>numCount</code>。</li><li>然后用<code>numCount</code>初始化稀疏矩阵<code>sparseArr[numCount+1][3]</code>，<code>numCount+1</code>是因为<code>sparseArr[0]</code>要存储矩阵的行列数，以及非0元素数。</li><li>之后遍历矩阵，存储非0元素数即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*统计非0元素数*/</span><br><span class="hljs-type">int</span> <span class="hljs-variable">numCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] row : chessArr1)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : row)&#123;<br><span class="hljs-keyword">if</span>(num !=<span class="hljs-number">0</span>)&#123;<br>numCount++;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> sparseArr[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCount+<span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br><span class="hljs-comment">/*第一行存储矩阵的行列数、非0元素数*/</span><br>sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] =<span class="hljs-number">11</span>;<br>sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = numCount;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;chessArr1.length;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;chessArr1.length;j++)&#123;<br><span class="hljs-keyword">if</span>(chessArr1[i][j]!=<span class="hljs-number">0</span>)&#123;<br>sparseArr[index][<span class="hljs-number">0</span>] = i;<br>sparseArr[index][<span class="hljs-number">1</span>] = j;<br>sparseArr[index++][<span class="hljs-number">2</span>] = chessArr1[i][j];<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">稀疏矩阵→矩阵</p><p>这就没什么好说的了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] chessArr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]][sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;sparseArr.length;i++)&#123;<br>chessArr2[sparseArr[i][<span class="hljs-number">0</span>]][sparseArr[i][<span class="hljs-number">1</span>]] = sparseArr[i][<span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="稀疏矩阵的快速转置"><a href="#稀疏矩阵的快速转置" class="headerlink" title="稀疏矩阵的快速转置"></a>稀疏矩阵的快速转置</h1><div align="center"><img src="https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/image.2ioamg882ww0.webp" alt="image" style="zoom:50%;" /></div><p>稀疏矩阵的快速转置是稀疏矩阵的重点，其基本思想就是<strong>空间换时间</strong>，下面我们来看看。</p><p>设我们现在有这样一个三元表a(<strong>省略掉a[0]</strong>)用于存储稀疏矩阵M：</p><table><thead><tr><th align="center">row</th><th align="center">col</th><th align="center">val</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td><td align="center">12</td></tr><tr><td align="center">1</td><td align="center">3</td><td align="center">9</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">-3</td></tr><tr><td align="center">3</td><td align="center">6</td><td align="center">14</td></tr><tr><td align="center">4</td><td align="center">3</td><td align="center">24</td></tr><tr><td align="center">5</td><td align="center">2</td><td align="center">15</td></tr><tr><td align="center">6</td><td align="center">1</td><td align="center">18</td></tr><tr><td align="center">6</td><td align="center">4</td><td align="center">7</td></tr></tbody></table><p>矩阵转置就是将<u>元素的行列调换</u>，我们这里也很简单，就直接调换行列就好了，但是三元表是<strong>按顺序存储</strong>的，所以调换完后，我们还要按行排序，正确的转置后三元表b应该如下所示：</p><table><thead><tr><th align="center">row</th><th align="center">col</th><th align="center">val</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">3</td><td align="center">-3</td></tr><tr><td align="center">1</td><td align="center">6</td><td align="center">18</td></tr><tr><td align="center">2</td><td align="center">1</td><td align="center">12</td></tr><tr><td align="center">2</td><td align="center">5</td><td align="center">15</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">9</td></tr><tr><td align="center">3</td><td align="center">4</td><td align="center">24</td></tr><tr><td align="center">4</td><td align="center">6</td><td align="center">-7</td></tr><tr><td align="center">6</td><td align="center">3</td><td align="center">14</td></tr></tbody></table><p>根据上述思路，我们可以看出重点就在于这个<font color=purple><strong>次序的问题</strong></font>上，根据对次序的不同处理方式，我们就有了两种转置的方法。</p><h2 id="扫描转置法"><a href="#扫描转置法" class="headerlink" title="扫描转置法"></a>扫描转置法</h2><p>这个方法很简单，就是<strong>扫描三元表a的第二列来转置</strong>，a的第二列也就是列序，a的列序就是b的行序。其算法复杂度很明显是$O（n^2）$，时间复杂度太高了，这种方法就不多加赘述了。</p><h2 id="快速转置法"><a href="#快速转置法" class="headerlink" title="快速转置法"></a>快速转置法</h2><p>如果我们<strong>知道三元表a中的每一项在转置后的新三元表b中的位置</strong>，然后直接放上去，那不就不需要$O(n^2)$的时间复杂度了？快速转置正是基于这种思路实现的。</p><p>那么我们怎么知道各项在新三元表中的位置的呢？</p><blockquote><p>下面的<code>a:col=2</code>表示a中某项的<code>col列</code>值为2的情况。</p></blockquote><p>注意三元表a的col就是新三元表b的row，<strong>我们开始读a的col列</strong>。a的第一项的col是2，因为a：col=2就是b：row=2，所以在b中占据第3、4行，那么就从第3位开始放，接下来如果又读到一个a：col=2，那么就放在第4位，因为a：col=2只有两项，所以b的第五位不会被b : row=2占据，b的第5、6位是留给b : row = 3的。通过这种思想，我们就能在三元表中找到相应的位置，这就是稀疏矩阵的原理。</p><p>下面我们来实现这个算法。</p><p class="note note-primary">空间换时间：求num[]和cpot[]</p><p>首先，我们需要两个变量：</p><hr><ul><li>num[col]：用于记录原三元表a: col = col的项的数目。</li><li>cpot[col]：用于记录原三元表a中列数为col的项在新三元表中的首位置，例如col=2，则cpot[col]=3。</li></ul><hr><p>那么三元表a的num[]和cpot[]值为：</p><table><thead><tr><th align="center">col</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th></tr></thead><tbody><tr><td align="center">num[col]</td><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">cpot[col]</td><td align="center">1</td><td align="center">3</td><td align="center">5</td><td align="center">7</td><td align="center">8</td><td align="center">8</td><td align="center">9</td></tr></tbody></table><p>求这两数组的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] M = ...; <span class="hljs-comment">//转置前的稀疏矩阵M</span><br><span class="hljs-type">int</span>[][] sparseArrA = ...;  <span class="hljs-comment">//转置前的三元表A</span><br><span class="hljs-type">int</span>[][] sparseArrB = ...;  <span class="hljs-comment">//转置后的三元表B</span><br><span class="hljs-type">int</span>[] num = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[M[<span class="hljs-number">0</span>].length+<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span>[] cpot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[num.length];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col=<span class="hljs-number">1</span>;col&lt;=num.length;col++)&#123;<br>    num[col] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*初始化num[]，统计每列各有多少个非0元素*/</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;t&lt;sparseArrA.length;t++)&#123;<br><span class="hljs-comment">/*num[三元表Acol列]++*/</span><br>    num[sparseArrA[t][<span class="hljs-number">1</span>]]++<br>&#125;<br><br><span class="hljs-comment">/*根据num[]初始化cpot[col]，统计a每一列的元素在b中的位置*/</span><br>cpot[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">2</span>;p&lt;cpot.length;p++)&#123;<br>    cpot[p] = cpot[p-<span class="hljs-number">1</span>]+num[p-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">快速转置</p><p>下面，我们就可以进行快速转置了，具体步骤如下：</p><ol><li>我们遍历三元表A的col列，得到每项的col</li><li>根据col，得到cpot[col]，这就是三元表A中该项在三元表B的位置。</li><li>将该项转置后填入三元表B，然后cpot[col]++。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">1</span>;p&lt;=sparseArrA.length;p++)&#123;<br>    col = sparseArrA[p][<span class="hljs-number">1</span>];<br>    q = cpot[col];<br>    sparseArrB[q][<span class="hljs-number">0</span>] = sparseArrA[p][<span class="hljs-number">1</span>];  <br>    sparseArrB[q][<span class="hljs-number">1</span>] = sparseArrA[p][<span class="hljs-number">0</span>];  <br>    sparseArrB[q][<span class="hljs-number">2</span>] = sparseArrA[p][<span class="hljs-number">2</span>];<br>    ++cpot[col];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java多态与动态绑定</title>
    <link href="/2022/10/16/java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E6%80%81%E7%BB%91%E5%AE%9A/"/>
    <url>/2022/10/16/java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E6%80%81%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><p>我们先来聊聊什么是<code>面向对象（OOP）</code>。编程语言干的活绝大部分是<u>将实际的问题映射到机器模型之中</u>，而映射问题的思路是五花八门的。<u>面向对象</u>的基本思路就是<strong>用编程语言去表达实际问题的元素，围绕这些元素进行操作</strong>，这些元素在java中就被称为<code>对象</code>。</p><p>比如说我现在要用OOP的思想去描述一个苹果，那么我会说：这个苹果的ID=xxxxx，颜色=红色，种类=红富士，产地=某地，是否打过药=是，除此之外，我还会围绕这个苹果进行操作，比如把它卖给张三，又比如吃掉它，这就是一个<strong>为实际问题的元素建立对象的过程</strong>。像什么苹果的ID、颜色、产地等等都是这个对象的<u>状态（属性）</u>，而被卖掉或者是被吃掉就是这个对象的行为，每个对象是不同的，因此对象还有自己唯一的<u>标识</u>。</p><blockquote><p><strong>对象的定义</strong>：一个对象具有自己的状态，行为和标识。这意味着对象有自己的内部数据(提供状态)、方法 (产生行为)，并彼此区分（每个对象在内存中都有唯一的地址）</p></blockquote><p>一个苹果对象很好管理，那如果是成百上千的苹果对象呢？难道要一个个的给它们建立对象吗？这显然不现实，这就要提到<code>类(class)</code>的概念。一个地方产的苹果往往有许多特征是一样的，比如产地啊，种类啊，是否打过药啊，那么我们就可以将其<strong>抽象</strong>为一个类，比如<code>张三果园苹果</code>，<strong>对象都从这个类生成，进行自己个性化的定制</strong>。</p><p>我们使用<u>类</u>来将一个对象的各种内部数据和行为封装在一起，以此来表达实际问题的元素。但有一个问题没有解决：<u>如果我们现在有一批<code>杰克果园苹果</code>，是从外国进口的，这个时候再创建一个新类也太麻烦了吧？</u></p><p>比较好的解决办法是什么呢？<u>我们不创建<code>张三果园苹果类</code>了，而是创建一个<code>苹果类</code>（<strong>注意不是苹果对象</strong>），其属性和行为和``张三果园苹果类<code>差不多，但是多个</code>果园名称`属性，然后张三果园和杰克果园产的苹果都<font color=purple><strong>继承</strong></font>自这个苹果类。</u>什么是继承呢，也就是<strong>is a</strong>的关系，杰克产的苹果是苹果，张三产的苹果也是苹果，他们都有苹果类的属性和行为，除此之外，还可以定制自己苹果的属性和行为。</p><p>以上的概念呢十分基础，但是还是要理理清的。</p><h1 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h1><p>我们常常听到：<u>对象是类的实例化</u>，什么意思呢？打个比方，我们正在为一批刚摘下来的水果设定属性，我们操作的是真真正正的苹果，也就是苹果对象1，苹果对象2，苹果对象3，苹果对象4这样一个个数过来的，但是设定属性时，是根据苹果类一批次设定的，而不管它是苹果对象几。</p><p>拓展一下思路，实际上<strong>我们处理对象，不仅不把它看成是其所属的类，还看成其所属的基类</strong>。假如有一个水果类，其下面有苹果子类，香蕉子类，西瓜子类等等，<font color=purple>我们设定一个eat<strong>方法</strong>，我们就不需要知道其是什么水果类型，反正是水果都能吃</font>。这就是<strong>多态</strong>的思想，那么多态有什么好处呢？</p><p>我们来举个例子，如果Java不支持多态，水果们应该这些写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span>&#123;<br>    <span class="hljs-type">int</span> id;<br>    String name;<br>    String color;<br>    String origin;<br>   <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOrigin</span><span class="hljs-params">(String origin)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(String color)</span>;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">fruit</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatApple</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watermelon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">fruit</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatWatermelon</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">banana</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatBanana</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们要吃个水果，每个水果类里都要定义一遍，如果调用这些方法，就会是下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">viod <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>     <span class="hljs-type">Apple</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>    <span class="hljs-type">Watermelon</span> <span class="hljs-variable">watermelon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>();<br>    <span class="hljs-comment">//吃苹果</span><br>    apple.eatApple();<br>    <span class="hljs-comment">//吃西瓜</span><br>   Watermelon.eatWatermelon();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用多态的思想，编写的水果类会是下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span>&#123;<br>    ...<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatFruit</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">fruit</span>&#123;<br>    <span class="hljs-comment">//不需要定义自己的方法</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watermelon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">fruit</span>&#123;<br>   <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">banana</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>现在吃水果的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">viod <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Fruit</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>    <span class="hljs-type">Fruit</span> <span class="hljs-variable">watermelon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>();<br>    <span class="hljs-comment">//吃苹果</span><br>    apple.eatFruit();<br>    <span class="hljs-comment">//吃西瓜</span><br>   Watermelon.eatFruit();<br>&#125;<br></code></pre></td></tr></table></figure><p>多态这层抽象使得软件系统更加好维护，可扩展性更强，加一个西瓜不需要我们再去加一个吃西瓜的方法，直接使用<code>eatFruit</code>方法就可以了。</p><h1 id="重写-override-和重载-overload"><a href="#重写-override-和重载-overload" class="headerlink" title="重写(override)和重载(overload)"></a>重写(override)和重载(overload)</h1><blockquote><ul><li><strong>重写(override)<strong>：</strong>子类对父类</strong>方法的实现过程进行重新编写，但是<strong>方法名，参数的类型和顺序是一样的</strong>，和<u>多态</u>有关。</li><li><strong>重载(overload)<strong>：</strong>在一个类里面</strong>，方法名相同，但是参数不同，比较常用的是构造器重载。</li></ul></blockquote><p>分清重写和重载的区别是很重要的，重写和本篇的主题多态有关，因为其涉及父子类相同的方法。举个例子，如果我们想定义自己吃苹果的方法，在java中就可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span>&#123;<br>    ...<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatFruit</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">fruit</span>&#123;<br>    <span class="hljs-meta">@override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatFruit</span><span class="hljs-params">()</span>&#123;<br>        print(<span class="hljs-string">&quot;这是李四吃苹果的方法&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watermelon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">fruit</span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">banana</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这就是多态中的override，这也引出一个核心问题：<font color=purple>计算机怎么知道我们要调用的是父类还是子类的方法呢？</font>这就要说到<u>绑定</u>的问题了。</p><h1 id="多态在JAVA的实现"><a href="#多态在JAVA的实现" class="headerlink" title="多态在JAVA的实现"></a>多态在JAVA的实现</h1><h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2><blockquote><p><strong>绑定</strong>：将一个方法的调用和一个方法的主体关联起来，比如将eatFruit()方法和apple关联起来。</p></blockquote><p>绑定分为<strong>静态绑定</strong>和<strong>动态绑定</strong>。</p><p>先来说说静态绑定，所谓的静态绑定<font color=purple>就是在<strong>编译期</strong>就进行方法和类的绑定</font>，一般用于<u>访问对象的属性</u>或者是<u>final、static和private修饰的方法</u>，这类方法的特征就是<strong>确定无疑</strong>。</p><p>动态绑定，就是<font color=purple>该对象的真实类型只有<strong>运行时</strong>才能确定，所以调用到的方法是运行时对象真实类型的方法</font>，在java中，除了静态绑定中提到的情况，其它都是动态绑定。</p><p>重写(override)就是动态绑定，也就是运行时绑定；重载(overload)就是静态绑定，也就是编译时绑定。</p><h2 id="动态绑定实现多态"><a href="#动态绑定实现多态" class="headerlink" title="动态绑定实现多态"></a>动态绑定实现多态</h2><p>首先举一个经典例子,下面调用的是apple的方法还是基类Fruit的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">viod <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// apple实现了自己的eatFruit方法</span><br>    <span class="hljs-type">Fruit</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>    <br>    apple.eatFruit();<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>因为子类apple定义了自己的eatFruit，所以调用的是apple的方法。由此可以看出，<u>当通过子类的实例去调用一系列的实例方法（包括一个方法调用的另一个方法）时，将优先和子类本身包含的实例方法动态绑定，如果子类没有定义这个实例方法，才会和从父类中继承来的实例方法动态绑定</u>。</p><p>JVM在准备阶段会生成一个<u>方法表</u>，里面存储着每个类的<strong>每个方法对应的内存地址</strong>，子类方法表中的方法包含父类的所有方法， 且<strong>每个方法和父类方法的索引值（方法在方法表中的位置）相同</strong>。比如父类Fruit的方法eatFruit的索引号是1，Apple子类如果没有重写该方法，那么该索引号1指向的就是父类Fruit的eatFruit；如果其重写了该方法，那么Apple子类方法表中的索引号1就指向自己的eatFruit。</p><p>在动态绑定的时，JVM会先根据动态类型获取对应类的方法表，再根据索引获取方法表中对应方法的内存地址。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown样式测试</title>
    <link href="/2022/09/23/Markdown%E6%A0%BC%E5%BC%8F%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/09/23/Markdown%E6%A0%BC%E5%BC%8F%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;This a test.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p class="note note-primary">primary标签</p><p class="note note-info">info标签</p><p class="note note-success">success标签</p><p class="note note-danger">danger标签</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">语法1：<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>&gt;</span></span>primary标签<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><br>语法2: <br>&#123;% note success %&#125;<br>文字 或者 <span class="hljs-code">`markdown`</span> 均可<br>&#123;% endnote %&#125;<br><br>行内标签： <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;label label-primary&quot;</span>&gt;</span></span>Label<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| 姓名  | 年龄  | 介绍  |<br>|:---:|:---:|:---:|<br>| a   | 20  | 1   |<br>| b   | 20  | 2   |<br>| c   | 18  | 3   |<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">姓名</th><th align="center">年龄</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">20</td><td align="center">1</td></tr><tr><td align="center">b</td><td align="center">20</td><td align="center">2</td></tr><tr><td align="center">c</td><td align="center">18</td><td align="center">3</td></tr></tbody></table><h1 id="页面嵌套"><a href="#页面嵌套" class="headerlink" title="页面嵌套"></a>页面嵌套</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://hexo.fluid-dev.com/&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;topFrame&quot;</span> <span class="hljs-attr">scrolling</span>=<span class="hljs-string">&quot;yes&quot;</span>  <span class="hljs-attr">noresize</span>=<span class="hljs-string">&quot;noresize&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;topFrame&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></span><br></code></pre></td></tr></table></figure><iframe src="https://hexo.fluid-dev.com/" width="100%" height="500" name="topFrame" scrolling="yes"  noresize="noresize" frameborder="0" id="topFrame"></iframe><h1 id="折叠标签"><a href="#折叠标签" class="headerlink" title="折叠标签"></a>折叠标签</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">details</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">summary</span>&gt;</span></span>这是一个折叠块<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">summary</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span></span>行一<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span></span>行二<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://www.jianguoyun.com/c/dl-file/2022923102812.jpg?dt=rin5ma&amp;sd=dlmq2&amp;kv=MTE4NjU5OTA4MUBxcS5jb20&amp;vr=1&amp;ud=7ye0WsQXUj-HvwzVtVeuuWw0Lg28JNzUwHpN3F7Ivw4&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;wechat&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">details</span>&gt;</span></span><br></code></pre></td></tr></table></figure><details><summary>这是一个折叠块</summary><p><b>行一</b></p><p><b>行二</b></p><img src="https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/凌波丽3.6folue9m3wk0.webp" alt="凌波丽3"></details><h1 id="图片引用"><a href="#图片引用" class="headerlink" title="图片引用"></a>图片引用</h1><p><img src="https://cdn.staticaly.com/gh/sail-Yang/myImage@main/img/%E5%87%8C%E6%B3%A2%E4%B8%BD3.6folue9m3wk0.webp" alt="凌波丽3"></p><h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">脚注演示<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="脚注内容演示">[1]</span></a></sup><br>[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">脚注内容演示</span><br>[<span class="hljs-symbol">^2</span>]: <span class="hljs-link">脚注内容演示</span><br><br>脚注演示<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="脚注内容演示">[2]</span></a></sup><br>[<span class="hljs-symbol">^2</span>]: <span class="hljs-link">脚注内容演示</span><br></code></pre></td></tr></table></figure><p>脚注演示<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="脚注内容演示">[1]</span></a></sup></p><p>脚注演示<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="脚注内容演示">[2]</span></a></sup></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>脚注内容演示<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>脚注内容演示<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>脚注内容演示<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
